# 6. 为事务分配`Undo`页面链表详细过程

接下来以事务对普通表的记录做改动为例,来梳理一下事务执行过程中分配`Undo`页面链表时的完整过程.

1. 事务在执行过程中对普通表的记录进行首次改动之前,先到系统表空间的第5号页面(类型为`TRX_SYS`的页面)中分配1个回滚段

    其实就是获取1个存储`Rollback Segment Header`结构的页面的地址(`表空间ID + 页号`).一旦某个回滚段被分配给了该事务,
    则之后该事务中再对普通表的记录做改动时,就不会重复分配了.
    
    使用`round-robin`(循环使用)的方式来分配回滚段.比如:
    
    - 当前事务分配了第0号回滚段
    - 下一个事务就要分配第33号回滚段
    - 再下个事务就要分配第34号回滚段

    简单一点的说就是:这些回滚段被轮着分配给不同的事务(很简单的分配方式).

2. 在分配到回滚段后,先看一下该回滚段的2个cached链表有没有已经缓存的`undo slot`

    - 若事务执行的是`INSERT`操作,则去回滚段对应的`insert undo cached`链表中检查是否存在缓存的`undo slot`
    - 若事务执行的是`DELETE`操作,则去回滚段对应的`update undo cached`链表中检查是否存在缓存的`undo slot`

    若存在缓存的`undo slot`,则把该缓存的`undo slot`分配给该事务;

3. 若没有缓存的`undo slot`可供分配,则到存储`Rollback Segment Header`结构的页面中,找一个可用的`undo slot`分配给当前事务

    前面讲过如何从存储`Rollback Segment Header`结构的页面中分配可用的`undo slot`,就是:

    - 从第0个`undo slot`开始,若该`undo slot`的值为`FIL_NULL`,则表示该`undo slot`是空闲的,把该`undo slot`分配给当前事务即可
    - 否则查看第1个`undo slot`是否满足条件,若满足条件,则把该`undo slot`分配给当前事务即可
    - 依次类推,直到最后一个`undo slot`
    - 若这1024个`undo slot`的值都不为`FIL_NULL`,则直接报错(一般不会出现这种情况)

4. 找到可用的`undo slot`后

    - 若该`undo slot`是从cached链表中获取的,则表示该`undo slot`对应的`Undo`页面链表已经分配过`Undo Log Segment`了
      - 前面在讲[`Undo Log Segment Header`](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC20%E7%AB%A0%20%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E--undo%E6%97%A5%E5%BF%97/7.%20Undo%E6%97%A5%E5%BF%97%E7%9A%84%E5%85%B7%E4%BD%93%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B/2.%20Undo%20Log%20Segment%20Header.md)时说过,每1个`Undo`页面链表都对应着1个segment,该segment称为`Undo Log Segment`
    - 否则需要重新分配一个`Undo Log Segment`,然后从该`Undo Log Segment`中申请1个页面作为`Undo`页面链表的`first undo page`

5. 然后事务就可以把`undo`日志写入到上面申请的`Undo`页面链表中了

对临时表的记录进行改动时,步骤与上面一样.这里不再赘述.再次强调:**若1个事务在执行过程中,既对普通表的记录进行了改动,又对临时表的记录进行了改动,
则需要为该事务分配2个回滚段.并发执行的不同事务其实也可以被分配相同的回滚段,只要分配不同的`undo slot`即可**.
