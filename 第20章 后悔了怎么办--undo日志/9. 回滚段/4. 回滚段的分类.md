# 4. 回滚段的分类

把这128个回滚段编一下号:

- 最开始的回滚段称为第0号回滚段
- 之后依次递增
- 最后一个回滚段称为第127号回滚段

这128个回滚段可以被分成2大类:

- 第0号/第33-127号回滚段属于一类
  - 其中第0号回滚段必须在系统表空间中
    - 也就是说第0号回滚段对应的存储`Rollback Segment Header`结构的页面必须在系统表空间中
  - 第33-127号回滚段既可以在系统表空间中,也可以在自己配置的undo表空间中
    - 关于怎么配置后面会讲到
  - 若一个事务在执行过程中,对**普通表**的记录进行了改动,需要分配`Undo`页面链表时,则必须从该类的段中分配相应的`undo slot`

- 第1-32号回滚段属于一类
  - 这些回滚段必须在临时表空间中
    - 临时表空间即数据目录中的`ibtmp1`文件
  - 若一个事务在执行过程中,对**临时表**的记录进行了改动,需要分配`Undo`页面链表,则必须从该类的段中分配相应的`undo slot`

即: 若1个事务在执行过程中,既对普通表的记录进行了改动,又对临时表的记录进行了改动,则需要为该事务分配2个回滚段,然后再分别到这2个回滚段中
分配对应的`undo slot`.

为什么要针对普通表和临时表来划分不同种类的回滚段?这还要从`Undo`页面本身说起.前面讲到过,`Undo`页面是类型为`FIL_PAGE_UNDO_LOG`的页面的简称,
本质上它也是一个普通的页面.之前还讲过,在修改页面之前一定要先把对应的`redo`日志写上,这样在系统因崩溃而重启时才能恢复到崩溃前的状态.
**向`Undo`页面写入`undo`日志本身也是一个写页面的过程**.InnoDB的设计者为记录对`Undo`页面的改动,还设计了许多种`redo`日志的类型:

- `MLOG_UNDO_HDR_CREATE`
- `MLOG_UNDO_INSERT`
- `MLOG_UNDO_INIT`
- 等等等等

也就是说,**对`Undo`页面做的任何改动都会记录相应类型的`redo`日志**.

对于临时表来说,因修改临时表而产生的`undo`日志,只需要在系统运行过程中有效.若系统发生崩溃,则在重启时也不需要恢复这些
为记录临时表的`undo`日志所使用的页面的修改.因此在针对临时表的变更而写`Undo`页面时,并不需要记录这些页面对应的`redo`日志.
用白话说就是: 针对临时表的修改所记录的`undo`日志,对`Undo`页面造成的修改,因为不需要在崩溃后被回复(因为临时表本身只对当前连接可见),
所以不需要记录这些`Undo`页面的`redo`日志.

针对普通表和临时表划分不同种类的回滚段的原因可以总结为:

- 修改针对普通表的回滚段中的`Undo`页面时,需要记录对这些`Undo`页面的修改产生的`redo`日志
- 修改针对临时表的回滚段中的`Undo`页面时,不需要记录对这些`Undo`页面的修改产生的`redo`日志


注: 实际上在MySQL5.7.21这个版本中:

- 若仅对普通表的记录进行了改动,则只会为该事务分配针对普通表的回滚段,不分配针对临时表的回滚段
- 若仅对临时表的记录进行了改动,则既会为该事务分配针对普通表的回滚段,又会为该事务分配针对临时表的回滚段
  - 不过分配了回滚段并不会立即分配`undo slot`,只有在真正需要`Undo`页面链表时才会去分配回滚段中的`undo slot`
