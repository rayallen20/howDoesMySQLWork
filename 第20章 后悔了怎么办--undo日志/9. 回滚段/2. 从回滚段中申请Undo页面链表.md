# 2. 从回滚段中申请`Undo`页面链表

在初始情况下,由于未向任何事务分配任何`Undo`页面链表,所以对于1个`Rollback Segment Header`结构来说,它的各个`undo slot`
都被设置为一个特殊的值:`FIL_NULL`(对应的十六进制就是`0xFFFFFFFF`),表示该`undo slot`不指向任何页面

随着时间的流逝,开始有事务需要分配`Undo`页面链表了,就从`Rollback Segment Header`结构中的第1个`undo slot`开始,检测该`undo slot`
的值是否为`FIL_NULL`:

- 若第1个`undo slot`的值为`FIL_NULL`

    - 则在表空间中新创建一个段(即`Undo Log Segment`,也就是`Undo`页面链表对应的那个segment)
    - 然后从该新创建的段中,申请1个页面作为`Undo`页面链表的`first undo page`
    - 最后把该`undo slot`的值,设置为刚刚申请的这个页面的页号

    这也就意味着:该`undo slot`被分配给了这个事务

- 若第1个`undo slot`的值不为`FIL_NULL`

    - 说明该`undo slot`已经指向了一个`Undo`页面链表
    - 也就是说该`undo slot`已经被别的事务占用了
    - 这就需要跳到下一个`undo slot`,判断该`undo slot`的值是否为`FIL_NULL`
    - 再重复上边的步骤

1个`Rollback Segment Header`结构中,包含1024个`undo slot`.若这1024个`undo slot`的值都不为`FIL_NULL`,就表示
这1024个`undo slot`都已经被分配给了某个事务.此时,由于新事务无法再获得新的`Undo`页面链表,就会停止执行该事务,并向用户报错:

```
Too many active concurrent transactions
```

用户看到该错误,可以选择重新执行该事务.因为可能重新执行时有别的事务提交了,该事务就可以被分配`Undo页面链表了.

当一个事务提交时,该事务所占用的`undo slot`有2种处理办法:

- 若该`undo slot`指向的`Undo`页面链表符合被重用的条件

    即:

    -  `Undo`页面链表只占用一个页面
    - `已使用空间 < 整个页面的3/4`

    则该`undo slot`就处于被缓存的状态.InnoDB的设计者规定:此时该`Undo`页面链表中的`first undo page`中的[`Undo Log Segment Header`](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC20%E7%AB%A0%20%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E--undo%E6%97%A5%E5%BF%97/7.%20Undo%E6%97%A5%E5%BF%97%E7%9A%84%E5%85%B7%E4%BD%93%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B/2.%20Undo%20Log%20Segment%20Header.md)
    中的`TRX_UNDO_STATE`属性值会被置为`TRX_UNDO_CACHED`.

    被缓存的`undo slot`都会被加入到一个链表中.不同类型的`Undo`页面链表对应的`undo slot`,会被加入到不同的链表中:

    - 若被缓存的`undo slot`,对应的`Undo`页面链表类型为`insert undo`链表,则该`undo slot`会被加入到`insert undo cached`链表中
    - 若被缓存的`undo slot`,对应的`Undo`页面链表类型为`update undo`链表,则该`undo slot`会被加入到`update undo cached`链表中

    1个回滚段就对应着上述2个cached链表,若有新事务要分配`undo slot`时:

    - 先从对应的cached链表中找
    - 若没有被缓存的`undo slot`
    - 才会到回滚段的`Rollback Segment Header`结构中寻找

    注: 从设计理念上讲,可以认为是"尽可能重用`Undo`页面"的实现

- 若该`undo slot`指向的`Undo`页面链表不符合被重用的条件

    则根据该`undo slot`对应的`Undo`页面链表类型不同,也会有不同的处理:

    - 若对应的`Undo`页面链表是`insert undo`链表
      - 则该`Undo`页面链表的`TRX_UNDO_STATE`属性会被设置为`TRX_UNDO_TO_FREE`
      - 之后该`Undo`页面链表对应的段(即`Undo Log Segment`)会被释放掉,也就意味着段中的页面可以被挪作他用
      - 然后把该`undo slot`的值设置为`FIL_NULL`
    - 若对应的`Undo`页面链表是`update undo`链表
      - 则该`Undo`页面链表的`TRX_UNDO_STATE`属性会被设置为`TRX_UNDO_TO_PURGE`
      - 并将该`undo slot`的值设置为`FIL_NULL`
      - 然后将该事务写入的一组`undo`日志放到History链表中(实际上是把该组日志的`Undo Log Header`结构挂到了History链表中)
        - 注意: 这里并不会将`Undo`页面链表对应的段给释放掉,因为这些`undo`日志还需要留着为MVCC服务
