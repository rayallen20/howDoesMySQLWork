# 1. 分配事务id的时机

前面[在讲事务时](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC18%E7%AB%A0%20%E4%BB%8E%E7%8C%AB%E7%88%B7%E5%80%9F%E9%92%B1%E8%AF%B4%E8%B5%B7--%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/3.%20MySQL%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%AF%AD%E6%B3%95/1.%20%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1.md)说过,一个事务可以是一个只读事务,也可以是一个读写事务:

- 通过`START TRANSACTION READ ONLY`语句开启一个只读事务

    在只读事务中,不可以对普通的表(其他事务也能访问到的表)进行增/删/改操作,但可以对临时表做增/删/改操作

- 通过`START TRANSACTION READ WRITE`语句开启一个读写事务

    使用`BEGIN`/`START TRANSACTION`语句开启的事务默认也算是读写事务.在读写事务中可以对表执行增删改查操作

**若某个事务在执行过程中对某个表执行了增/删/改操作,则InnoDB存储引擎就会给该事务分配一个独一无二的事务id**.分配方式如下:

- 对于只读事务来说:
    - 只有在该事务第一次对某个用户创建的临时表执行增/删/改操作时,才会为该事务分配1个事务id
    - 否则不分配事务id 

注:在第15章讲到过,对某个查询语句执行`EXPLAIN`来分析它的执行计划时,在在`Extra`列可能会看到[`Using temporary`](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC15%E7%AB%A0%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6--EXPLAIN%E8%AF%A6%E8%A7%A3/1.%20%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%BE%93%E5%87%BA%E4%B8%AD%E5%90%84%E5%88%97%E8%AF%A6%E8%A7%A3/11.%20Extra/11.%20Using%20temporary.md)的提示.
这表明在执行该查询语句时会用到内部临时表.这里的内部临时表和用`CREATE TEMPORARY TABLE`语句手动创建的用户临时表并不一样.
在事务回滚时,并不需要把执行`SELECT`语句的过程中用到的内部临时表也回滚.在执行`SELECT`语句时,若用到内部临时表,InnoDB存储引擎也
不会为这条`SELECT`语句分配事务id(因为这条`SELECT`语句不会对其他事务也能访问到的表做增/删/改操作,只会操作内部的临时表)

- 对于读写事务来说:
    - 只有在该事务第一次对某个表(包括用户创建的临时表)执行增/删/改操作时,才会为该事务分配1个事务id
    - 否则不分配事务id

有时虽然开启了一个读写事务,但是该事务中全是查询语句,并没有执行增/删/改操作的语句,那也就意味着该事务并不会被分配1个事务id.

注: 若不为某个事务分配事务id,则该事务的事务id为默认值0.另外,前文描述的事务id分配策略是针对MySQL5.7的,更早版本的分配方式可能不同.
