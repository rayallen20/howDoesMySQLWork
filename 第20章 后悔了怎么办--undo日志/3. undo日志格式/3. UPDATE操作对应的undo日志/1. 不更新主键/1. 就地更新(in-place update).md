# 1. 就地更新(`in-place update`)

更新记录时,对于被更新的每个列来说,若:

- 更新前的列
- 更新后的列

这二者占用的存储空间都一样大,则可以进行就地更新,即:**直接在原记录的基础上修改对应列的值**.

再强调一遍: 这里说的列,是指**每个列在更新前后占用的存储空间相同**,只要有任何一个被更新的列:

- 更新前比更新后占用的存储空间大
- 更新前比更新后占用的存储空间小

都不能进行就地更新.

比如,现在`undo_demo`表里还有一条`id`值为2的记录,该条记录中各个列占用的大小如下图示(因为采用`utf8mb4`字符集,所以`'步枪'`这2个字符占用6个字节):

![id为2的聚簇索引记录](./img/id为2的聚簇索引记录.jpg)

假设现在有如下`UPDATE`语句:

```sql
UPDATE undo_demo 
SET
    key1 = 'P92',
    col = '手枪' 
WHERE
    id = 2;
```

在该`UPDATE`语句中:

- `col`列从`'步枪'`被更新为`'手枪'`,前后都占用6字节
  - 即:占用的存储空间大小未改变
- `key1`列从`'M416'`被更新为`'P92'`,从4字节更新为3字节
  - 即: 不满足就地更新所需的条件

因此不能进行就地更新.

但是如果`UPDATE`语句如下:

```sql
UPDATE undo_demo 
SET
    key1 = 'M249',
    col = '机枪' 
WHERE
    id = 2;
```

因为所有被更新的列,在更新前后占用的存储空间是相同(`key1`列更新前后都是4字节;`col`列更新前后都是6字节),所以该语句可以执行就地更新.
