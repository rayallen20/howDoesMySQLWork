# 2. 更新主键

在聚簇索引中,记录按主键值的大小连成了一个单向链表.若更新了某条记录的主键值,就表示该条记录在聚簇索引中的位置将会发生改变.
比如,将记录的主键值从1更新为10000,若此时还有很多的记录的主键值分布在1到10000之间,则主键值为1和主键值为10000的2条记录
在聚簇索引中就有可能离得非常远,甚至中间隔了好多个页面.针对`UPDATE`语句中更新了记录主键值的情况,InnoDB在聚簇索引中分了2步来处理:

- 步骤1. 将旧记录进行`delete mark`操作

    注意: 这一步是`delete mark`操作.这意味着:
    
    - **在`UPDATE`语句所在的事务提交之前,对旧记录只执行1步`delete mark`操作**
    - **在事务提交后,才由专门的线程执行`purge`操作,从而把这条旧记录加入到垃圾链表中**
    
    这里一定要和前面讲的"在不更新记录主键值时,先真正删除旧记录,再插入新记录"的方式区分开
    
    注: 之所以在事务提交之前,只对旧记录做`delete mark`操作,是因为别的事务也可能同时访问这条记录,若把旧记录真正删除并加入到垃圾链表后,
    则别的事务就访问不到了.这个功能就是MVCC,后续会讲到.

- 步骤2. 根据更新后各列的值创建一条新记录,并将其插入到聚簇索引中

    因为更新后的记录主键值发生了改变,所以需要重新从聚簇索引中定位这条新记录所在的位置,然后把这条新纪录插进去.

针对`UPDATE`语句更新记录主键值的情况:

- 在对该记录进行`delete mark`操作时,会记录一条类型为[`TRX_UNDO_DEL_MARK_REC`](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC20%E7%AB%A0%20%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E--undo%E6%97%A5%E5%BF%97/3.%20undo%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F/2.%20DELETE%E6%93%8D%E4%BD%9C%E5%AF%B9%E5%BA%94%E7%9A%84undo%E6%97%A5%E5%BF%97/2.%20DELETE%E6%93%8D%E4%BD%9C%E5%AF%B9%E5%BA%94%E7%9A%84undo%E6%97%A5%E5%BF%97%E7%9A%84%E7%BB%93%E6%9E%84.md)的`undo`日志
- 之后插入新记录时,会记录一条类型为[`TRX_UNDO_INSERT_REC`](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC20%E7%AB%A0%20%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E--undo%E6%97%A5%E5%BF%97/3.%20undo%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F/1.%20INSERT%E6%93%8D%E4%BD%9C%E5%AF%B9%E5%BA%94%E7%9A%84undo%E6%97%A5%E5%BF%97.md)的`undo`日志

即: **每对1条记录的主键值做改动,都会记录2条`undo`日志**.这就是在本章的[前言](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC20%E7%AB%A0%20%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E--undo%E6%97%A5%E5%BF%97/3.%20undo%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F/0.%20%E5%89%8D%E8%A8%80.md)部分中说的,"在某些更新记录的操作中,可能会对应着2条undo日志"的情况.

注: 还有一种类型为`TRX_UNDO_UPD_DEL_REC`的`undo`日志的类型这里没有讲到,主要是想避免引入过多的复杂性
