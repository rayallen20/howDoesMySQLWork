# 1. `ASC`与`DESC`混用

对于使用联合索引进行排序的场景,要求各个排序列的排序规则是一致的,也就是要么各个列都是按照`ASC`(升序)规则排序,要么都是按照`DESC`(降序)规则排序.
否则无法使用索引.

可能有人会有疑问:虽然B+树的每层页面之间是用双向链表连接起来的,但是在一个页内的记录却是按照记录从小到大的顺序,以单向链表的形式连接起来的.
如果ORDER BY子句要求以升序排序,那么使用索引查询可以很好理解.但是如果ORDER BY子句要求以降序排序,还能使用索引进行查询么?

答案是可以的.因为每个索引页的页目录中的槽,指向了每组中最大的那条数据的位置.查找当前记录的上一条记录的过程如下:

- step1. 找到该记录所在组的第一条记录
  - 1.1 一直根据记录的`next_record`属性找下一条记录,直到某条记录的头信息的next_record`属性值不为0,该记录就是本组中的"带头大哥"(最大的那条数据)
  - 1.2 然后再从页目录中找到"带头大哥"记录对应的槽的上一个槽,该槽对应的记录的下一条记录,就是本组中的第一条记录
- step2. 从第本组中的一条记录开始遍历该组中的记录,直到找到当前记录的前一条记录

很显然,找某条记录的上一条记录要比找下一条记录复杂一些.

为什么会有这种规定呢? 还是要看联合索引`idx_key_part`中,二级索引记录的排序规则:

- 先按照`key_part1`列的值进行升序排序
- 若`key_part1`列的值相同,则按照`key_part2`列的值进行升序排序
- 若`key_part1`和`key_part2`列的值都相同,则按照`key_part3`列的值进行升序排序

若查询语句中各个排序列的排序规则是一致的,例如:

```sql
SELECT *
FROM single_table
ORDER BY 
    key_part1 ASC,
    key_part2 ASC,
LIMIT 10;
```

则可以直接从联合索引`idx_key_part`中最左边的那条二级索引记录开始,向右读10条二级索引记录即可.

再例如:

```sql
SELECT *
FROM single_table
ORDER BY 
    key_part1 DESC,
    key_part2 DESC,
LIMIT 10;
```

则可以直接从联合索引`idx_key_part`中最右边的那条二级索引记录开始,向左读10条二级索引记录即可.

如果查询的需求是先按照`key_part1`列升序排序,再按照`key_part2`列降序排序,比如这个查询语句:

```sql
SELECT *
FROM single_table
ORDER BY 
    key_part1 ASC,
    key_part2 DESC,
LIMIT 10;
```

则过程如下:

- 先找到联合索引最左边的那条二级索引记录的`key_part1`值(将其称为`min_value`)
- 然后向右找到`key_part1`值等于`min_value`的所有二级索引记录
- 最后再从`key_part1`值等于`min_value`最后一条二级索引记录开始,向左找10条二级索引记录

可是`key_part1`值等于`min_value`的二级索引记录有多少条是未知的.

- 若`key_part1`值等于`min_value`的二级索引记录共有`n`条(且`n < 10`),则需要找到`key_part1`值等于`min_value`最后一条二级索引记录的下一条二级索引记录
- 假级该二级索引记录的`key_part1`值值为`min_value2`:
  - 则需要再找到`key_part1`值为`min_value2`所有二级索引记录
  - 然后再从`key_part1`值为`min_value2`的最后一条二级索引记录开始,向左找`10-n`条记录
- 若`key_part1`值等于`min_value`和`min_value2`的二级索引记录加起来还不够10条,则继续重复这个过程

**这种需要较为复杂的算法从索引中读取记录的方式,不能高效地使用索引.所以在这种情境下是不会使用联合索引执行排序操作的**.

注: MySQL8.0引入了一种称为`Descending Index`的特性,可以支持ORDER BY中`ASC`/`DESC`混用的情况.具体情况可以参考文档.
