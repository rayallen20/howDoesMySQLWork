# 4. 包含`UNION`子句的查询语句的id列

对于包含`UNION`子句的查询语句来说,每个`SELECT`关键字对应1个`id`值也是没错的,不过还是有些其他内容.例如:

```
mysql> EXPLAIN SELECT * FROM single_table UNION SELECT * FROM single_table2;
+----+--------------+---------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
| id | select_type  | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |
+----+--------------+---------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
|  1 | PRIMARY      | single_table  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9817 |   100.00 | NULL            |
|  2 | UNION        | single_table2 | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9942 |   100.00 | NULL            |
|  3 | UNION RESULT | <union1,2>    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |
+----+--------------+---------------+------------+------+---------------+------+---------+------+------+----------+-----------------+
3 rows in set, 1 warning (0.00 sec)
```

该语句的执行计划的第3条记录中,其`table`列的值为`<union1,2>`.
`UNION`子句会把多个查询的结果集合并起来,并对结果集中的记录进行去重,这个去重的过程需要使用内部的临时表.
如该的查询计划中所示,`UNION`子句是为了把`id`为1的查询和`id`为2的查询的结果集合并起来并去重,
所以在内部创建了一个名为`<union1, 2>`的临时表(即执行计划第3条记录的`table`列的名称).
