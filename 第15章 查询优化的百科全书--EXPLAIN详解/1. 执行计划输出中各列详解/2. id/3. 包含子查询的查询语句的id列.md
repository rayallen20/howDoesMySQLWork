# 3. 包含子查询的查询语句的id列

对于包含子查询的查询语句来说,就可能涉及多个`SELECT`关键字.所以在包含子查询的查询语句的执行计划中,
每个`SELECT`关键字都会对应1个唯一的`id`值,例如:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key1 IN (SELECT key1 FROM single_table2) OR key3 = 'a';
+----+-------------+---------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
| id | select_type | table         | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
|  1 | PRIMARY     | single_table  | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9817 |   100.00 | Using where |
|  2 | SUBQUERY    | single_table2 | NULL       | index | idx_key1      | idx_key1 | 403     | NULL | 9942 |   100.00 | Using index |
+----+-------------+---------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
2 rows in set, 1 warning (0.03 sec)
```

从输出结果中可以看到,`single_table`表在外层查询中,外层查询有1个独立的`SELECT`关键字,所以第1条记录的`id`值就是1;
`single_table2`表在子查询中,子查询有1个独立的`SELECT`关键字,所以第2条记录的`id`值就是2.

注意: **查询优化器可能对涉及子查询的查询语句进行重写,从而转换为连接查询(当然这里说的连接查询是指半连接)**.
如果想知道查询优化器对某个包含子查询的语句是否进行了重写,直接查看执行计划即可.例如:

```
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = 'a');
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                        |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+
| 1 | SIMPLE       | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 9954 | 10.00    | Using where; Start temporary |
| 1 | SIMPLE       | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s2.key3 | 1    | 100.00   | End temporary                |
+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+
2 rows in set, 1 warning (0.00 sec)
```

注: 该执行计划是书中的,并不是我的环境中的,因为我的环境中跑出来的执行计划和书中的不同.

可以看到,虽然查询语句中包含了一个子查询,但是执行计划中`s1`和`s2`表对应的记录的`id`值全部是1,这表明
查询优化器将子查询转换为了连接查询.

注: 这里我的执行计划和书中的不同,所以把书中的贴出来了.我的执行计划如下:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key1 IN (SELECT key3 FROM single_table2 WHERE common_field = 'a');
+----+--------------+---------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+
| id | select_type  | table         | partitions | type | possible_keys | key      | key_len | ref              | rows | filtered | Extra       |
+----+--------------+---------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+
|  1 | SIMPLE       | <subquery2>   | NULL       | ALL  | NULL          | NULL     | NULL    | NULL             | NULL |   100.00 | Using where |
|  1 | SIMPLE       | single_table  | NULL       | ref  | idx_key1      | idx_key1 | 403     | <subquery2>.key3 |    1 |   100.00 | NULL        |
|  2 | MATERIALIZED | single_table2 | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL             | 9942 |    10.00 | Using where |
+----+--------------+---------------+------------+------+---------------+----------+---------+------------------+------+----------+-------------+
3 rows in set, 1 warning (0.00 sec)
```
