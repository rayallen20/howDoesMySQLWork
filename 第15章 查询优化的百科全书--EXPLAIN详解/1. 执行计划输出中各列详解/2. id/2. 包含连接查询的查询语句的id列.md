# 2. 包含连接查询的查询语句的id列

对于连接查询来说,1个`SELECT`关键字后边的`FROM`子句中可以跟随多个表.
**在连接查询的执行计划中,每个表都会对应`EXPLAIN`的结果中的1条记录,但是这些记录的`id`值都是相同的**.例如:

```
mysql> EXPLAIN SELECT * FROM single_table INNER JOIN single_table2;
+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
| id | select_type | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                         |
+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
|  1 | SIMPLE      | single_table  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9817 |   100.00 | NULL                          |
|  1 | SIMPLE      | single_table2 | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9942 |   100.00 | Using join buffer (hash join) |
+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+
2 rows in set, 1 warning (0.01 sec)
```

可以看到,该连接查询中参与连接的`single_table`和`single_table2`表分别对应1条记录,但是这两条记录对应的`id`值都是1.

注意:

**在连接查询的执行计划中**:

- **每个表都会对应执行计划中的1条记录,这些记录的`id`列的值是相同的**
- **`id`列值相同的前提下,出现在前面的表为驱动表,出现在后面的表为被驱动表**

所以从该`EXPLAIN`的输出中可以看出:查询优化器准备使用`single_table`表作为驱动表,以`single_table2`表作为被驱动表,来执行查询
