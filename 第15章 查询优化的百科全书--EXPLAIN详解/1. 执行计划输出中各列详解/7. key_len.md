# 7. `key_len`

前面说过,当决定使用某个索引来执行查询时,首先要知道对应的扫描区间,以及形成该扫描区间的边界条件是什么.

例如:

```sql
SELECT * FROM single_table WHERE key1 > 'a' AND key1 < 'b';
```

在使用索引`idx_key1`执行查询时,对应的扫描区间为`key1 ∈ ('a', 'b')`,形成该扫描区间的边界条件为`key1 > 'a' AND key1 < 'b'`.
当然,这个结论是根据经验得出的,在一些情况下,需要**从执行计划中直接看出形成扫描区间的边界条件是什么**,这时就需要用到`key_len`列.

上述查询语句的执行计划如下:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key1 > 'a' AND key1 < 'b';
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table        | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | single_table | NULL       | range | idx_key1      | idx_key1 | 403     | NULL |  296 |   100.00 | Using index condition |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

可以看到,执行计划中`key_len`列的值为`403`,那这个`403`是怎么算出来的呢?

`key_len`列表示当优化器决定使用某个索引执行查询时,该索引记录的最大长度.由3个部分构成:

- 该列的实际数据最多占用的存储空间长度

    对于固定长度类型的列来说,假设对`INT`类型的列来说,该列的实际数据最多占用的存储空间长度为`4`字节(当然对于`INT`类型的列来说,
    不论存储的值是什么,其实际占用的存储空间都是4字节).
    
    对于变长类型的列来说,例如使用`utf8mb4`字符集,类型为`VARCHAR(100)`的列,该列的实际数据最多占用的存储空间长度为:
    
    ```
    该列的实际数据最多占用的存储空间长度 = 在该字符集中表示1个字符最多占用的字节数 * 该类型最多可以存储的字符数
    ```
    
    按上述公式,这个`VARCHAR(100)`的列的实际数据最多占用的存储空间长度为`4 * 100 = 400`字节.

- 若该列可存储`NULL`值
  - 则`key_len`值为`该列的实际数据最多占用的存储空间长度 + 1`字节
- 若该列为变长类型的列,则还需要2字节的空间来存储该变长列的实际数据占用的存储空间长度
  - 则`key_len`值为`该列的实际数据最多占用的存储空间长度 + 2`字节

在上述的执行计划中:

- 通过査看执行计划的`key`列值为`idx_key1`,所以确定该查询是使用索引`idx_key1`来执行的
- 再査看执行计划的`key_len`列值为`403`,说明形成扫描区间的搜索条件中,只包含`key1`列这1个列
- 查询语句中,涉及该列的搜索条件是`key1 > 'a' AND key1 < 'b'`,这个搜索条件就是形成扫描区间的边界条件

- 索引列不允许存储NULL值且长度固定时的`key_len`值

    例如:
    
    ```
    mysql> EXPLAIN SELECT * FROM single_table WHERE id = 5;
    +----+-------------+--------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    | id | select_type | table        | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
    +----+-------------+--------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | single_table | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
    +----+-------------+--------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    1 row in set, 1 warning (0.00 sec)
    ```

本例中,由于`id`列的类型是`INT`,且不允许存储NULL值,所以在使用该列的索引时`key_len`的大小就是4.

- 索引列允许存储`NULL`值且长度固定时的`key_len`值

    例如:
    
    ```
    mysql> EXPLAIN SELECT * FROM single_table WHERE key2 = 5;
    +----+-------------+--------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    | id | select_type | table        | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
    +----+-------------+--------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | single_table | NULL       | const | uk_key2       | uk_key2 | 5       | const |    1 |   100.00 | NULL  |
    +----+-------------+--------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    1 row in set, 1 warning (0.01 sec)
    ```

    可以看到`key_len`列值为5,比使用`id`列的索引时多了1.

这里可能会有疑问: 在介绍InnoDB行格式中的[变长字段长度列表部分](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC4%E7%AB%A0%20%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7--InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/3.%20InnoDB%E8%A1%8C%E6%A0%BC%E5%BC%8F/2.%20COMPACT%E8%A1%8C%E6%A0%BC%E5%BC%8F/1.%20%E8%AE%B0%E5%BD%95%E7%9A%84%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF/1.%20%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8.md)
时,存储变长字段的实际长度可能占用1个字节或者2个字节,为什么在执行计划的`key_len`列中,确定是2字节?

这里需要强调的: **执行计划的生成是server层的功能,并不是针对具体某个存储引擎的功能,
server表示记录的方式与具体某个存储引擎表示记录的方式是不同的**.MySQL的设计者在执行计划中输出`key_len`列,主要是为了在
使用联合索引执行查询时,能知道优化器具体使用了设计多少个列的搜索条件来作为形成扫描区间的边界条件.

例如:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key_part1 = 'a' AND key_part3 = 'a';
+----+-------------+--------------+------------+------+---------------+--------------+---------+-------+------+----------+-----------------------+
| id | select_type | table        | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+--------------+------------+------+---------------+--------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | single_table | NULL       | ref  | idx_key_part  | idx_key_part | 403     | const |    1 |    10.00 | Using index condition |
+----+-------------+--------------+------------+------+---------------+--------------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```


执行计划的`key_len`列值为403.这意味着MySQL在执行上述査询时只把涉及`key_part1`列的搜索条件作为形成扫描区间的边界条件,
也就是仅使用搜索条件`key_part1 = 'a'`作为边界条件.

注: 联合索引中可以"作为形成扫描区间的边界条件"的列,必须是最左连续前缀.所以这里判定`key_part3`列的搜索条件没有被作为
形成扫描区间的边界条件使用.

例如:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key_part1 = 'a' AND key_part2 = 'b';
+----+-------------+--------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+
| id | select_type | table        | partitions | type | possible_keys | key          | key_len | ref         | rows | filtered | Extra |
+----+-------------+--------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | single_table | NULL       | ref  | idx_key_part  | idx_key_part | 806     | const,const |    1 |   100.00 | NULL  |
+----+-------------+--------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

该查询的执行计划的`ken_len`列值为606,说明MySQL在执行该查询时把涉及`key_part1`和`key_part2`列的搜索条件都作为形成扫描区间的边界条件,
也就是使用搜索条件`key_part1 = 'a' AND key_part2 = 'b'`作为边界条件.
