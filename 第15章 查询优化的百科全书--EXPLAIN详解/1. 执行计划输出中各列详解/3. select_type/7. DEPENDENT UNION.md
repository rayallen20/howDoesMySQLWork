# 7. DEPENDENT UNION

DEPENDENT UNION在文档中的描述为: Second or later SELECT statement in a UNION, dependent on outer query

对于包含

- `UNION`
- `UNION ALL`

的大查询来说,**若各个小查询都依赖于外层查询**,则除了最左边的那个小查询之外,其余小查询的`select_type`的值为DEPENDENT UNION.
例如:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key1 IN (SELECT key1 FROM single_table2 WHERE key1 = 'a' UNION SELECT key1 FROM single_table WHERE key1 = 'b');
+----+--------------------+---------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+
| id | select_type        | table         | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |
+----+--------------------+---------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+
|  1 | PRIMARY            | single_table  | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | 9817 |   100.00 | Using where              |
|  2 | DEPENDENT SUBQUERY | single_table2 | NULL       | ref  | idx_key1      | idx_key1 | 403     | const |    1 |   100.00 | Using where; Using index |
|  3 | DEPENDENT UNION    | single_table  | NULL       | ref  | idx_key1      | idx_key1 | 403     | const |    1 |   100.00 | Using where; Using index |
|  4 | UNION RESULT       | <union2,3>    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | NULL |     NULL | Using temporary          |
+----+--------------------+---------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+
4 rows in set, 1 warning (0.08 sec)
```

从执行计划中可以看出:

- `SELECT key1 FROM s2 WHERE key1 = 'a'`: 该小查询是子查询中第一个查询,所以它的`select_type`值为DEPENDENT SUBQUERY
- `SELECT key1 FROM s1 WHERE key1 = 'b'`: 该小查询的`select_type`值为DEPENDENT UNION

这里需要解释的是: 为什么MySQL查询优化器会认为这2个小查询是依赖于外层查询的?

先给结论: **若某个子查询,既没有被物化也没有被改写为半连接,则该子查询无论语义上是否依赖外层行,都会被评估为相关子查询**.

出现这个现象的关键在于: **子查询`IN ( ... UNION ... )`既没有被半连接改写,
也没有被物化成一次性可复用的临时表(它确实可以被物化,只是查询优化器评估成本后没有选择物化它)**.

在这种执行策略下,MySQL会把它**当成相关子查询来评估**.即: **该子查询会随外层行变化而重新执行**,因此就打上了`DEPENDENT`的标签.

1. 为什么`SELECT key1 FROM s2 WHERE key1 = 'a'`的`select_type`值为`DEPENDENT SUBQUERY`,而不是`SUBQUERY`?

   - `DEPENDENT SUBQUERY`表示**该子查询依赖于外层查询**
   - 虽然该子查询里没有显式引用外层表的列,但是,**在没有做半连接或物化时,MySQL会把`IN (subquery)`以`"外层→内层"`方式逐行评估**
     - 相当于按外层行去"驱动"子查询
     - 因此被标成 `DEPENDENT SUBQUERY`
     - 社区里也有同样案例与解释:
       - `IN` 子查询常被改写/执行得像相关子查询一样,所以显示为`DEPENDENT`,即使语义上看似不相关
       - [参考案例](https://stackoverflow.com/questions/19190681/what-is-dependent-union-in-select-type-column-from-explain-command?utm_source=chatgpt.com)
       - [参考文档](https://dev.mysql.com/doc/refman/8.4/en/explain-output.html?utm_source=chatgpt.com)

2. 为什么`SELECT key1 FROM s1 WHERE key1 = 'b'`的`select_type`值为`DEPENDENT UNION`而不是`UNION`?
    
    在一个包含`UNION`/`UNION ALL`的子查询块中:
    
    - **若该子查询中最左边的那个子查询的`select_type`值为`SUBQUERY`或`DEPENDENT SUBQUERY`
    - 且其后的分支若同样被判定依赖外层
    - 则其后的分支的`select_type`值为`DEPENDENT UNION`**
    
    原因同上: 没有半连接或物化,执行策略把整个子查询(`IN ( ... UNION ... )`)当作外层驱动的相关子查询来跑,
    因此该分支的`select_type`值为`DEPENDENT UNION`

在MySQL的执行计划里,**"`select_type`值为`DEPENDENT SUBQUERY`/`DEPENDENT UNION`",
并不严格等同于语义上的"相关子查询"**,而是取决于优化器采用的执行策略.

更准确地说:

- 若一个子查询**既没有被物化,也没有被改写为半连接**
- 则MySQL会按照"外层行驱动内层"的方式逐行执行它
  - 这个执行方式和相关子查询类似
- 因此即使SQL语义上该子查询并没有引用外层列,但执行计划中依然会标记为`DEPENDENT SUBQUERY`/`DEPENDENT UNION`

换言之: **在EXPLAIN里看到的DEPENDENT,有时候反映的是执行策略,而不是严格的SQL语义**.

在本例中,子查询(`IN ( ... UNION ... )`)是可以被物化的,但优化器最后没有物化,而是选择了逐行执行的策略,
因此出现了`DEPENDENT SUBQUERY`/`DEPENDENT UNION`.

没有物化常见原因有以下几类(本例至少命中了其中2条):

1. 成本模型判定
    优化器会在`物化子查询 + 外层行在物化表中做IN查找`与`外层每行驱动内层用索引快速探测`之间做代价比较.
    本例的子查询的2个分支都能用`idx_key1`做等值索引查找(2个分支的`type`值均为`ref`),预估成本时**逐行探测**可能被认为成本更低,因而放弃物化

2. `UNION`的形态
    `IN (subquery)`的子查询物化转换并不是无条件发生,**当子查询里是`UNION`(尤其还跨不同表)时**,优化器有时更倾向按"相关子查询"的执行路径
    (在执行计划中虽然也看到`UNION RESULT … Using temporary`了,但那只是合并分支的中间结果,不等于"整个IN子查询被一次性物化供外层复用)).

3. 子查询里出现了外层同名表
    虽然子查询中的第2个分支(`SELECT key1 FROM single_table WHERE key1='b'`)**在语义上并不引用外层行**,
    但**内外都出现了`single_table`表**,在一些计划里会抑制半连接的改写和物化,转而选择外层驱动(这点在实践中很常见).

怎么验证它确实没有物化?

- 用`EXPLAIN FORMAT=JSON`看子查询节点是否带`dependent`/`cacheable`标记
- 打开`optimizer_trace`,能看到在`materialize`与`semi-join`转换尝试时的"放弃原因"(看完下一章回来试一下)

也可以用会话级开关去试探(不一定每版都生效,但便于对比计划):

```sql
SET optimizer_switch='materialization=on,semijoin=off';
-- 再 EXPLAIN 同一条语句看差异
```
