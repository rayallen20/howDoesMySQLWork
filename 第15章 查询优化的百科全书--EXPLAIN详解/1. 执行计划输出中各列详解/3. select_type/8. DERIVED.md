# 8. DERIVED

DERIVED在文档中的描述为: Derived table

在包含派生表的查询中,若以物化派生表的方式执行查询,则派生表对应的子查询的`select_type`值为DERIVED.

```
mysql> EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM single_table GROUP BY key1) AS derived_single_table where c > 1;
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
| id | select_type | table        | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
|  1 | PRIMARY     | <derived2>   | NULL       | ALL   | NULL          | NULL     | NULL    | NULL | 9817 |   100.00 | NULL        |
|  2 | DERIVED     | single_table | NULL       | index | idx_key1      | idx_key1 | 403     | NULL | 9817 |   100.00 | Using index |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

从执行计划中可以看出，,`id`为2的记录表示子查询的执行方式,它的`select_type`值为DERIVED,说明该子查询是以物化的方式执行的.
`id`为1的记录表示外层查询,注意它的`table`列的值为`<derived2>`,表示该查询是针对"将派生表物化之后的表"进行查询的.

注: 若派生表可以通过和外层查询合并的方式执行,则执行计划和连接很像

```
mysql> EXPLAIN
    -> SELECT /*+ MERGE(d) */-- 提示优化器合并派生表d
    -> single_table.id, single_table.key1, single_table.key2
    -> FROM single_table
    -> INNER JOIN (
    ->     SELECT key1
    ->     FROM single_table2
    ->     WHERE key2 BETWEEN 500 AND 1500   -- 利用索引uk_key2做range扫描
    -> ) AS d
    -> ON d.key1 = single_table.key1;    -- 两边都有索引idx_key1,可使用ref扫描
+----+-------------+---------------+------------+------+-------------------+----------+---------+------------------------------------+------+----------+-------------+
| id | select_type | table         | partitions | type | possible_keys     | key      | key_len | ref                                | rows | filtered | Extra       |
+----+-------------+---------------+------------+------+-------------------+----------+---------+------------------------------------+------+----------+-------------+
|  1 | SIMPLE      | single_table2 | NULL       | ALL  | idx_key2,idx_key1 | NULL     | NULL    | NULL                               | 9942 |    10.07 | Using where |
|  1 | SIMPLE      | single_table  | NULL       | ref  | idx_key1          | idx_key1 | 403     | charset_demo_db.single_table2.key1 |    1 |   100.00 | NULL        |
+----+-------------+---------------+------------+------+-------------------+----------+---------+------------------------------------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

从执行计划中可以看出,派生表`SELECT key1 FROM single_table2 WHERE key2 BETWEEN 500 AND 1500`被合并成了一个内连接,而没有物化.

作为对照,可以为该查询语句设置禁止合并:

```
mysql> EXPLAIN
    -> SELECT /*+ NO_MERGE(d) */-- 禁止优化器合并派生表d,强制保留
    -> single_table.id, single_table.key1, single_table.key2
    -> FROM single_table
    -> INNER JOIN (
    ->     SELECT key1
    ->     FROM single_table2
    ->     WHERE key2 BETWEEN 500 AND 1500   -- 利用索引uk_key2做range扫描
    -> ) AS d
    -> ON d.key1 = single_table.key1;    -- 两边都有索引idx_key1,可使用ref扫描
+----+-------------+---------------+------------+------+---------------+----------+---------+--------+------+----------+-------------+
| id | select_type | table         | partitions | type | possible_keys | key      | key_len | ref    | rows | filtered | Extra       |
+----+-------------+---------------+------------+------+---------------+----------+---------+--------+------+----------+-------------+
|  1 | PRIMARY     | <derived2>    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL   | 1000 |   100.00 | Using where |
|  1 | PRIMARY     | single_table  | NULL       | ref  | idx_key1      | idx_key1 | 403     | d.key1 |    1 |   100.00 | NULL        |
|  2 | DERIVED     | single_table2 | NULL       | ALL  | idx_key2      | NULL     | NULL    | NULL   | 9942 |    10.07 | Using where |
+----+-------------+---------------+------------+------+---------------+----------+---------+--------+------+----------+-------------+
3 rows in set, 1 warning (0.00 sec)
```

可以看到,此时派生表`single_table2`没有被合并,并且它的`select_type`值为DERIVED,表示该子查询是被单独评估后再与外层查询连接的.
注意: 这里子查询没有被物化,因为它的`select_type`值为DERIVED,而不是MATERIALIZED.

注: 派生表和物化是不同的.

简单理解: 派生表若不能合并(也就是说必须产生一个临时结果集):

- 若临时结果集可以被反复使用(例如不相关子查询),则它可能会被物化
  - 这里说可能是因为还要考虑逐行执行和物化哪个方案成本更低
- 否则就和相关子查询一样,每次都被外层行驱动去执行查询

- 派生表

    语义层面: 它是一个临时的"虚拟表",外层可以像用普通表一样用它
    执行策略:
    
    - 合并: 优化器把它的定义直接嵌回外层查询,生成一个大查询(派生表消失,只剩下原始表参与执行)
    - 不合并: 需要先执行子查询,得到一个临时结果集,再由外层查询使用
      - 这时可能会发生物化

- 物化

    是一种执行策略(注意物化本身就是一种执行策略),意思是"先把查询结果算出来,放进一个临时表(memory/disk),后面反复使用这个临时表"
    物化不只发生在派生表,还可能发生在:

    - `IN (subquery)`的子查询
    - CTE(公用表表达式)
      - CTE就是在查询开头用`WITH`定义的一个临时结果集,这个临时结果集有名字,可以在后续的SQL中像表一样被引用
    - 半连接优化
    - 某些`EXISTS`/`ANY`/`ALL`子查询

|      对比项      |         派生表(Derived Table)         |                     物化(Materialization)                     |
|:-------------:|:----------------------------------:|:-----------------------------------------------------------:|
|   **定义位置**    |            出现在`FROM`子句中            |                       是一种执行过程,不依赖特定位置                       |
|  **是否一定物化**   |         不一定,可能被**合并**进外层执行         |                      物化就是**一定要先生成临时表**                      |
|   **优化方式**    |            可以`MERGE`或保留            |                    没有"合并"这个说法,物化本身就是执行策略                    |
|   **执行代价**    |        合并后少了临时表开销,可能减少扫描次数         |                   增加一次临时表写入/读取开销,但能避免重复计算                   |
| **EXPLAIN标志** | 合并后不会显示`DERIVED`;不合并时会显示 `DERIVED` | 物化在EXPLAIN里可能表现为 `DERIVED`/`MATERIALIZED`/`<subquery>`等不同形式 |
|    **关系**     |          不合并的派生表,通常会用物化实现          |                 在派生表/子查询/CTE等多个场景中均有可能出现物化                  |
