# 10. `filtered`

`filtered`列表示优化器预估满足`WHERE`条件的记录的数量,占从前一步传递过来的记录的百分比.

- 每一行执行计划(每个`id`/`table`)会先从前一个执行步骤(或驱动表)拿到若干记录
- `filtered`表示优化器估计在这些记录中,有多少比例的记录可以通过当前步骤的`WHERE`条件过滤

之前在分析连接查询的成本时,提出过一个[Condition Filtering(条件过滤)](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC12%E7%AB%A0%20%E8%B0%81%E4%BE%BF%E5%AE%9C%E5%B0%B1%E9%80%89%E8%B0%81--%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/3.%20%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC/2.%20%E6%9D%A1%E4%BB%B6%E8%BF%87%E6%BB%A4(Condition%20Filtering).md)
的概念.这个概念就是MySQL在计算驱动表扇出时采用的一个策略:

- 若使用全表扫描的方式执行单表查询,则计算驱动表的扇出时,需要估计出满足搜索条件的记录到底有多少条
- 若使用索引执行单表扫描,则计算驱动表的扇出时,需要估计出满足除使用到对应索引的搜索条件外,还满足其他搜索条件的记录有多少条

例如:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key1 > 'z' AND common_field = 'a';
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+
| id | select_type | table        | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                              |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+
|  1 | SIMPLE      | single_table | NULL       | range | idx_key1      | idx_key1 | 403     | NULL |  327 |    10.00 | Using index condition; Using where |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+
1 row in set, 1 warning (0.01 sec)
```

- 从`key`列中可以看出,该查询使用索引`idx_key1`来执行查询
- 从`rows`列可以看出,满足条件`key1 > 'z'`的记录有327条
- `filtered`列就代表查询优化器预测在这 327条记录中,有多少条记录满足其他搜索条件
  - 即满足条件`common_field = 'a'`的记录占这327条记录的百分比
   

本例中`filtered`列的值是10.00,说明查询优化器预测在327条记录中有`10.00%`的记录满足条件`common_field = 'a'`.

对于单表查询来说,`filtered`列的值没什么意义.但是**在连接查询中驱动表对应的执行计划记录的`filtered`值,就很重要了.因为它描述的就是扇出值**.

例如:

```
mysql> EXPLAIN SELECT * FROM single_table INNER JOIN single_table2 ON single_table.key1 = single_table2.key1 WHERE single_table.common_field = 'a';
+----+-------------+---------------+------------+------+---------------+----------+---------+-----------------------------------+------+----------+-------------+
| id | select_type | table         | partitions | type | possible_keys | key      | key_len | ref                               | rows | filtered | Extra       |
+----+-------------+---------------+------------+------+---------------+----------+---------+-----------------------------------+------+----------+-------------+
|  1 | SIMPLE      | single_table  | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL                              | 9817 |    10.00 | Using where |
|  1 | SIMPLE      | single_table2 | NULL       | ref  | idx_key1      | idx_key1 | 403     | charset_demo_db.single_table.key1 |    1 |   100.00 | NULL        |
+----+-------------+---------------+------------+------+---------------+----------+---------+-----------------------------------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

从执行计划中可以看出,查询优化器打算把`single_table`作为驱动表,`single_table2`作为被驱动表.驱动表`single_table`的执行计划中:

- `rows`列值为9817
- `filtered`列值为`10.00`

表示驱动表`single_table`的扇出值就是 `9817 × 10.00% = 981.7`,这说明还要对被驱动表执行大约981次查询
