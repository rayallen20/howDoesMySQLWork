# 10. `Using filesort`

在有些情况下,当对结果集中的记录进行排序时,是可以使用到索引的.例如:

```
mysql> EXPLAIN SELECT * FROM single_table ORDER BY key1 ASC LIMIT 10;
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-------+
| id | select_type | table        | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-------+
|  1 | SIMPLE      | single_table | NULL       | index | NULL          | idx_key1 | 403     | NULL |   10 |   100.00 | NULL  |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

该查询语句利用索引`idx_key1`直接取出`key1`列的10条记录,然后针对每条二级引记录进行回表操作即可.
但是在很多情况下,排序操作无法使用到案引,只能在内存(记录较少时)或者磁盘中(记录较多时)进行排序.
MySQL的设计者把这种**在内存中者磁盘中进行排序的方式统称为文件排序(`filesort`)**.
若某个查询需要使用文件排序的方执行查询,则会在执行计划的`Extra`列中显示`Using filesort`提示.
例如:

```
mysql> EXPLAIN SELECT * FROM single_table ORDER BY common_field LIMIT 10;
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+----------------+
| id | select_type | table        | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra          |
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+----------------+
|  1 | SIMPLE      | single_table | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10200 |   100.00 | Using filesort |
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+----------------+
1 row in set, 1 warning (0.00 sec)
```

注意: **若查询中需要使用文件排序的记录非常多,则这个过程还是很耗费性能的.可以尝试将文件排序的执行方式改为使用索引进行排序.**
