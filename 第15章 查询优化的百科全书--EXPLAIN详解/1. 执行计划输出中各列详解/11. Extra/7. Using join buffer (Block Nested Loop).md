# 7. `Using join buffer (Block Nested Loop)`

在连接查询执行过程中,**当被驱动表不能有效的利用索引加快访问速度**,MySQL一般会为其分配一块名为
连接缓冲区(`Join Buffer`)的内存块来加快查询速度;即:使用[基于块的嵌套循环算法](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC11%E7%AB%A0%20%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9A%84%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6--%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/2.%20%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/3.%20%E5%9F%BA%E4%BA%8E%E5%9D%97%E7%9A%84%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.md).
例如:

```
mysql> EXPLAIN SELECT * FROM single_table INNER JOIN single_table2 ON single_table.common_field = single_table2.common_field;
+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
| id | select_type | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |
+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
|  1 | SIMPLE      | single_table  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9817 |   100.00 | NULL                                       |
|  1 | SIMPLE      | single_table2 | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9942 |    10.00 | Using where; Using join buffer (hash join) |
+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
2 rows in set, 1 warning (0.00 sec)
```

在对`single_table2`表的执行计划的`Extra`列显示了2个提示:

- `Using join buffer (Block Nested Loop)`

    由于对`single_table2`表的访问不能有效利用索引(`common_field`列上没有索引),
    只好退而求其次,使用`Join Buffer`来减少对`single_table2`表的访问次数,从而提高性能
- `Using where`

    查询语句中的连接条件为`single_table.common_field = single_table2.common_field`.
    从执行计划中可以看出:`single_table`是驱动表,`single_table2`是被驱动表.所以在访问`single_table2`表时,
    `s1.single_table.common_field`的值是已经确定的.
    因此,实际上查询`single_table2`表的条件是`single_table2.common_field = 一个常数`.所以提示了`Using where`信息.
