# 6. `Using where`

当某个搜索条件需要在server层进行判断时,`Extra`列中会提示`Using where`.例如:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE common_field = 'a';
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table        | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | single_table | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9817 |    10.00 | Using where |
+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

对于聚簇索引来说,是用不到索引条件下推特性的,因此本例中所有的搜索条件都得在server层进行判断.
即: 条件`common_field = 'a'`是在server层进行判断的,所以该语句的执行计划的`Extra`列才提示`Using where`.

有时,MySQL会扫描某个二级索引的1个扫描区间的记录.例如:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key1 = 'a' AND common_field = 'a';
+----+-------------+--------------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
| id | select_type | table        | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |
+----+-------------+--------------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | single_table | NULL       | ref  | idx_key1      | idx_key1 | 403     | const |    1 |    10.00 | Using where |
+----+-------------+--------------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

从执行计划可以看出,该语句在执行时将会使用到二级索引`idx_key1`索引.但是由于该索引并不包含`common_field`列,也就是说该条件
不能作为索引条件下推的条件在存储引擎层进行判断.存储引擎需要根据二级索引记录执行回表操作,并将完整的用户记录返回给server层,
然后在server层判断条件`common_field = 'a'`是否成立.因此该语句的执行计划的`Extra`列也提示了`Using where`.
