# 11. `Using temporary`

在许多査询的执行过程中,MySQL可能会借助临时表来完成一些功能,例如:

- 去重
- 排序

在执行包含`DISTINCT`/`GROUP BY`/`UNION`等子句的查询过程中,若不能有效利用索引来完成查询,则MySQL很有可能通过建立内部的临时表来执行查询.
如果查询中使用到了内部的临时表,则在执行计划的`Extra`列将会显示`Using temporary`提示.例如:

```
mysql> EXPLAIN SELECT DISTINCT common_field FROM single_table;
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
| id | select_type | table        | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra           |
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
|  1 | SIMPLE      | single_table | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10200 |   100.00 | Using temporary |
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
1 row in set, 1 warning (0.02 sec)
```

例如:

```
mysql> EXPLAIN SELECT common_field, COUNT(*) AS amount FROM single_table GROUP BY common_field;
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
| id | select_type | table        | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra           |
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
|  1 | SIMPLE      | single_table | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10200 |   100.00 | Using temporary |
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
1 row in set, 1 warning (0.00 sec)
```

从MySQL8.0开始,`GROUP BY`子句不再具有排序的功能(只有去重的功能),因此不会看到`Using filesort`的提示.

但如果使用MySQL5.X的版本,就会看到这样的执行计划(这里我直接拿书中的执行计划了):

```
 mysql> EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;
 +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
 | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |
 +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
 | 1  | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 | 100.00   | Using temporary; Using filesort |
 +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
```

上述执行计划的`Extra`列不仅包含`Using temporary`提示,还包含`Using filesort`提示.
这是因为MySQl会在包含`GROUP BY`子句的査询中默认添加`ORDER BY`子句.也就是说上面这个査询其实和下面这个查询等价:

```
mysql> EXPLAIN SELECT common_field, COUNT(*) AS amount FROM single_table GROUP BY common_field ORDER BY common_field;
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------+
| id | select_type | table        | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                           |
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------+
|  1 | SIMPLE      | single_table | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10200 |   100.00 | Using temporary; Using filesort |
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------+
1 row in set, 1 warning (0.00 sec)
```

若不想为包含`GROUP BY`子句的查询进行排序,需要我们显式声明`ORDER BY NULL`:

```
mysql> EXPLAIN SELECT common_field, COUNT(*) AS amount FROM single_table GROUP BY common_field ORDER BY NULL;
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
| id | select_type | table        | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra           |
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
|  1 | SIMPLE      | single_table | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10200 |   100.00 | Using temporary |
+----+-------------+--------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+
1 row in set, 1 warning (0.00 sec)
```

注意: **执行计划中出现`Using temporary`并不是一个好的征兆,因为建立与维护临时表要付出很大的成本,所以最好能使用索引来替代临时表**.
例如: 下面这个包含`GROUP BY`子句的查询就不需要使用临时表:

```
mysql> EXPLAIN SELECT key1, COUNT(*) AS amount FROM single_table GROUP BY key1;
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
| id | select_type | table        | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | single_table | NULL       | index | idx_key1      | idx_key1 | 403     | NULL | 10200 |   100.00 | Using index |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

从`type`列值为`index`以及`Extra`的列值为`Using index`的提示中可以看出,上述査询只需要扫描索引`idx_key1`即可,不需要临时表.
