# 5. `Using index condition`

有些搜索条件中虽然出现了索引列,但却不能使用到索引.例如:

```sql
SELECT * FROM single_table WHERE key1 > 'z' AND key1 LIKE '%a';
```

其中的条件`key1 > 'z'`可以用来形成扫描区间,但是条件`key1 LIKE '%a'`却不能.在没有索引条件下推这一特性之前,
server层生成执行计划后,按照如下步骤执行该查询:

- 步骤1.

    server层首先调用存储引擎的接口,定位到满足条件`key1> 'z'`的第1条二级索引记录

- 步骤2.

    存储引擎根据B+树索引快速定位到这条二级索引记录后,根据该二级索引记录的主键值进行回表操作,将完整的用户记录返给server层

- 步骤3.

    server层再判断其他的搜索条件是否成立:

    - 若成立则将其发送给客户端
    - 否则跳过该记录,然后向存储引擎层要下一条记录

- 步骤4.

    由于每条记录都有一个`next record`属性,根据该属性可以快速定位到符合条件`key1> 'z'`的下一条二级索引记录.
    然后再执行回表操作,将完整的用户记录返回给server层.
    
    然后重复步骤3,直到将索引`idx_key1`的扫描区间`key1 ∈ ('z',+∞)`内的所有记录都扫描过为止.

这个过程中存在问题:

虽然条件`key1 LIKE '%a'`不能作为边界条件来减少需要扫描的二级索引记录的数量,但这个搜索条件毕竟只涉及`key1`列,
且`key1`列是包含在索引`idx_key1`中的.所以,MySQL的设计者尝试改进了上面的执行步骤:

- 步骤1.

    server层首先调用存储引擎的接口,定位到满足条件`key1> 'z'`的第1条二级索引记录
    
- 步骤2.

    存储引擎根据B+树索引快速定位到这条二级索引记录后,**没有执行回表操作,而是先判断所有关于索引`idx_key1`中包含的列的条件是否成立**,
    在本例中即为条件`key1 > 'z' AND key1 LIKE'%a'`是否成立(注意这里判断的条件是`key1 > 'z' AND key1 LIKE'%a'`,而非只有`key1 LIKE'%a'`).

    - **若这些条件不成立,则直接跳过该二级索引记录,然后去找下一条二级索引记录**
    - **若这些条件成立,则执行回表操作,将完整的用户记录返回给server层**

    注意: 在这个过程中,存储引擎层并不是对所有扫描出的二级索引记录都回表,而是根据二级索引记录中的列值,判断该条二级索引记录
    是否符合条件,进而决定是否回表.

- 步骤3.

    server层再判断其他的搜索条件是否成立(本例中没有其他的搜索条件了).

    - 若成立则将其发送给客户端
    - 否则跳过该记录,然后向存储引擎层要下一条记录

- 步骤4.

    由于每条记录都有一个`next record`属性,根据该属性可以快速定位到符合条件`key1> 'z'`的下一条二级索引记录.
    定位到之后,同样还是先不执行回表操作,还是先判断所有关于索引`idx_key1`中包含的列的条件是否成立.

    - 若这些条件不成立,则直接跳过该二级索引记录,然后去找下一条二级索引记录
    - 若这些条件成立,则执行回表操作将完整的用户记录返回给server层

    然后重复步骤3,直到将索引`idx_key1`的扫描区间`key1 ∈ ('z',+∞)`内的所有记录都扫描过为止.

每次执行回表操作,都需要将1个聚簇索引页面加载到内存中,这是比较耗时的.所以尽管上述修改只改进了一点点,
但可以省去很多回表操作的成本.MySQL的设计者把这个改进称为索引条件下推(`Index Condition Pushdown`).

例如:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key1 > 'z' AND key1 LIKE '%b';
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table        | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | single_table | NULL       | range | idx_key1      | idx_key1 | 403     | NULL |  327 |   100.00 | Using index condition |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

这里有一个问题需要注意: 本例中,在使用索引条件下推特性时,在存储引擎层获取到一条二级索引记录后,
需要在存储引擎层继续判断条件`key1 > 'z' AND key1 LIKE'%a'`是否成立.可是扫描区间就是用条件`key1 > 'z'`生成的啊,
为什么还要在存储引擎层中作为索引条件下推的条件,再判断1次呢?

猜测这是MySQL的设计者为了编码方便而做的一种冗余处理(注意这是作者猜的,他也没有找到关于这个问题的直接说明).

由于**形成扫描区间的条件需要作为索引下推的条件,再在存储引擎层判断一次**,这导致在查询条件中即使只有形成扫描区间的条件时,
该条件依旧会被作为索引条件下推中的条件,在存储引擎层再判断一遍.

例如之前在讲解`rows`列时使用的查询语句:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key1 > 'z';
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table        | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | single_table | NULL       | range | idx_key1      | idx_key1 | 403     | NULL |  327 |   100.00 | Using index condition |
+----+-------------+--------------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)
```

可以看到,`Extra`列中依旧有`Using index condition`.

但是MySQL的设计者在代码中,对形成扫描区间的等值匹配条件又进行了特殊处理,使得这些条件不作为索引条件下推中的条件,也就是说这些等值匹配
的条件不需要在存储引擎层再判断一次.例如:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key1 = 'a';
+----+-------------+--------------+------------+------+---------------+----------+---------+-------+------+----------+-------+
| id | select_type | table        | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------------+------------+------+---------------+----------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | single_table | NULL       | ref  | idx_key1      | idx_key1 | 403     | const |    1 |   100.00 | NULL  |
+----+-------------+--------------+------------+------+---------------+----------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

这里之所以要把形成扫描区间的边界条件是否作为索引条件下推中的条件说得这么细,是为了后边的内容做铺垫,

注意: 索引条件下推特性只是为了在扫描某个扫描区间的二级索引记录时,尽可能减少回表操作的次数,从而减少I/O操作.
而对于聚簇索引而言,它不需要表,它本身就包含全部的列,索引条件下推的特性在聚簇索引中也起不到减少I/0操作的作用,
所以InnoDB的设计者规定:索引条件下推特性只适用于二级索引.
