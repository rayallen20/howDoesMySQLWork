# 11. `index`

[`index`访问方法介绍](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC10%E7%AB%A0%20%E6%9D%A1%E6%9D%A1%E5%A4%A7%E8%B7%AF%E9%80%9A%E7%BD%97%E9%A9%AC--%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/6.%20index.md)

简单理解,若:

- 可以使用索引覆盖
  - 即查询的字段都在索引中,不需要回表
- 但需要扫描全部的索引记录

则该表的访问方法为`index`

```
mysql> EXPLAIN SELECT key_part2 FROM single_table WHERE key_part3 = 'a';
+----+-------------+--------------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
| id | select_type | table        | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+--------------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | single_table | NULL       | index | idx_key_part  | idx_key_part | 1209    | NULL | 9817 |    10.00 | Using where; Using index |
+----+-------------+--------------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```

该查询的查询列表中只有`key_part2`这1个列,且搜索条件中也只有`key_part3`这1个列,这2个列又恰好包含在联合索引`idx_key_part`中,
但搜索条件`key_part3 = 'a'`不能形成合适的扫描区间以便减少需要扫描的记录数量(即无法使用`ref`或`range`访问方法),
只能扫描整个联合索引`idx_key_part`的记录,所以查询计划的`type`列的值为`index`.

注: 对于使用InnoDB存储引擎的表来说:

- 二级索引叶子节点中的记录只包含索引列和主键列的值
- 聚簇索引叶子节点中包含用户定义的全部列以及一些隐藏列

所以扫描二级索引的代价比扫描全部聚簇索引记录的代价更低一些.
