# 9. `index_subquery`

`index_subquery`与`unique_subquery`类似,只不过访问子查询中的表时使用的是普通的索引.即:

若:

- 查询优化器决定将IN子查询转换为EXISTS子查询
- 且子查询可以使用到**普通索引**键进行等值匹配
  - `unique_subquery`使用的是**主键或不允许存储NULL值的唯一二级索引**进行等值匹配
  - 有点像针对子查询的表的`ref`访问方法

则该子查询执行计划的`type`列的值为`index_subquery`.例如:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE common_field IN (SELECT key3 FROM single_table2 where single_table.common_field = single_table2.common_field) OR key3 = 'a';
+----+--------------------+---------------+------------+----------------+---------------+----------+---------+------+------+----------+-------------+
| id | select_type        | table         | partitions | type           | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |
+----+--------------------+---------------+------------+----------------+---------------+----------+---------+------+------+----------+-------------+
|  1 | PRIMARY            | single_table  | NULL       | ALL            | idx_key3      | NULL     | NULL    | NULL | 9817 |   100.00 | Using where |
|  2 | DEPENDENT SUBQUERY | single_table2 | NULL       | index_subquery | idx_key3      | idx_key3 | 403     | func |    1 |    10.00 | Using where |
+----+--------------------+---------------+------------+----------------+---------------+----------+---------+------+------+----------+-------------+
2 rows in set, 2 warnings (0.00 sec)
```

可以看到执行计划的第2条记录的`type`值为`index_subquery`,说明在执行子查询时会使用到`idx_key3`列的索引.

换言之,看到`type=index_subquery`,可以确定查询优化器把:`common_field IN (SELECT key3 FROM single_table2 where single_table.common_field = single_table2.common_field)`
改写为了:`EXISTS (SELECT 1 FROM single_table2 WHERE single_table.common_field = single_table2.common_field AND single_table2.key3 = single_table.common_field)`.
这样就可以使用到`single_table2`表的索引`idx_key3`了.
