# 8. `unique_subquery`

类似于两表连接中被驱动表的`eq_ref`访问方法,`unique_subquery`针对的是一些包含IN子查询的查询语句,
若:

- 查询优化器决定将IN子查询转换为EXISTS子查询
- 且子查询可以使用主键或不允许存储NULL值的唯一二级索引进行等值匹配
  - 有点像针对子查询的表的`const`访问方法

则该子查询执行计划的`type`列的值为`unique_subquery`.例如:

```
mysql> EXPLAIN SELECT * FROM single_table WHERE key2 IN (SELECT id FROM single_table2 WHERE single_table.key1 = single_table2.key1) OR key3 = 'a';
+----+--------------------+---------------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+
| id | select_type        | table         | partitions | type            | possible_keys    | key     | key_len | ref  | rows | filtered | Extra       |
+----+--------------------+---------------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+
|  1 | PRIMARY            | single_table  | NULL       | ALL             | idx_key3         | NULL    | NULL    | NULL | 9817 |   100.00 | Using where |
|  2 | DEPENDENT SUBQUERY | single_table2 | NULL       | unique_subquery | PRIMARY,idx_key1 | PRIMARY | 4       | func |    1 |    10.00 | Using where |
+----+--------------------+---------------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+
2 rows in set, 2 warnings (0.01 sec)
```

可以看到执行计划的第2条记录的`type`值为`unique_subquery`,说明在执行子查询时会使用到`id`列的索引.

换言之,看到`type=unique_subquery`,可以确定查询优化器把:`key2 IN (SELECT id FROM single_table2 WHERE single_table.key1 = single_table2.key1)`
改写为了:`EXISTS (SELECT 1 FROM single_table2 WHERE single_table.key1 = single_table2.key1 AND single_table2.id = single_table.key2)`.
