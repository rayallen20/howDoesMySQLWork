# 3. `eq_ref`

在连接查询时,若:

- 被驱动表是通过主键或不允许存储NULL值的唯一二级索引列**等值匹配**的方式进行访问的
  - 若该主键或不允许存储NULL值的唯一二级索引是联合索引,则所有的索引列都必须进行等值比较

则对该被驱动表的访问方法就是`eq_ref`.本质上是描述通过索引能在被驱动表中**精确定位到一行**数据的访问方法.
有点像对被驱动表的`const`访问方法,只是要求唯一二级索引列不能允许存储NULL值.

例如:

```
mysql> EXPLAIN SELECT * FROM single_table INNER JOIN single_table2 ON single_table.id = single_table2.id;
+----+-------------+---------------+------------+--------+---------------+---------+---------+---------------------------------+------+----------+-------+
| id | select_type | table         | partitions | type   | possible_keys | key     | key_len | ref                             | rows | filtered | Extra |
+----+-------------+---------------+------------+--------+---------------+---------+---------+---------------------------------+------+----------+-------+
|  1 | SIMPLE      | single_table  | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL                            | 9817 |   100.00 | NULL  |
|  1 | SIMPLE      | single_table2 | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | charset_demo_db.single_table.id |    1 |   100.00 | NULL  |
+----+-------------+---------------+------------+--------+---------------+---------+---------+---------------------------------+------+----------+-------+
2 rows in set, 1 warning (0.00 sec)
```

从执行计划的结果中可以看出:

- MySQL打算将`single_table`作为驱动表,`single_table2`作为被驱动表
- `single_table2`的访问方法是`eq_ref`,表示在访问`single_table2`表时可以通过主键的等值匹配来进行访问
