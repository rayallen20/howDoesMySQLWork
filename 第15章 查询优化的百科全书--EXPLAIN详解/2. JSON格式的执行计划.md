# 2. JSON格式的执行计划

前面介绍的`EXPLAIN`语句输出中缺少了一个衡量执行计划好坏的重要属性:**成本**.MySQL的设计提供了一种查看某个执行计划花费的成本的方式:
在`EXPLAIN`单词和真正的查询语句中间加上`FORMAT=JSON`.

例:

```
mysql> EXPLAIN FORMAT=JSON SELECT * FROM single_table INNER JOIN single_table2 ON single_table.key1 = single_table2.key2 WHERE single_table.common_field = 'a'\G;
*************************** 1. row ***************************
```

这里为了阅读方便,我把输出的JSON单独列出来了:

```json
EXPLAIN: {
  "query_block": {
    "select_id": 1,         # 整个查询语句只有1个SELECT关键字,该关键字对应的id号为1
    "cost_info": {
      "query_cost": "1401.25"   # 整个查询的执行成本预计为1401.25
    },
    "nested_loop": [      # 采用嵌套循环连接算法执行查询
      # 数组中的每个元素是参与嵌套循环连接算法的各个表的信息
      {
        "table": {
          "table_name": "single_table",   # single_table表是驱动表
          "access_type": "ALL",     # 访问方法为ALL,即全表扫描
          "possible_keys": [      # 可能使用的索引
            "idx_key1"
          ],
          "rows_examined_per_scan": 10200,    # 查询一次single_table表大致需要扫描10200条记录
          "rows_produced_per_join": 1020,     # 驱动表single_table的扇出是1020
          "filtered": "10.00",                # condition filtering代表的百分比
          "cost_info": {
            "read_cost": "942.25",            # 稍后解释
            "eval_cost": "102.00",            # 稍后解释
            "prefix_cost": "1044.25",         # 单次查询single_table表总共需要的成本
            "data_read_per_join": "2M"        # 读取的数据量
          },
          "used_columns": [       # 执行查询中涉及到的列
            "id",
            "key1",
            "key2",
            "key3",
            "key_part1",
            "key_part2",
            "key_part3",
            "common_field"
          ],
          # 对single_table表访问时,针对单表查询的条件
          "attached_condition": "((`charset_demo_db`.`single_table`.`common_field` = 'a') and (`charset_demo_db`.`single_table`.`key1` is not null))"
        }
      },
      {
        "table": {
          "table_name": "single_table2",    # single_table2表是被驱动表
          "access_type": "eq_ref",          # 访问方法为eq_ref,意味着使用主键索引或不允许存储NULL值的唯一二级索引等值匹配的方式访问
          "possible_keys": [            # 可能使用的索引
            "idx_key2"      
          ],
          "key": "idx_key2",        # 实际使用的索引
          "used_key_parts": [       # 使用到的索引列
            "key2"
          ],
          "key_length": "5",      # key_len
          "ref": [      # 与key2列进行等值匹配的对象
            "charset_demo_db.single_table.key1"
          ],
          "rows_examined_per_scan": 1,      # 查询一次single_table2表大致需要扫描1条记录
          "rows_produced_per_join": 1020,   # 被驱动表single_table2的扇出是1020(由于后边没有多余的表进行连接,所以这个值也没什么用)
          "filtered": "100.00",
          # single_table2表使用索引进行查询的搜索条件
          "index_condition": "(cast(`charset_demo_db`.`single_table`.`key1` as double) = cast(`charset_demo_db`.`single_table2`.`key2` as double))",
          "cost_info": {
            "read_cost": "255.00",      # 稍后解释
            "eval_cost": "102.00",      # 稍后解释
            "prefix_cost": "1401.25",   # 单次查询single_table和多次查询single_table2表总共的成本
            "data_read_per_join": "2M"  # 读取的数据量
          },
          "used_columns": [   # 执行查询中涉及到的列
            "id",
            "key1",
            "key2",
            "key3",
            "key_part1",
            "key_part2",
            "key_part3",
            "common_field"
          ]
        }
      }
    ]
  }
}
```

```
1 row in set, 2 warnings (0.00 sec)

ERROR: 
No query specified
```

这里重点解释`cost_info`中的各个属性.先看`single_table`表的`cost_info`:

```json
{
  "cost_info": {
    "read_cost": "942.25",
    "eval_cost": "102.00",
    "prefix_cost": "1044.25",
    "data_read_per_join": "2M"
  }
}
```

- `read_cost`由以下2部分组成:
  - I/O成本
  - 检测`rows * (1 - filter)`条记录的CPU成本

- `eval_cost`的计算方式:
  - 检测`rows * filter`条记录的CPU成本

- `prefix_cost`就是单独查询`single_table`表的成本,本例中即为`read_cost + eval_cost`,即`942.25 + 102.00 = 1044.25`.

`single_table2`表的`cost_info`如下:

```json
{
  "cost_info": {
    "read_cost": "255.00",
    "eval_cost": "102.00",
    "prefix_cost": "1401.25",
    "data_read_per_join": "2M"
  }
}
```

由于`single_table2`表是被驱动表,所以可能被读取多次.这里的`read_cost`和`eval_cost`是访问多次`single_table2`表后累加起来的值.
主要关注`prefix_cost`的值代表的是整个连接查询预计的成本,即: 单次查询`single_table`表和多次查询`single_table2`表后的成本的和.
即: `255.00 + 102.00 + 1044.25 = 1401.25`.
