# 4. REDUNDANT行格式中NULL值的处理

因为REDUNDANT行格式并没有NULL值列表,所以REDUNDANT行格式在字段长度偏移列表中的各个列对应的偏移量处做了一些特殊处理:
**将列对应的偏移量值的第1个比特位作为是否为NULL的依据,该比特位也被称为NULL比特位**.
也就是说在解析一条记录的某个列时,首先要看该列对应的偏移量的NULL比特位是不是为1:

- 若为1,则该列的值就是NULL
- 否则不是NULL

这也就解释了之前的疑问:为什么只要记录的真实数据大于127(十六进制`0x7F`,二进制`01111111`)时,就采用2个字节来表示一个列对应的偏移量?

因为第1个比特位是NULL比特位,用来标记该列的值是否为NULL,不能用于表示偏移量的大小.换言之,在这个规则下,1字节能够表示偏移量的最大值就是127

注意: **对于值为NULL的列来说,该列的类型是否为定长类型决定了NULL值的实际存储方式**

这里再贴一下表结构和数据:

```
mysql> SHOW CREATE TABLE record_format_demo;
+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table              | Create Table                                                                                                                                                                                                                                                                |
+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| record_format_demo | CREATE TABLE `record_format_demo` (
  `c1` varchar(10) DEFAULT NULL,
  `c2` varchar(10) NOT NULL,
  `c3` char(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,
  `c4` varchar(10) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=ascii ROW_FORMAT=REDUNDANT |
+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
```

```
mysql> SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)
```

分析`record_format_demo`表的第二条记录:

它的字段长度偏移列表如下:

```
 A4 A4 1A 17 13 0C 06
```

按照列的顺序排放就是:

```
06 0C 13 17 1A A4 A4
```

- **如果存储NULL值的字段是定长类型的,(例如`CHAR(M)`类型),则NULL值也将占用记录的真实数据部分,并把该字段对应的数据使用`0x00`字节填充**
  - 如下图示中,第二条数据的`c3`列的值部分

![REDUNDANT行格式下2条记录的具体格式](./img/REDUNDANT行格式下2条记录的具体格式.jpg)

第二条记录的`c3`列的值是 NULL,而`c3`列的类型是`CHAR(10)`,占用记录的真实数据部分10个字节,所以在REDUNDANT行格式中使用`0x00 00 00 00 00 00 00 00 00 00`来表示NULL值

另外,`c3`列对应的偏移量为`0xA4`,对应的二进制为`10100100`.可以看到最高位为1,表示该列的值为`NULL`.
将最高位去掉后的值变成了`0100100`,对应的十进制值为36.
而`c2`列对应的偏移量为`0x1A`,对应的十进制为`26`.`36 - 26 = 10`,也就是说最终`c3`列占用的存储空间为10个字节

- **如果该存储NULL值的字段是变长数据类型的,则不在记录的真实数据处占用任何存储空间**

比如`record_format_demo`表的`c4`列的类型为`VARCHAR(10)`,是一个变长数据类型,`c4`列对应的偏移量为`0xA4`,
与`c3`列对应的偏移量相同,这就表示`c4`列的值也为NULL,
将`0xA4`的最高位去掉后对应的十进制值也是36,`36 - 36 = 0`,也就是说`c4`列本身不占用任何记录的实际数据处的空间
