# 4. 对比各种执行方案的代价,找出成本最低的那个方案

这里再贴一下查询语句:

```sql
SELECT *
FROM single_table
WHERE
    key1 IN ('a', 'b', 'c')
AND
    key2 > 10
AND
    key2 < 1000
AND
    key3 > key2
AND
    key_part1 LIKE '%hello%'
AND
    common_field = '123';
```

执行该查询的各种可执行方案以及它们对应的成本列如下:

- 全表扫描的成本: 2037.7
- 使用`uk_key2`的成本: 134.01
- 使用`idx_key1`的成本: 168.21

很显然,使用`uk_key2`的成本最低,所以选择`idx_key2`来执行查询.

注: 

再一次强调,前文的成本计算方式与MySQL5.7.22中的成本计算方式稍有不同,但核心思路没变.

另外,无论使用`idx_key1`还是`uk_key2`,都是`range`访问方法.在使用`range`访问方法进行查询时,扫描区间中包含多少条二级索引记录,
优化器就认为要进行多少次回表操作,也就相当于要进行多少次页面I/O.

但是对于`ref`访问方法来说,InnoDB的设计者在计算因回表操作带来的I/O成本时,就设置了天花板.在使用`ref`访问方法时,因回表操作带来的I/O成本,
不得超过以下2个I/O成本之一:

- 访问全表记录数的1/10个页面的I/O成本
  - 可以简单理解为: `二级索引中列值 = 搜索条件中列值`的数据量不超过全表数据的1/10
- 全表扫描的I/O成本的3倍

之所以设置这样的天花板,猜测是因为在使用`ref`访问方法时,需要扫描的二级索引记录的`id`值离得更近,1次回表操作可能能够将多条需要访问的聚簇索引
记录都从磁盘加载到内存.即:即使`range`访问方法和`ref`访问方法需要扫描的记录数相同,`ref`方法也更有优势(因为回表时可能能够1次加载多条聚簇索引记录).
