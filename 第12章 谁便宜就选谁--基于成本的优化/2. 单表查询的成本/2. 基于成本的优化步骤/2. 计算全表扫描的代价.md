# 2. 计算全表扫描的代价

对InnoDB存储引擎来说,全表扫描的意思就是把聚簇索引中的记录都依次与给定的搜索条件进行比较,并把符合搜索条件的记录加入到结果集中.
所以需要将聚簇索引对应的页面加载到内存中,然后再检测记录是否符合搜索条件.由于`查询成本 = I/O成本 + CPU成本`,
所以在计算全表扫描的代价时需要两个信息:

- 聚簇索引占用的页面数
- 该表中的记录数

这两个信息从哪来呢?MySQL的设计者为每个表维护了一系列的统计信息.关于这些统计信息的收集方式这里我们先不用关心,
现在关心的是如何查看这些统计信息.使用`SHOW TABLE STATUS`语句来查看表的统计信息.如果要看某个指定表的统计信息,
在该语句后加对应的LIKE语句即可.例如,查看表`single_table`的统计信息:

```
mysql> SHOW TABLE STATUS LIKE 'single_table'\G;
*************************** 1. row ***************************
           Name: single_table
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 10200
 Avg_row_length: 155
    Data_length: 1589248
Max_data_length: 0
   Index_length: 1277952
      Data_free: 4194304
 Auto_increment: 10001
    Create_time: 2025-07-31 10:46:17
    Update_time: NULL
     Check_time: NULL
      Collation: utf8mb4_0900_ai_ci
       Checksum: NULL
 Create_options: 
        Comment: 
1 row in set (0.01 sec)

ERROR: 
No query specified
```

注: 上边这个是我的环境中的`single_table`表的统计信息,由于版本和表中随机的数据和书中的都不一样,所以后边贴上了书中的统计信息.
书中的统计信息如下:

```
mysql> SHOW TABLE STATUS LIKE 'single_table'\G;
*************************** 1. row ***************************
 Name: single_table
 Engine: InnoDB
 Version: 10
 Row_format: Dynamic
 Rows: 9693
Avg_row_length: 163
 Data_length: 1589248
Max_data_length: 0
 Index_length: 2752512
 Data_free: 4194304
Auto_increment: 10001
 Create_time: 2018-12-10 13:37:23
 Update_time: 2018-12-10 13:38:03
 Check_time: NULL
 Collation: utf8_general_ci
 Checksum: NULL
Create_options:
 Comment:
1 row in set (0.01 sec)
```

且后续有些内容中使用到的具体数值(例如符合某条件的数据的数量),也尽量按照书中的数值来进行讲解.

们目前只看2个选项即可:

- `Rows`

表示表中的记录条数.对于使用MyISAM存储引擎的表来说,该值是准确的;**对于使用InnoDB存储引擎的表来说,该值是一个估计值**.
从查询结果也能看出,由于`single_tabl` 表使用的是InnoDB存储引擎,虽然该表实际有10,000条记录,
但是执行`SHOW TABLE STATUS`语句后显示的`Rows`值只有9693条记录.

注: 这里我的统计信息中`Rows`值是10200,说明在MySQL8.X中,`Rows`选项的值仍然还是估计值

- `Data_length`

表示表占用的存储空间字节数(注意单位是字节).对于使用MyISAM存储引擎的表来说,该值就是数据文件的大小;
**对于使用InnoDB存储引擎的表来说,该值就相当于聚簇索引占用的存储空间大小**.可以按照下面的公式计算该值的大小:

```
Data_length = 聚簇索引的页面数量 * 每个页面的大小
```

`single_table`表使用默认16KB的页面大小(默认INDEX类型页的大小),而该统计结果显示`Data_length`的值是`1,589,248`,
所以可以反向推导出聚簇索引的页面数量: `聚簇索引的页面数量 = 1589248 / 16 / 1024 = 97`

现在已经得到了:

- 聚簇索引占用的页面数量
- 该表记录数的估计值

接下来就可以计算全表扫描成本了.但是MySQL的设计者在真正计算成本时会进行一些微调,这些微调的值是直接硬编码到代码中的.
由于没有注释,原书坐着也不知道这些微调值的意思.但是由于这些微调的值非常小,小到不会影响分析,所以就不在这些微调值上纠结了(
我猜测这些常数是MySQL设计者为了防止I/O成本或CPU成本过低而设置的,以避免查询优化器选择不合适的索引).
全表扫描成本的计算过程如下:

- I/O成本: `97 * 1.0 + 1.1 = 98.1`.其中:

    - 97: 聚簇索引占用的页面数量
    - 1.0: 读取1个页面的成本常数
    - 1.1: 微调值

- CPU成本: `9693 * 0.2 + 1.0 = 1939.6`.其中:

    - 9693: 是统计数据中表的记录数,对于InnoDB存储引擎来说是一个估计值
    - 0.2: 访问1条记录所需的成本常数
    - 1.0: 微调值

- 总成本: `98.1 + 1939.6 = 2037.7`

综上所述,对`single_table`表的全表扫描所需的总成本为: 2037.7

注: 前文说过,完整的用户记录其实都存储在聚簇索引对应的B+树的叶子节点中,所以只要通过根节点获得了
最左边的叶子节点,就可以沿着叶子节点组成的双向链表把所有记录都查看一遍.也就是说在全表扫描的过程中,
有一些B+树的非叶子节点是不需要访问的.但是MySQL的设计者在计算全表扫描成本时,直接使用聚簇索引占用的所有页面数作为计算I/O成本的依据,
没有区分叶子节点和非叶子节点.这有些"简单粗暴",注意一下即可.
