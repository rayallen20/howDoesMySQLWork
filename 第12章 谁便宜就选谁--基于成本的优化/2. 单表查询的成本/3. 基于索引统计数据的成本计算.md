# 3. 基于索引统计数据的成本计算

有时候使用索引执行查询时会有许多单点扫描区间,使用IN语句就很容易产生非常多的单点区间.例如该查询(`...`表示还有很多参数):

```sql
SELECT *
FROM single_table
WHERE key1 IN ('aa1', 'aa2', 'aa3', '...' , 'zzz');
```

很显然,该查询可能使用到的索引为`idx_key1`.由于该索引并不是唯一二级索引,所以无法确定1个单点区间对应的
二级索引记录的条数有多少,需要计算.计算方式之前已经说过了:

- step1. 先获取索引对应的B+树的区间最左记录和区间最右记录
- step2. 然后再计算这2条记录之间有多少记录(记录条数少的时候可以做到精确计算,多的时候只能估算)

MySQL的设计者把这种**通过直接访问索引对应的B+树来计算某个扫描区间内对应的索引记录条数的方式称为`index dive`**.

注: `index dive`就是直接利用索引对应的B+树来计算某个扫描区间内对应的记录条数.也就是说,在查询真正执行前的执行计划生成阶段,
就可能少量地访问B+树中的数据.

有零星几个单点区间的话,使用`index dive`的方式去计算这些单点扫描区间对应的记录数也不是什么问题.但是IN语句中参数太多就不行了.
假设IN语句中有20000个参数,这就意味着MySQL的优化器为了计算这些单点扫描区间对应的索引记录条数,要进行20000次`index dive`操作,
由此带来的性能损耗可就大了,搞不好计算这些单点扫描区间对应的索引记录条数的成本比直接全表扫描的成本都大.

MySQL的设计者考虑到了这种情况,所以提供了一个系统变量`eq_range_index_dive_limit`,该变量的默认值如下:

```
mysql> SHOW VARIABLES LIKE '%dive%';
+---------------------------+-------+
| Variable_name             | Value |
+---------------------------+-------+
| eq_range_index_dive_limit | 200   |
+---------------------------+-------+
1 row in set (0.01 sec)
```

也就是说,如果通过IN语句生成的单点扫描区间的数量小于200个,则使用`index dive`的方式计算各个单点区间对应的记录条数;
如果大于或等于200个,就不能使用`index dive`了,而是要使用索引统计数据(`index statistics`)来进行**估算**.

像会为每个表维护1份统计数据一样,MySQL也会为表中的每1个索引维护1份统计数据,查看某个表中索引的统计数据可以使用
`SHOW INDEX FROM 表名`的语法.查看`single_table`表的各个索引的统计数据如下:

```
mysql> SHOW INDEX FROM single_table;
+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table        | Non_unique | Key_name     | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| single_table |          0 | PRIMARY      |            1 | id          | A         |       10200 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| single_table |          0 | uk_key2      |            1 | key2        | A         |       10000 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| single_table |          1 | idx_key3     |            1 | key3        | A         |       10000 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| single_table |          1 | idx_key_part |            1 | key_part1   | A         |       10000 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| single_table |          1 | idx_key_part |            2 | key_part2   | A         |       10000 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| single_table |          1 | idx_key_part |            3 | key_part3   | A         |       10000 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| single_table |          1 | idx_key1     |            1 | key1        | A         |       10000 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
7 rows in set (0.01 sec)
```

注: 下面的是书中的索引统计数据,后续以他书中的为准.因为随机生成的数据不同,所以导致有些值也不同.

```
mysql> SHOW INDEX FROM single_table;
+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table        | Non_unique       | Key_name      | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| single_table | 0                | PRIMARY       | 1            | id          | A         | 9693        | NULL     | NULL   |      | BTREE      |         |               |
| single_table | 0                | idx_key2      | 1            | key2        | A         | 9693        | NULL     | NULL   | YES  | BTREE      |         |               |
| single_table | 1                | idx_key1      | 1            | key1        | A         | 968         | NULL     | NULL   | YES  | BTREE      |         |               |
| single_table | 1                | idx_key3      | 1            | key3        | A         | 799         | NULL     | NULL   | YES  | BTREE      |         |               |
| single_table | 1                | idx_key_part  | 1            | key_part1   | A         | 9673        | NULL     | NULL   | YES  | BTREE      |         |               |
| single_table | 1                | idx_key_part  | 2            | key_part2   | A         | 9999        | NULL     | NULL   | YES  | BTREE      |         |               |
| single_table | 1                | idx_key_part  | 3            | key_part3   | A         | 10000       | NULL     | NULL   | YES  | BTREE      |         |               |
+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
7 rows in set (0.01 sec)
```

|       属性名       |                                                                                                                   描述                                                                                                                    |
|:---------------:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|     `Table`     |                                                                                                              该列所属索引所在的表名称                                                                                                               |
|  `Non_unique`   |                                                                               该列所属索引是否不为唯一索引.对于聚簇索引和唯一二级索引来说,`Non_unique`的值为0;对于普通二级索引来说,`Non_unique`值为1                                                                                |
|   `Key_name`    |                                                                                                 该列所属索引的名称.若是聚簇索引,则`Key_name`为`PRIMARY`                                                                                                  |
| `Seq_in_index`  |                                                                     该列在索引包含的列中的位置,从1开始计数.例如:对于联合索引`idx_key_part`来说,`key_part1`/`key_part2`/`key_part3`对应的位置分别为1/2/3                                                                     |
|  `Column_name`  |                                                                                                                 索引列的名称                                                                                                                  |
|   `Collation`   |                                                                                         索引列中的值是按照哪种排序方式存放的.`Collation`为`A`时代表升序存放;为`NULL`时代表不排序                                                                                         |
|  `Cardinality`  | 索引列中不重复值的数量.对于联合索引来说,`Cardinality`表示从索引列的第1个列开始,到本列为止的列组合不重复的数量.例如,对于联合索引`idx_key_part`来说:`key_part2`这一行的`Cardinality`列值表示`key_part1`/`key_part2`的组合不重复的数量;`key_part3`这一行的`Cardinality`列值表示`key_part1`/`key_part2`/`key_part3`的组合不重复的数量 |
|   `Sub_part`    |                                                                      对于存储字符串或者字节串的列来说,有时只想对这些串的前`n`个字符或字节建立索引.`Sub_part`表示的就是这个`n`的值.若对完整的列建立索引,则`Sub_part`值就为NULL                                                                      |
|    `Packed`     |                                                                                                 索引列如何被压缩.NULL值表示未被压缩.这个属性目前不用了解,可以先忽略掉                                                                                                  |
|     `Null`      |                                                                                                             该索引列是否允许存储NULL值                                                                                                             |
|  `Index_type`   |                                                                                                     该列所属索引的类型.最常见的就是`BTREE`,即B+树索引                                                                                                      |
|    `Comment`    |                                                                                                              该列所属索引的一些额外信息                                                                                                              |
| `Index_comment` |                                                                                                      创建索引时,使用COMMENT语句为该索引添加的注释信息                                                                                                       |

重点看`Cardinality`属性.`Cardinality`直译过来就是"基数"的意思,**表示某个索引列中不重复值的个数**.比如对于一个有10000行记录的表来说:

- 某个索引列的`Cardinality`属性值是10000,则表示该列中没有重复的值
- 某个索引列的`Cardinality`属性值是1,则表示该列中全部都是重复的值

注意: **对于InnoDB存储引擎来说,使用`SHOW INDEX`语句展示出来的某个索引列的`Cardinality`属性是一个估计值,并不精确**.

前边讲到,当IN语句对应的单点扫描区间的数量大于或等于系统变量`eq_range_index_dive_limit`的值时,就不会使用`index dive`的方式计算
各个单点扫描区间对应的索引记录条数,而是使用索引统计数据(`index statistics`).这里索引统计数据指的是如下2个值:

- 使用`SHOW TABLE STATUS`语句显示的`Rows`值,表示1个表中有多少条记录
  - 这个统计数据之前说过,是一个估计值
- 使用`SHOW INDEX`语句显示的某个索引列的`Cardinality`属性值,表示该索引列中不重复值的个数
  - 这个统计数据也是一个估计值

结合Rows统计数据,可以计算出在某一个索引列中,1个值平均重复的次数: `1个值平均重复的次数 ≈ Rows / Cardinality`

以`single_table`表的索引`idx_key1`为例,该表的`Rows`值为9693,索引列`key1`的`Cardinality`值为968,
所以可以计算`key1`列平均单个值的重复次数为: `9693 / 968 ≈ 10条`

此时再看本节最开始的那条查询语句:

```sql
SELECT *
FROM single_table
WHERE key1 IN ('aa1', 'aa2', 'aa3', '...' , 'zzz');
```

假设IN语句中对应着20000个单点扫描区间,就直接使用统计数据来估算这些单点扫描区间对应的记录条数了.每个单点扫描区间大约对应10条记录,
所以总共需要回表的记录数就为: `20000 * 10 = 200000条`

使用统计数据来计算单点扫描区间对应的索引记录条数比`index dive`的方式简单多了.但是它的致命弱点就是**不精确**.
使用统计数据算出来的查询成本与实际执行时的成本可能相差很大.

注: 在MySQL5.7.3及之前的版本中,`eq_range_index_dive_limit`的默认值为10,之后的版本默认值为200.
所以若使用的是5.7.3及之前的版本,很容易采用索引统计数据而非`index dive`的方式来计算查询成本.
**当查询中使用到了IN查询,但是却实际没有用到索引,就应该查看是否由于`eq_range_index_dive_limit`值太小导致的**.
