# 4. 多表连接的成本分析

分析多表连接的成本之前,先考虑多表连接时可能产生出多少种连接顺序:

- 对于2表连接,比如表A和表B连接:
  - `A JOIN B`
  - `B JOIN A`
  - 只有这2种连接顺序.其实相当于`2 × 1 = 2`种连接顺序

- 对于3表连接,比如表A/表B/表C连接:
  - `A JOIN B JOIN C`
  - `A JOIN C JOIN B`
  - `B JOIN A JOIN C`
  - `B JOIN C JOIN A`
  - `C JOIN A JOIN B`
  - `C JOIN B JOIN A`
  - 共有6种连接顺序,相当于`3 × 2 × 1 = 6`种连接顺序

- 对于4表连接,则会有`4 × 3 × 2 × 1 = 24`种连接顺序
- 对于n表连接,则会有`n * (n - 1) * (n - 2) * ··· * 1`种连接顺序,即`n!`种连接顺序

在有n个表进行连接时,MySQL查询优化器需要计算每一种连接顺序的成本么?确实真的是要都算一遍,
不过MySQL的设计想了很多办法,来减少因计算不同连接顺序下的查询成本,而带来的性能损耗:

- 提前结束某种顺序的成本评估

    MySQL在计算各种链接顺序的成本之前,会维护一个全局的变量,该变量表示当前最小的连接查询成本.
    若在分析某个连接顺序的成本时,该成本已经超过当前最小的连接查询成本,那就不对该连接顺序继续往下分析了.
    
    例如A/B/C这3个表进行连接,已经计算得到连接顺序`A JOIN B JOIN C`是当前的最小连接成本(假设为10.0).
    在计算连接顺序`B JOIN C JOIN A`时,发现`B JOIN C`的连接成本就已经大于10.0,
    此时就不再继续往后分析`B JOIN C JOIN A`这个连接顺序的成本了.

- 系统变量`optimizer_search_depth`

    为了防止无穷无尽的分析各种连接顺序的成本,MySQL的设计者提供了一个`optimizer_search_depth`系统变量.

    - 若连接表的个数小于该值,则就穷举分析每种连接顺序的成本
    - 否则只对与`optimizer_search_depth`值相同数量的表进行穷举分析

    很显然:

    - 该值越大,成本分析的越精确,越容易得到好的执行计划,但是消耗的时间也就越长
    - 否则得到不是很好的执行计划,但是节省了连接成本的分析时间

    ```
    mysql> SHOW VARIABLES LIKE '%optimizer_search_depth%';
    +------------------------+-------+
    | Variable_name          | Value |
    +------------------------+-------+
    | optimizer_search_depth | 62    |
    +------------------------+-------+
    1 row in set (0.00 sec)
    ```
    
    该变量的默认值为62.
  
- 某些规则压根就不考虑某些连接顺序

    即使存在上边2条规则的限制,但是分析多个表的不同连接顺序所花费的成本时,用时还是会很长.
    所以MySQL的设计者干脆提出了一些启发式规则(就是根据以往经验指定的一些规则).**凡是不满足这些规则的连接顺序压根就不分析,
    这样可以极大的减少需要分析的连接顺序的数量,但这样也可能错失最优的执行计划**.
    系统变量`optimizer_prune_level`用于控制是否启用这些启发式规则.
    
    ```
    mysql> SHOW VARIABLES LIKE '%optimizer_prune_level%';
    +-----------------------+-------+
    | Variable_name         | Value |
    +-----------------------+-------+
    | optimizer_prune_level | 1     |
    +-----------------------+-------+
    1 row in set (0.01 sec)
    ```
    
    默认启用这些启发式规则.
