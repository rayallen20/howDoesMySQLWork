# 2. 使用`s2`作为驱动表

这里再贴一下查询语句:

```sql
SELECT *
FROM s1 INNER JOIN s2 
ON
    s1.key1 = s2.common_field 
WHERE
    s1.key2 > 10
AND
    s1.key2 < 1000
AND
    s2.key2 > 1000
AND
    s2.key2 < 2000;
```

- step1. 分析针对驱动表的成本最低的执行方案

    涉及驱动表`s2`的搜索条件为`s2.key2 > 1000 AND s2.key2 < 2000`.

    该查询可能使用到索引`uk_key2`,从全表扫描和使用索引`uk_key2`这2个方案中选出成本最低的那个,这个过程前文已经分析过了,
    很显然使用索引`uk_key2`执行查询的成本更低.

- step2. 分析针对驱动表的连接条件的成本最低的执行方案

    此时,涉及被驱动表`s1`的搜索条件如下:

    - `s1.key1 = 常数`
    - `s1.key2 > 10 AND s1.key2 < 1000`

    这时和使用`s1`作为驱动表的情况就不同了:

    - 使用`idx_key1`时,可以使用`ref`访问方法
    - 使用`uk_key2`时,可以使用`range`访问方法

    这时对于优化器来讲,需要从下列方案中选出1个成本最低的方案:

    - 全表扫描
    - 使用索引`idx_key1`
    - 使用索引`uk_key2`

    索引`uk_key2`的扫描区间是确定的:`key2 ∈ (10, 1000)`,按照`index dive`的过程即可计算出使用索引`uk_key2`成本.
    但是,在没有真正执行查询之前,条件`s1.key1 = 常数`中的常数值是不知道的,怎么衡量使用索引`idx_key1`执行查询的成本呢?
    很简单,使用`index statistics`中,`Key_name = idx_key1`那行的`Cardinality`列值来估算即可(`Cardinality / Rows`即可得到
    在`key1`列中平均每个值大概重复多少次).一般情况下,`ref`访问方法比`range`访问方法的成本低,这里假设使用索引`idx_key1`来访问`s1`.

所以此时使用`s2`作为驱动表时的总成本如下(暂时不考虑使用Join Buffer对成本的影响):

```
使用uk_key2访问s2的成本 + s2的扇出值 * 使用idx_key1访问s1的成本
```

最后,优化器会从这2种连接顺序中,选出成本更低的那种连接顺序去真正地执行查询.从这个的计算过程可以看出,在连接查询成本中,"占大头"的其实是
`驱动表扇出值 * 单次访问被驱动表的成本`,所以优化的重点其实是以下2个部分:

- 尽量减少驱动表的扇出
- 对被驱动表的访问成本尽量低

在实际书写连接查询语句时,第二点十分有用.需要**尽量在被驱动表的连接列上建立索引,这样就可以使用`ref`访问方法来降低访问被驱动表的成本**了.
如果可以,被驱动表的连接列最好是该表的主键或者唯一二级索引列,这样就可以把访问被驱动表的成本降至更低了.
