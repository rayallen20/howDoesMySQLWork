# 1. 使用`s1`作为驱动表

这里再贴一下查询语句:

```sql
SELECT *
FROM s1 INNER JOIN s2 
ON
    s1.key1 = s2.common_field 
WHERE
    s1.key2 > 10
AND
    s1.key2 < 1000
AND
    s2.key2 > 1000
AND
    s2.key2 < 2000;
```

- step1. 分析针对驱动表的成本最低的执行方案

    涉及驱动表`s1`的搜索条件为`s1.key2 > 10 AND s1.key2 < 1000`.
    
    该查询可能使用到索引`uk_key2`,从全表扫描和使用索引`uk_key2`这2个方案中选出成本最低的那个,这个过程前文已经分析过了,
    很显然使用索引`uk_key2`执行查询的成本更低.

- step2. 分析针对驱动表的连接条件的成本最低的执行方案

    此时,涉及被驱动表`s2`的搜索条件如下:

    - `s2.common_field = 常数`
      - 这是因为针对驱动表`s1`查询后的结果集中的每1条记录,都需要访问1次被驱动表`s2`,涉及两表的条件现在相当于只涉及被驱动表`s2`
    - `s2.key2 > 1000 AND s2.key2 < 2000`

    很显然,由于`common_field`没有用到索引,所以条件`s2.common_field = 常数`并没有什么卵用.
    此时用来访问`s2`表的可用方案也是:

    - 全表扫描
    - 使用索引`uk_key2`

    很显然使用索引`uk_key2`的成本更小.

所以此时使用`s1`作为驱动表时的总成本如下(暂时不考虑使用Join Buffer对成本的影响):

```
使用uk_key2访问s1的成本 + s1的扇出值 * 使用uk_key2访问s2的成本
```