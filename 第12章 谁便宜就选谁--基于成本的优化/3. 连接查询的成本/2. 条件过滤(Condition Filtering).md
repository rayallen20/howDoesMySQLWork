# 2. 条件过滤(Condition Filtering)

前文说过,MySQL中连接查询采用的是嵌套循环连接算法,驱动表会被访问一次,被驱动表可能会被访问多次.
所以,对于两表连接查询来说,它的查询成本由以下2个部分构成:

- 单次查询驱动表的成本
- 多次查询被驱动表的成本(**具体查询多少次取决于对驱动表查询的结果集中有多少条记录**)

**对驱动表进行查询后得到的记录条数**称为驱动表的扇出(fanout).显然,驱动表的扇出值越小,对被驱动表的查询次数也就越少,
连接查询的总成本也就越低.当查询优化器想计算执行整个连接查询所需的成本时,就需要计算出驱动表的扇出值.有的时候扇出值的计算是很容易的,
比如以下这2个查询:

- 查询1:

```sql
SELECT *
FROM s1 INNER JOIN s2;
```

假设使用`s1`表作为驱动表,很显然就只能使用全表扫描的方式对驱动表执行单表查询.驱动表的扇出值也很明确,
那就是驱动表中有多少记录,扇出值就是多少.前文说过,**统计数据中`s1`表的记录行数是9693,
也就是说优化器直接会把9693当作`s1`表的扇出值**.

注意: 这里仍旧是在执行计划生成阶段,并没有真的去查询,所以计算fanout时,能拿到的只是根据`index dive`或`index statistics`预估的信息.

本例中计算fanout时,优化器并没有使用索引,而是直接使用了表的统计信息.也就是说使用`index statistics`来估算的扇出值.

- 查询2:

```sql
SELECT *
FROM s1 INNER JOIN s2
WHERE
    s1.key2 >10
AND
    s1.key2 < 1000;
```

仍然假设`s1`表是驱动表,很显然可以使用索引`uk_key2`对驱动表执行单表查询.此时索引`uk_key2`的扫描区间
`key2 ∈ (10, 1000)`中有多少条记录,那么扇出值就是多少.前边计算过,满足`uk_key2`的扫描区间`key2 ∈ (10, 1000)`的记录数是95条,
也就是说在该查询中优化器会把95当作驱动表`s1`的扇出值.

本例中计算fanout时,优化器使用了索引`uk_key2`.也就是说使用`index dive`来估算的扇出值.

有的时候扇出值的计算就变得很棘手,比方说下边几个查询:

- 查询3:

```sql
SELECT *
FROM s1 INNER JOIN s2 
WHERE s1.common_field > 'xyz';
```

该查询和查询1类似,只不过在查询驱动表`s1`时多了一个搜索条件`common_field > 'xyz'`.查询优化器不会真正的去执行查询,
所以它只能**猜**这9693条记录里有多少条记录满足条件`common_field > 'xyz'`.

本例中计算fanout时,由于`common_field`字段没有索引,所以优化器也无法根据`index statistics`来估算扇出值,只能纯靠猜.

- 查询4:

```sql
SELECT *
FROM s1 INNER JOIN s2 
WHERE
    s1.key2 > 10
AND
    s1.key2 < 1000
AND
    s1.common_field > 'xyz';
```

该查询和查询2类似,只不过在查询驱动表`s1`时也多了一个搜索条件`common_field > 'xyz'`.不过因为该查询可以使用索引`uk_key2`,
所以只需要从符合二级索引扫描区间`key2 ∈ (10, 1000)`的二级索引记录中猜有多少条记录符合条件`common_field > 'xyz'`,
也就是只需要在95条记录中猜有多少条记录符合条件`common_field > 'xyz'`.

本例中计算fanout时,优化器使用了索引`uk_key2`.也就是说先使用`index dive`计算`key2 ∈ (10, 1000)`的二级索引记录的数量,
再猜在这些二级索引记录中符合条件`common_field > 'xyz'`的二级索引记录的数量.

- 查询5:

```sql
SELECT *
FROM s1 INNER JOIN s2 
WHERE
    s1.key2 > 10
AND
    s1.key2 < 1000
AND
    s1.key1 IN ('a', 'b', 'c')
AND
    s1.common_field > 'xyz';
```

该查询和查询2类似,不过在对驱动表`s1`选取索引`uk_key2`执行查询后,优化器需要在二级索引扫描区间的记录中
猜测有多少条记录符合以下2个条件:

- `key1 IN ('a', 'b', 'c')`
- `common_field > 'xyz'`

本例中计算fanout时,优化器使用了索引`uk_key2`.也就是说先使用`index dive`计算`key2 ∈ (10, 1000)`的二级索引记录的数量,
再猜在这些二级索引记录中符合条件`key1 IN ('a', 'b', 'c')`和条件`common_field > 'xyz'`的二级索引记录的数量.

举了这么多例子,主要是想表达在以下2种情况下计算驱动表扇出值时,查询优化器需要靠猜测:

- 如果使用全表扫描的方式执行单表查询,那么计算驱动表扇出值时需要猜测满足搜索条件的记录到底有多少条
- 如果使用索引来执行单表查询,那么计算驱动表扇出值时需要猜测:除了满足形成索引扫描区间的搜索条件外,还满足其他搜索条件的记录有多少条

MySQL的设计者把这个"猜"的过程称为`Condition Filtering`(条件过滤).当然.这个过程可能会使用到索引,也可能使用到统计数据,
还有可能就是MySQL的设计者单纯地瞎猜.整个评估过程很复杂,这里就不细讲了.

注: 在MySQL5.7之前的版本中,查询优化器在计算驱动表扇出值时:

- 若使用全表扫描执行查询,则直接使用表中记录的数量作为扇出值;
- 若使用索引执行查询,则直接使用在扫描区间中的的记录条数作为扇出值

在MySQL5.7中,MySQL的设计者引入了这个`Condition Filtering`的功能,就是还要猜一猜剩余的那些搜索条件,能把驱动表中的记录再过滤多少条,
**其实本质上就是为了让成本估算更精确**.上文中所说的纯粹瞎猜是很不严谨的,MySQL的设计者将该过程称为启发式规则(heuristic).
