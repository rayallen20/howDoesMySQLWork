# 1. `mysql.server_cost`表

`server_cost`表记录了在`server`层进行的一些操作所对应的成本常数,具体内容如下:

```
mysql> SELECT * FROM mysql.server_cost;
+------------------------------+------------+---------------------+---------+---------------+
| cost_name                    | cost_value | last_update         | comment | default_value |
+------------------------------+------------+---------------------+---------+---------------+
| disk_temptable_create_cost   |       NULL | 2025-07-14 02:07:51 | NULL    |            20 |
| disk_temptable_row_cost      |       NULL | 2025-07-14 02:07:51 | NULL    |           0.5 |
| key_compare_cost             |       NULL | 2025-07-14 02:07:51 | NULL    |          0.05 |
| memory_temptable_create_cost |       NULL | 2025-07-14 02:07:51 | NULL    |             1 |
| memory_temptable_row_cost    |       NULL | 2025-07-14 02:07:51 | NULL    |           0.1 |
| row_evaluate_cost            |       NULL | 2025-07-14 02:07:51 | NULL    |           0.1 |
+------------------------------+------------+---------------------+---------+---------------+
6 rows in set (0.00 sec)
```

先看一下`server_cost`表中各个列的含义:

- `cost_name`: 表示成本常数的名称
- `cost_value`: 表示成本常数对应的值.若该列的值为NULL,则表示对应的成本常数会采用默认值
- `last_update`: 表示最后更新记录的时间
- `comment`: 注释
- `default_value`: 表示成本常数的默认值

从`server_cost`表中的内容可以看出,目前在server层的一些操作对应的成本常数有以下几种:

|             成本常数名称             | 默认值  |                                                                 描述                                                                  |
|:------------------------------:|:----:|:-----------------------------------------------------------------------------------------------------------------------------------:|
|  `disk_temptable_create_cost`  | 20.0 |                                              创建基于磁盘的临时表的成本.若增大该值,则会让优化器尽量少的创建基于磁盘的临时表                                               |
|   `disk_temptable_row_cost`    | 0.5  |                                          向基于磁盘的临时表写入或读取1条记录的成本.若增大该值,则会让优化器尽量少的创建基于磁盘的临时表                                           |
|       `key_compare_cost`       | 0.05 | 2条记录进行比较操作的成本,多用在排序操作中.若增大该值,则会提升`filesort`的成本,从而让优化器可能更倾向于使用索引(而不是`filesort`)完成排序.注意: 查询1条记录后与条件进行比较不叫"2条记录的比较",而是1条记录与1个或多个条件进行比较 |
| `memory_temptable_create_cost` | 1.0  |                                              创建基于内存的临时表的成本.若增大该值,则会让优化器尽量少的创建基于内存的临时表                                               |
|  `memory_temptable_row_cost`   | 0.1  |                                          向基于内存的临时表写入或读取1条记录的成本.若增大该值,则会让优化器尽量少的创建基于内存的临时表                                           |
|      `row_evaluate_cost`       | 0.1  |                                          读取并检测1条记录是否符合搜索条件的成本.增大该值可能让优化器更倾向于使用索引(而不是全表扫描)                                           |

注: 这里我使用的MySQL的版本为8.0.42,与MySQL5.X相比,各种成本常数发生了一些变化.

注: MySQL在执行诸如DISTINCT查询/分组查询/Union查询以及某些特殊条件下的排序查询时,MySQL都可能在内部先创建一个临时表,
使用这个临时表来辅助完成查询.比如针对包含DISTINCT子句的查询,则建立一个内部临时表,该临时表在需要去重的那些列上具有唯一性(带有UNIQUE索引).
这样直接把需要去重的记录插入到这个临时表中,插入完成之后的记录就是结果集了.在数据量大的情况下可能创建基于磁盘的临时表,
也就是为该临时表使用MyISAM/InnoDB等存储引擎.在数据量不大时可能创建基于内存的临时表,也就是使用Memory存储引擎.
关于更多临时表的细节这里不展开讲,只需要知道创建临时表和对这个临时表进行写入和读取的操作代价还是很高的即可.

这些成本常数在`server_cost`表中的初始值都是NULL,即优化器会使用它们的默认值来计算某个操作的成本.如果想修改某个成本常数的值的话,需要做2个步骤:

- 步骤1. 对感兴趣的成本常数做更新操作

    例如想把检测1条记录是否符合搜索条件的成本增大到0.4,那么就可以这样写更新语句:
    
    ```sql
    UPDATE mysql.server_cost
    SET cost_value = 0.4
    WHERE cost_name = 'row_evaluate_cost';
    ```

- 步骤2. 让系统重新加载`mysql.server_cost`表的值

    使用下边语句即可:
    
    ```sql
    FLUSH OPTIMIZER_COSTS;
    ```

当然,在修改完某个成本常数后想把它们再恢复成默认值,可以直接把`cost_value`的值设置为NULL,
再使用`FLUSH OPTIMIZER_COSTS`语句让系统重新加载`mysql.server_cost`表的值即可.
