# 4. 子查询语法的注意事项

- 子查询必须用小括号扩起来

    不扩起来的子查询是非法的,例如:
    
    ```
    mysql> SELECT 
        ->     SELECT m1
        ->     FROM t1;
    ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'SELECT m1
        FROM t1' at line 2
    ```

- 在 SELECT 子句中的子查询必须是标量子查询

    若子查询结果集中有多个列或者多个行,则都不允许放在SELECT子句中.例如:
    
    ```
    mysql> SELECT (
        ->     SELECT m1, n1
        ->     FROM t1
        -> );
    ERROR 1241 (21000): Operand should contain 1 column(s)
    ```

- 要想得到标量子查询或者行子查询,但又不能保证子查询的结果集只有1条记录时,应该使用`LIMIT 1`语句来限制记录数量

- 对于`[NOT] IN`/`ANY`/`SOME`/`ALL`子查询来说,子查询中不允许有LIMIT语句

    ```
    mysql> SELECT *
        -> FROM t1
        -> WHERE m1 IN (
        ->     SELECT *
        ->     FROM t2
        ->     LIMIT 2
        -> );
    ERROR 1235 (42000): This version of MySQL doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
    ```
    
    至于不合法的原因,只能说MySQL的设计者就是这么规定的.可能以后的版本会支持吧.
    正因为`[NOT] IN`/`ANY`/`SOME`/`ALL`子查询不支持`LIMIT`语句，所以在这些子查询中使用:
    
    - `ORDER BY`
    - `DISTINCT`
    - 没有聚合函数和`HAVING`子句的`GROUP BY`子句
    
    是没有意义的:

    - `ORDER BY`子句

        子查询的结果其实就相当于一个集合,在`[NOT] IN`/`ANY`/`SOME`/`ALL`子查询中,作为子查询结果的集合中的值,
        是否排序完全没有意义(因为不支持`LIMIT`语句).例如:
    
        ```
        mysql> SELECT *
            -> FROM t1
            -> WHERE m1 IN (
            ->     SELECT m2
            ->     FROM t2
            ->     ORDER BY m2
            -> );
        +------+------+
        | m1   | n1   |
        +------+------+
        |    2 | b    |
        |    3 | c    |
        +------+------+
        2 rows in set (0.00 sec)
        ```
    
        该语句中的`ORDER BY`子句完全没有任何意义:
    
        ```
        mysql> SELECT *
            -> FROM t1
            -> WHERE m1 IN (
            ->     SELECT m2 
            ->     FROM t2
            -> );
        +------+------+
        | m1   | n1   |
        +------+------+
        |    2 | b    |
        |    3 | c    |
        +------+------+
        2 rows in set (0.00 sec)
        ```
    
        简言之,假设IN子查询返回一个值列表: `[v1, v2, v3, ...]`,
        则`m1 IN (v1, v2, v3, ...)`与`m1 IN (v3, v2, v1, ...)`的结果是等价的.

    - `DISTINCT`子句

      子查询的结果其实就相当于一个集合,在`[NOT] IN`/`ANY`/`SOME`/`ALL`子查询中,作为子查询结果的集合中的值,
      是否去重也没有意义.例如:

        ```
        mysql> SELECT *
            -> FROM t1
            -> WHERE m1 IN (
            ->     SELECT DISTINCT m2
            ->     FROM t2
            -> );
        +------+------+
        | m1   | n1   |
        +------+------+
        |    2 | b    |
        |    3 | c    |
        +------+------+
        2 rows in set (0.00 sec)
        ```

        该语句中的`DISTINCT`子句完全没有任何意义:
    
        ```
        mysql> SELECT *
            -> FROM t1
            -> WHERE m1 IN (
            ->     SELECT m2 
            ->     FROM t2
            -> );
        +------+------+
        | m1   | n1   |
        +------+------+
        |    2 | b    |
        |    3 | c    |
        +------+------+
        2 rows in set (0.00 sec)
        ```
      
        简言之,假设IN子查询返回一个值列表: `[v1, v2, v2, v3, v3, ...]`,
        则`m1 IN (v1, v2, v2, v3, v3, ...)`与`m1 IN (v1, v2, v3, ...)`的结果是等价的.

    - 没有聚合函数和`HAVING`子句的`GROUP BY`子句

        没有聚合函数和`HAVING`子句的`GROUP BY`子句,就相当于`ORDER BY`子句 + `DISTINCT`子句,
        `ORDER BY`子句和`DISTINCT`子句在`[NOT] IN`/`ANY`/`SOME`/`ALL`子查询中都毫无意义,所以
        没有聚合函数和`HAVING`子句的`GROUP BY`子句在`[NOT] IN`/`ANY`/`SOME`/`ALL`子查询中也是毫无意义的.
        例如:

        ```
        mysql> SELECT *
            -> FROM t1 
            -> WHERE m1 IN (
            ->     SELECT m2
            ->     FROM t2
            ->     GROUP BY m2
            -> );
        +------+------+
        | m1   | n1   |
        +------+------+
        |    2 | b    |
        |    3 | c    |
        +------+------+
        2 rows in set (0.00 sec)
        ```

        该语句中的`GROUP BY`子句完全没有任何意义:
    
        ```
        mysql> SELECT *
            -> FROM t1
            -> WHERE m1 IN (
            ->     SELECT m2 
            ->     FROM t2
            -> );
        +------+------+
        | m1   | n1   |
        +------+------+
        |    2 | b    |
        |    3 | c    |
        +------+------+
        2 rows in set (0.00 sec)
        ```

    **这些没有意义的语句,查询优化器在一开始就把它们给干掉了**

- 不允许在一条语句中增删改某个表的记录时,同时还对该表进行子查询

    例如:
    
    ```
    mysql> DELETE
        -> FROM t1
        -> WHERE m1 < (
        ->     SELECT MAX(m1)
        ->     FROM t1
        -> );
    ERROR 1093 (HY000): You can't specify target table 't1' for update in FROM clause
    ```
