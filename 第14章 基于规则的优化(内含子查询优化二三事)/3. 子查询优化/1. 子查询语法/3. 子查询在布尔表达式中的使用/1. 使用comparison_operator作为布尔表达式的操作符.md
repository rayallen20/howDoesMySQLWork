# 1. 使用`comparison_operator`作为布尔表达式的操作符

- `comparison_operator`:即
  - `=`
  - `>`
  - `<`
  - `>=`
  - `<=`
  - `!=`(也可以写成`<>`)
  - `<=>`(安全等于)

这些操作符.

所以子查询组成的布尔表达式的格式如下:

```
操作数 comparison_operator (子查询)
```

这里的操作数可以是:

- 某个列名
- 一个常量
- 一个更复杂的表达式
- 另一个子查询

但是要注意: **这里的子查询只能是标量子查询或者行子查询,也就是说子查询的结果只能返回1个单一的值或者1条记录**.

例如:

```
mysql> SELECT *
    -> FROM t1
    -> WHERE m1 < (
    ->     SELECT MIN(m2)
    ->     FROM t2
    -> );
+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
+------+------+
1 row in set (0.00 sec)
```

道理很简单,这里WHERE子句中的条件是`m1 < (子查询)`,若该子查询是一个列子查询(当然这里只是假设,表示假设子查询返回了多行1列的意思),
那么从逻辑上就不合理了: `m1 < val1, val2..., valN`(假设子查询返回了N行1列的值),很明显逻辑就不通了.

或:

```
mysql> SELECT *
    -> FROM t1
    -> WHERE (m1, n1) = (
    ->     SELECT m2, n2
    ->     FROM t2
    ->     LIMIT 1
    -> );
+------+------+
| m1   | n1   |
+------+------+
|    2 | b    |
+------+------+
1 row in set (0.00 sec)
```

这里的道理同上.这里WHERE子句中的条件是`(m1, n1) = (子查询)`,若该子查询是一个表子查询(当然这里只是假设,表示假设子查询返回了多行2列的意思),
那么从逻辑上就不合理了: `(m1, n1) = (val1, val2), (val3, val4), ..., (valN, valM)`(假设子查询返回了N行2列的值),很明显逻辑就不通了.
假设搜索条件想表达的是`(m1, n1)`在结果集`(val1, val2), (val3, val4), ..., (valN, valM)`中,那么也应该使用IN操作符,而非`=`操作符.
