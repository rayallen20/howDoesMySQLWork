# 2. 相关子查询的执行方式

```sql
SELECT *
FROM s1 
WHERE key1 IN (
    SELECT common_field
    FROM s2
    WHERE s1.key2 = s2.key2
);
```

该查询语句中的子查询中出现了条件`s1.key2 = s2.key2`,这就意味着该子查询的执行依赖外层查询的值.直觉上认为该查询是的执行方式如下:

- 步骤1.

    从外层查询中获取1条记录,本例中也就是先从`s1`表中获取一条记录

- 步骤2.

    从步骤1获取的那条记录中,找出子查询中涉及到的值.
    本例中就是从`s1`表中获取的那条记录中找出`s1.key2`列的值,然后使用这个值执行子查询

- 步骤3.

    根据子查询的查询结果,检测外层查询WHERE子句的条件(即`WHERE key1 IN (步骤2的查询结果))`是否成立
    - 若成立,则把外层查询的那条记录(就是步骤1获取的那条记录)加入到结果集
    - 否则就丢弃

- 步骤4.
  
    重复执行步骤1,获取第2条外层查询中的记录,以此类推,直到外层查询中的所有记录都被查询完毕

观察这个步骤,它的伪代码大致如下:

```
for each s1Row in s1: {
    for each s2Row in t2 {
        if s1Row.key2 == s2Row.key2: {
            if s1Row.key1 in s2Row.common_field: {
                add s1Row to result set
            }
        }
    }
}
```

注意: 这个过程看起来有点像2表连接的过程

其实MySQL的设计者想了很多办法来优化子查询的执行.这些优化措施在大部分情况下其实挺有效的,但是有的时候也不灵.
后文详解各种不同类型的子查询具体是怎么执行的.

注: 后续关于MySQL优化子查询的执行方式的内容都是基于MySQL5.7版本的,之后的版本可能有更新的优化策略.
