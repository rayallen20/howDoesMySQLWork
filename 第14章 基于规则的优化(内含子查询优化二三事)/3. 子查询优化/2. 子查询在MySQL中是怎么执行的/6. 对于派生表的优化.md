# 6. 对于派生表的优化

再重复一次派生表的概念:

- 派生表: **在FROM子句中出现的子查询**

把子查询放在外层查询的FROM子句后面,则该子查询相当于一个派生表.例如:

```sql
SELECT *
FROM (
    SELECT id AS d_id, key3 AS d_key3
    FROM s2
    WHERE key1 = 'a'
) AS derived_s1
WHERE d_key3 = 'a';
```

子查询`( SELECT id AS d_id, key3 AS d_key3 FROM s2 WHERE key1 = 'a')`的结果就相当于一个派生表.
该表的名称为`derived_s1`,该表有2个列,分别是`d_id`和`d_key3`.

对于含有派生表的查询,MySQL提供了2种执行策略:

- 把派生表物化

    这是最容易想到的执行策略.可以将派生表的结果集写到一个内部的临时表中,然后把这个物化表当作普通表一样参与查询.
    当然,在对派生表进行物化时,MySQL的设计者使用了一种称为**延迟物化**的策略,即:**在查询中真正使用到派生表时才会去尝试物化派生表,
    而不是在执行查询之前就先把派生表物化**.例如下面这个含有派生表的查询:
    
    ```sql
    SELECT *
    FROM (
        SELECT *
        FROM s1
        WHERE key1 = 'a'
    ) AS derived_s1 INNER JOIN s2
    ON derived_s1.key1 = s2.key1
    WHERE s2.key2 = 1;
    ```

    若采用物化派生表的方式来执行该查询,则:

    - 执行时首先会到`s2`表中找出满足条件`s2.key2 = 1`的记录
    - 若找不到,则说明参与连接的`s2`表记录就是空的
    - 所以整个查询的结果集就是空的
    - 所以也就没有必要去物化查询中的派生表了

- 将派生表和外层的表合并,即:将查询重写为没有派生表的形式

    例如:
    
    ```sql
    SELECT *
    FROM (
        SELECT *
        FROM s1
        WHERE key1 = 'a'
    ) AS derived_s1;
    ```

    该查询本质上就是查找:`s1`表中满足条件`key1 = 'a'`的全部记录,所以和下面这个语句是等价的:
    
    ```sql
    SELECT *
    FROM s1
    WHERE key1 = 'a';
    ```

    对于一些稍微复杂的包含派生表的语句,例如:
    
    ```sql
    SELECT *
    FROM (
        SELECT *
        FROM s1
        WHERE key1 = 'a'
    ) AS derived_s1 INNER JOIN s2
    ON derived_s1.key1 = s2.key1
    WHERE s2.key2 = 1;
    ```

    可以将派生表与外层查询的表合并,然后将派生表中的搜索条件放到外层查询的搜索条件中:

    ```sql
    SELECT s1.*
    FROM s1 INNER JOIN s2
    ON s1.key1 = s2.key1
    WHERE
        s1.key1 = 'a'
    AND
        s2.key2 = 1;
    ```

    这样,通过将外层查询和派生表合并的方式成功的消除了派生表,也就意味着没有必要再**付出创建和访问临时表的成本了**.
    但是,并不是所有带有派生表的查询都能被成功的和外层查询合并,当派生表中有如下语句时,就无法与外层查询合并:

    - 聚合函数
      - 如`MAX()`/`MIN()`/`SUM()`
    - `DISTINCT`
    - `GROUP BY`
    - `HAVING`
    - `LIMIT`
    - `UNION`/`UNION ALL`
    - 派生表对应的子查询的SELECT子句中含有另一个子查询

    因为这些语句都需要扫全表才能得到派生表的结果集,所以无法将派生表和外层查询合并.说白了就是一旦出现这些语句,就意味着无法基于原表进行查询.

所以MySQL在执行带有派生表的查询时:

- 优先尝试把派生表和外层查询合并
- 若无法合并,则把派生表物化掉

然后执行查询.
