# 1. 不适用于半连接的情况

还有一些不能将子查询转换为半连接的情况,比较典型的有下面这几种:

- 外层查询的WHERE子句中,存在其他搜索条件,这些搜索条件使用OR操作符与IN子查询组成的布尔表达式连接起来

    例如:

    ```sql
    SELECT * FROM s1 
    WHERE key1 IN (
        SELECT common_field
        FROM s2
        WHERE key3 = 'a'
    )
    OR 
        key2 > 100;
    ```
    
    半连接的目的是为了将子查询转换为连接,从而提高查询性能.但是在这个例子中,因为外层查询有一个用OR连接的条件,所以如果把子查询转换为如下:
    
    ```sql
    SELECT s1.*
    FROM s1 SEMI JOIN s2
    ON s1.key1 = s2.common_field
    WHERE s2.key3 = 'a'
    OR s1.key2 > 100;
    ```
    
    很明显这2个查询语句的结果集是不同的:

    ```
    mysql> SELECT * FROM single_table AS s1
        -> WHERE key1 IN (
        -> SELECT common_field
        -> FROM single_table2 AS s2
        -> WHERE key3 = 'a'
        -> )
        -> OR
        -> key2 > 100;
    +-------+----------+-------+----------+-----------+-----------+-----------+--------------+
    | id    | key1     | key2  | key3     | key_part1 | key_part2 | key_part3 | common_field |
    +-------+----------+-------+----------+-----------+-----------+-----------+--------------+
    |     1 | 5RHJv668 |     1 | sL4fVbJj | Wf7Paj    | kAJER7    | ghHhTH    | N0smVSd6     |
    |     2 | trpkKXbS |     2 | EhhGOeK0 | cvg4CU    | kBpKeS    | wdhM6p    | jZAaw52P     |
    |     3 | kYV6idfm |     3 | 1j8d8gTk | icirSL    | 4ZNdmc    | znYyqN    | UatkkBtn     |
    |   101 | vDOJxTlj |   101 | vVHjf6t6 | Q28WDc    | qucBxI    | 29KxBD    | 3N7lPMEt     |
    |   102 | hCE9Pwm1 |   102 | X5yEmnjt | ny4Iv2    | o0eh9X    | cSBQhh    | wozYV1Hm     |
    ...
    |  9999 | GkK8nisc |  9999 | i6hjuNzJ | OxXSWO    | zktnN8    | E47r2m    | W9RIQ5Yf     |
    | 10000 | VCaubN3D | 10000 | lCRMTOKR | 5NUB4p    | eROHXg    | O5we0s    | iy8Diqig     |
    +-------+----------+-------+----------+-----------+-----------+-----------+--------------+
    9903 rows in set (0.01 sec)
    ```

    该查询语句查询范围有2个:

    - 子查询的结果集
      - 即`SELECT common_field FROM s2 WHERE key3 = 'a'`的结果集
    - `s1`表全表
      - 因为条件`OR s1.key2 > 100`是针对`s1`表的,而非针对子查询的结果集的

    而如果改写为:
    
    ```sql
    SELECT s1.*
    FROM s1 SEMI JOIN s2
    ON s1.key1 = s2.common_field
    WHERE s2.key3 = 'a'
    OR s1.key2 > 100;
    ```
    
    这里由于`SEMI JOIN`跑步起来,我换成`INNER JOIN`来代替,则查询结果为:

    ```
    mysql> SELECT s1.*
        -> FROM single_table AS s1 INNER JOIN single_table2 AS s2
        -> ON s1.key1 = s2.common_field
        -> WHERE s2.key3 = 'a'
        -> OR s1.key2 > 100;
    +----+----------+------+----------+-----------+-----------+-----------+--------------+
    | id | key1     | key2 | key3     | key_part1 | key_part2 | key_part3 | common_field |
    +----+----------+------+----------+-----------+-----------+-----------+--------------+
    |  1 | 5RHJv668 |    1 | sL4fVbJj | Wf7Paj    | kAJER7    | ghHhTH    | N0smVSd6     |
    |  1 | 5RHJv668 |    1 | sL4fVbJj | Wf7Paj    | kAJER7    | ghHhTH    | N0smVSd6     |
    |  2 | trpkKXbS |    2 | EhhGOeK0 | cvg4CU    | kBpKeS    | wdhM6p    | jZAaw52P     |
    |  2 | trpkKXbS |    2 | EhhGOeK0 | cvg4CU    | kBpKeS    | wdhM6p    | jZAaw52P     |
    |  3 | kYV6idfm |    3 | 1j8d8gTk | icirSL    | 4ZNdmc    | znYyqN    | UatkkBtn     |
    |  3 | kYV6idfm |    3 | 1j8d8gTk | icirSL    | 4ZNdmc    | znYyqN    | UatkkBtn     |
    +----+----------+------+----------+-----------+-----------+-----------+--------------+
    6 rows in set (0.02 sec)
    ```

    该查询语句查询范围有1个:

    - 子查询的结果集
      - 即`SELECT common_field FROM s2 WHERE key3 = 'a'`的结果集

- 使用`NOT IN`而不是`IN`的情况

    例如:
    
    ```sql
    SELECT * FROM s1 
    WHERE key1 NOT IN (
        SELECT common_field
        FROM s2
        WHERE key3 = 'a'
    );
    ```
    
    半连接的目的是为了: 在子查询的结果集中检测到只要有1条记录满足匹配条件就不再检查子查询的结果集.
    而`NOT IN`的逻辑是: 外层的行必须对比子查询的所有结果都不相等(且子查询结果集中不能包含NULL,否则返回结果为UNKNOWN),才能判定`NOT IN`为TRUE.
    `NOT IN`的逻辑与半连接的逻辑不一致,所以不能将`NOT IN`子查询转换为半连接.

- 位于SELECT子句中的IN子查询

    例如:
    
    ```sql
    SELECT key1 IN (
        SELECT common_field
        FROM s2
        WHERE key3 = 'a'
    ) FROM s1 ;
    ```
    
    半连接的核心特征:

    - 子查询的结果用于判断外层行是否保留(过滤条件)
    - 一旦找到匹配行,外层行就保留,后面不再检查(早停)

    而本例中出现在SELECT子句中的IN子查询,并不是用来判断外层行是否保留的,而是用来计算一个布尔值(即`key1 IN (...)`)的.
    因此,不能将该子查询转换为半连接.

- 子查询中包含`GROUP BY`/`HAVING`/聚合函数的情况

    例如:

    ```sql
    SELECT *
    FROM s1 
    WHERE key2 IN (
        SELECT COUNT(*)
        FROM s2
        GROUP BY key1
    );
    ```

    本例中子查询的部分为:
    
    ```sql
    SELECT COUNT(*)
    FROM s2
    GROUP BY key1;
    ```
    
    该子查询的特点:

    1. 子查询结果列不是表的原始列,而是聚合结果
    2. `GROUP BY`会先把`s2`按`key1`分组,然后对每组做聚合,得到一个新的结果集
    3. 这个结果集必须先全部计算出来,才能去判断外层查询的`key2`是否存在于结果集中

    这些特点与半连接的匹配方式是冲突的:

    - 半连接希望在匹配时就能逐步生成子查询的结果
    - 但该子查询的聚合结果要等到整个分组计算完成后才能确定,没法边匹配边生成

    因此,不能将该子查询转换为半连接.

- 子查询中包含UNION的情况

    例如:
    
    ```sql
    SELECT * FROM s1 WHERE key1 IN (
        SELECT common_field FROM s2 WHERE key3 = 'a' 
        UNION
        SELECT common_field FROM s2 WHERE key3 = 'b'
    );
    ```
    
    本例中子查询的部分为:
    
    ```sql
    SELECT common_field FROM s2 WHERE key3 = 'a' 
    UNION
    SELECT common_field FROM s2 WHERE key3 = 'b'
    ```
    
    该子查询的执行特点:

    1. `UNION`会合并多个查询块的结果集,并进行去重(除非使用的是`UNION ALL`连接的)
    2. 去重通常意味着需要先收集所有分支的输出,再排序或构建哈希表来去重
    3. 只有得到完整去重后的集合,才能判断外层查询值是否存在于结果集中

    这些特点与半连接的匹配方式是冲突的:

    - 半连接希望在匹配时就能逐步生成子查询的结果
    - 但该子查询的结果需要等到多个子查询分支合并后才能保证结果集正确(尤其是去重时)
      - 在合并完成前,无法确保某个值最终会或不会出现在结果集中
      - 这就导致该子查询的粗阿勋结果要等到整个合并计算完成后才能确定,和使用`GROUP BY`/`HAVING`/聚合函数的情况一样,无法边匹配边生成结果
