# 2. 对不能使用半连接查询的子查询优化

MySQL仍然有一些策略来优化不能转为`semi-join`查询的子查询:

- 对于不相关子查询来说,可以尝试把子查询物化之后再参与查询

    例如:
    
    ```sql
    SELECT *
    FROM s1 
    WHERE key1 NOT IN (
        SELECT common_field
        FROM s2
        WHERE key3 = 'a'
    );
    ```
    
    先将子查询物化,然后再判断`key1`是否在物化表的结果集中.这样可以加快查询执行的速度.
    
    注: 这里将子查询物化之后不能转为和外层查询的表的连接.只能是先扫描s1表,然后对s1表的每条记录,判断该记录的`key1`值是否在物化表中.

- 无论子查询是相关的还是不相关的,都可以把IN子查询尝试转为EXISTS子查询

其实对于任意一个IN子查询来说,都可以被转为EXISTS子查询,通用的转换示例如下:

```
outer_expr IN (SELECT inner_expr FROM ... WHERE subquery_where)
```

可以被转换为:

```
EXISTS (SELECT inner_expr FROM ... WHERE subquery_where AND outer_expr = inner_expr)
```

这个过程中有一些特殊情况,比如在`outer_expr`或者`inner_expr`值为NULL的情况下就比较特殊.
因为有NULL值作为操作数的表达式结果往往是NULL.例如:

```
mysql> SELECT NULL IN (1, 2, 3);
+-------------------+
| NULL IN (1, 2, 3) |
+-------------------+
|              NULL |
+-------------------+
1 row in set (0.00 sec)
```

```
mysql> SELECT 1 IN (1, 2, 3);
+----------------+
| 1 IN (1, 2, 3) |
+----------------+
|              1 |
+----------------+
1 row in set (0.00 sec)
```

```
mysql> SELECT NULL IN (NULL);
+----------------+
| NULL IN (NULL) |
+----------------+
|           NULL |
+----------------+
1 row in set (0.00 sec)
```

而EXISTS子查询的结果肯定是TRUE或FALSE:

```
mysql> SELECT EXISTS (SELECT 1 FROM single_table WHERE NULL = 1);
+----------------------------------------------------+
| EXISTS (SELECT 1 FROM single_table WHERE NULL = 1) |
+----------------------------------------------------+
|                                                  0 |
+----------------------------------------------------+
1 row in set (0.00 sec)
```

```
mysql> SELECT EXISTS (SELECT 1 FROM single_table WHERE 1 = NULL);
+----------------------------------------------------+
| EXISTS (SELECT 1 FROM single_table WHERE 1 = NULL) |
+----------------------------------------------------+
|                                                  0 |
+----------------------------------------------------+
1 row in set (0.00 sec)
```

```
mysql> SELECT EXISTS (SELECT 1 FROM single_table WHERE NULL = NULL);
+-------------------------------------------------------+
| EXISTS (SELECT 1 FROM single_table WHERE NULL = NULL) |
+-------------------------------------------------------+
|                                                     0 |
+-------------------------------------------------------+
1 row in set (0.00 sec)
```

从上述例子中可以看出,当有NULL值作为操作数时,IN子查询的结果可能是NULL,而EXISTS子查询的结果是TRUE或FALSE.

好在,大部分使用IN子查询的场景是把它放在WHERE或者ON子句中,而WHERE子句和ON子句是不区分NULL和FALSE的.例如:

```
mysql> SELECT 1 FROM single_table WHERE NULL;
Empty set (0.00 sec)
```

```
mysql> SELECT 1 FROM single_table WHERE FALSE;
Empty set (0.00 sec)
```

可以看到,表达式`WHERE NULL`和表达式`WHERE FALSE`的结果是相同的.

所以只要IN子查询是放在WHERE子句或ON子句中,那么IN到EXISTS的转换就没问题.可是为什么要转换呢?
这是因为不转换的话可能用不到索引.例如:

```sql
SELECT * FROM s1
WHERE key1 IN (
    SELECT key3
    FROM s2
    WHERE s1.common_field = s2.common_field
) 
OR key2 > 1000;
```

该查询中的子查询是一个相关子查询,且子查询执行的时候不能使用到索引(因为`common_field`列上没有索引).
但是将它转为EXISTS子查询后却可以使用到索引:

```sql
SELECT *
FROM s1
WHERE EXISTS (
    SELECT 1
    FROM s2
    WHERE
        s1.common_field = s2.common_field
    AND
        s2.key3 = s1.key1
)
OR key2 > 1000;
```

可以看到,转为EXISTS子查询时就可以使用到`s2`表的索引`idx_key3`了.

注意: 若IN子查询不满足转换为半连接的条件,又不能转换为物化表,或者转换为物化表的成本太大,则该IN子查询就会被转换为EXISTS查询.

注:  在MySQL5.5以及之前的版本中,没有引入半连接和物化的方式优化子查询,查询优化器都会把IN子查询转换为EXISTS子查询.
于是很多人就有疑惑: 明明写的是一个不相关子查询,为什么要按照执行相关子查询的方式来执行呢?

所以如果使用的是MySQL5.5或更早的版本,将包含子查询的语句手动转为连接查询可能会起到比较好的效果.
不过自从MySQL5.6开始,加入了越来越多的自动优化子查询的功能,没有什么特殊情况的话,建议让优化器自行优化即可.
