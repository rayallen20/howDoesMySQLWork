# 1. 物化表的提出

对于不相关的IN子查询,例如:

```sql
SELECT *
FROM s1 
WHERE key1 IN (
    SELECT common_field
    FROM s2
    WHERE key3 = 'a'
);
```

直觉上认为,这种不相关IN子查询和不相关标量子查询或不相关行子查询是完全相同的,都是把外层查询和子查询当作2个独立的单表查询来对待.
但是,MySQL的设计者为了优化IN子查询想了很多办法(因为IN子查询是最常用的子查询类型),所以整个执行过程并不像直觉上认为的的那么简单.

对于不相关IN子查询来说,若子查询的结果集中的记录条数很少,那么把子查询和外层查询分别看成2个单独的单表查询效率还是很高的.
但是,如果单独执行子查询后的结果集太多的话,就会出现:结果集太多,可能内存中放不下的问题.

注: 对于`expr IN (arg1, arg2, ...)`这种形式的IN子句来说,IN子句中的若干参数首先会被排序,若在执行查询时,不能利用索引将IN子句
划分成若干个扫描区间,则会对已排好序的IN子句参数进行二分查找,以加快计算IN表达式的效率.

于是MySQL的设计者想了一个办法: **不直接将不相关子查询的结果集当作外层查询的参数,而是将该结果集写入一个临时表中**

在将结果集写入临时表时,有2点注意事项:

- 该临时表的列就是子查询结果集中的列
- 写入临时表的记录会被去重
  - **因为该子查询是出现在IN子句中,所以子查询的结果集为`[v1, v1, v2, v3]`的效果和子查询的结果集为`[v1, v2, v3]`是一样的**
  - 所以这里可以对结果集进行去重处理

IN语句用于判断某个操作数是否存在于某个集合中,集合中的值是否重复对整个IN语句的结果没有任何影响.
因此在将结果集写入临时表时,对记录进行去重可以让临时表变得更小,从而节省空间.

注: 

临时表中对记录做去重操作的做法: 临时表也是个表,只要为表中记录的所有列建立主键或者唯一索引即可.
若子查询的结果集有多个列(也就是为其建立的临时表有多个列),则为临时表的所有列建立联合主键或者联合唯一索引即可.

一般情况下,子查询结果集不会大的离谱.所以会为它建立基于内存的使用MEMORY存储引擎的临时表,且会为该表建立哈希索引.

注: IN语句的本质就是判断某个操作数是否存在于某个集合中.若集合中的数据建立了哈希索引,则这个匹配的过程会非常快.

在MySQL中,MEMORY存储引擎(以前叫HEAP引擎)默认会使用哈希索引(HASH index),这是和InnoDB/MyISAM默认的B+树索引最大的不同之一.

哈希索引是一种基于哈希表(hash table)实现的索引结构,它通过对索引列的值计算哈希值(hash value),然后根据哈希值直接定位到对应的存储位置.

特点:

- 访问速度非常快(`O(1)`平均复杂度)
- 适合等值匹配查询
- 不适合范围查询或排序

工作原理(以MEMORY表为例):

1. 插入一行数据,MEMORY引擎会对索引列(如`id`)的值计算一个哈希值
2. 哈希值会映射到内存中一个哈希桶(bucket)
3. 若多个值映射到同1个桶,就会形成1个链表(哈希冲突)
4. 查询时,对查询值计算哈希值,直接到对应桶中查找匹配的行

图示大致如下:

```
索引列值 → 哈希函数 → 桶编号 → 桶中存放的行指针列表
```

例如:

```
Key: 101 → hash(key) → 桶 3 → 指向行 #5
Key: 102 → hash(key) → 桶 7 → 指向行 #8
Key: 202 → hash(key) → 桶 3（冲突）→ 链表存放行 #5, #12
```

MEMORY表常用于临时中间结果集(例如派生表/`GROUP BY`结果/去重等),这些操作很多是等值匹配(哈希查找性能最好).

若子查询的结果集非常大,超过了系统变量`tmp_table_size`和系统变量`max_heap_table_size`中二者较小的那个值,则临时表会转而使用
基于磁盘的存储引擎来保存结果集中的记录,索引类型也对应转变为B+树索引.

- `tmp_table_size`: 用于限制服务器中**内存临时表**(MEMORY存储引擎的临时表)的最大大小.默认16MB
  - 该变量不会作用在用户创建的MEMORY表上,只作用在MySQL内部创建的内存临时表上

```
mysql> SHOW VARIABLES LIKE 'tmp_table_size';
+----------------+----------+
| Variable_name  | Value    |
+----------------+----------+
| tmp_table_size | 16777216 |
+----------------+----------+
1 row in set (0.04 sec)
```

- `max_heap_table_size`: 用于限制服务器中**内存表**(MEMORY存储引擎的表)的最大大小.默认16MB
  - 该变量作用既在用户创建的MEMORY表上,也作用在MySQL内部创建的内存临时表上
  - 即: 该变量限制所有MEMORY存储引擎的表的最大大小

```
mysql> SHOW VARIABLES LIKE 'max_heap_table_size';
+---------------------+----------+
| Variable_name       | Value    |
+---------------------+----------+
| max_heap_table_size | 16777216 |
+---------------------+----------+
1 row in set (0.00 sec)
```

MySQL的设计者把**这个"将子查询结果集中的记录保存到临时表的过程"称为物化(Materialize)**.
注意: 物化并不只是出现在IN子句的不相关子查询中,而它是一种通用的中间结果缓存技术
方便起见,就把那个**存储子查询结果集的临时表称为物化表**.正因为物化表中的记录都建立了索引(基于内存的物化表有哈希索引,基于磁盘的有B+树索引),
通过索引执行IN语句判断某个操作数是否存在于子查询结果集中时,速度会变得非常快,从而提升了子查询语句的性能.
