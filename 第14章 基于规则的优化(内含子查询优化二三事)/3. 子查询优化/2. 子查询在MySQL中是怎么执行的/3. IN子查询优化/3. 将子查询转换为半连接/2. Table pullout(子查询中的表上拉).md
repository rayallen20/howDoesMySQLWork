# 2. Table pullout(子查询中的表上拉)

**当子查询的查询列表处只有主键或唯一索引列时**,可以直接把子查询中的表上拉到外层查询的FROM子句中,
并把子查询中的搜索条件合并到外层查询的搜索条件中.例如:

```sql
SELECT *
FROM s1
WHERE key2 IN (
    SELECT key2
    FROM s2
    WHERE key3 = 'a'
);
```

由于`key2`列是`s2`表的唯一二级索引列,所以可以直接把`s2`表上拉到外层查询的FROM子句中,
并且把子查询中的搜索条件合并到外层查询的搜索条件中,上拉之后的查询如下:

```sql
SELECT s1.*
FROM s1 INNER JOIN s2
ON s1.key2 = s2.key2
WHERE s2.key3 = 'a';
```

这个场景下可以把IN子查询改写成INNER JOIN.其核心原因在于:**子查询中出现在查询列表位置上的列,
天然地在`s2`表中具有唯一性(因为`key2`是`s2`表的唯一二级索引列),因此在搜索条件`s1.key2 = s2.key2`下,
压根不会出现1条`s1`表中的记录对应多条`s2`表中的记录的情况**.即: 对于同一条`s1`表中的记录,
不可能在`s2`表中找到2条以上的符合条件`s1.key2 = s2.key2`的记录,自然不会出现前文说的情况3了.

抽象层级再高一点的话说就是: 若在IN子查询的查询列表中出现的列具有唯一性(即这些列都是主键或唯一索引列时),则该IN子查询满足`semi-join`的条件
