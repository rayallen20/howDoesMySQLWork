# 1. 前言

虽然将子查询进行物化之后再执行查询都会有建立临时表的成本,但是也让优化器能够更准确的评估执行查询的成本,更好的安排表的连接顺序.
MySQL的设计者继续想: 能不能不进行物化操作,直接把子查询转换为连接呢?

重新审视一下之前的查询语句:

```sql
SELECT *
FROM s1 
WHERE key1 IN (
    SELECT common_field
    FROM s2
    WHERE key3 = 'a'
);
```

可以把该查询理解成: 

- 对于`s1`表中的某条记录,若能在`s2`表(准确的说是执行完`WHERE s2.key3 = 'a'`之后的结果集)中找到:
  - 1条或多条符合条件`s1.key1 = s2.common_field`的记录
  - 则该条`s1`表的记录就会被加入到最终的结果集中

这个过程其实与把`s1`和`s2`两个表连接起来的效果很像:

```sql
SELECT s1.*
FROM s1 INNER JOIN s2 
ON s1.key1 = s2.common_field 
WHERE s2.key3 = 'a';
```

只不过不能保证对于`s1`表的某条记录来说,在`s2`表(准确的说是执行完`WHERE s2.key3 = 'a'`之后的结果集)中,
有多少条记录满足条件`s1.key1 = s2.common_field`.
注意: 这个使用`INNER JOIN`的查询语句,与之前的使用`IN`子查询的查询语句,在结果集上是不同的:

- 在`IN`子查询的查询语句的结果集中,满足条件`s1.key1 = s2.common_field`(这里假设已经执行完`WHERE s2.key3 = 'a'`了)的`s1`表的记录,只会出现1次
- 而在使用`INNER JOIN`的查询语句的结果集中,满足条件`s1.key1 = s2.common_field`(这里假设已经执行完`WHERE s2.key3 = 'a'`了)的`s1`表的记录
  - 该记录出现的次数为: 满足条件`s1.key1 = s2.common_field`的`s2`表的记录的数量

实际演示一下:

```
mysql> SELECT *
    -> FROM single_table AS s1 
    -> WHERE key1 IN (
    -> SELECT common_field
    -> FROM single_table2 AS s2 
    -> WHERE key3 = 'a'
    -> );
+----+----------+------+----------+-----------+-----------+-----------+--------------+
| id | key1     | key2 | key3     | key_part1 | key_part2 | key_part3 | common_field |
+----+----------+------+----------+-----------+-----------+-----------+--------------+
|  1 | 5RHJv668 |    1 | sL4fVbJj | Wf7Paj    | kAJER7    | ghHhTH    | N0smVSd6     |
|  2 | trpkKXbS |    2 | EhhGOeK0 | cvg4CU    | kBpKeS    | wdhM6p    | jZAaw52P     |
|  3 | kYV6idfm |    3 | 1j8d8gTk | icirSL    | 4ZNdmc    | znYyqN    | UatkkBtn     |
+----+----------+------+----------+-----------+-----------+-----------+--------------+
3 rows in set (0.04 sec)
```

```
mysql> SELECT s1.*
    -> FROM single_table AS s1 INNER JOIN single_table2 AS s2
    -> ON s1.key1 = s2.common_field
    -> WHERE s2.key3 = 'a';
+----+----------+------+----------+-----------+-----------+-----------+--------------+
| id | key1     | key2 | key3     | key_part1 | key_part2 | key_part3 | common_field |
+----+----------+------+----------+-----------+-----------+-----------+--------------+
|  1 | 5RHJv668 |    1 | sL4fVbJj | Wf7Paj    | kAJER7    | ghHhTH    | N0smVSd6     |
|  1 | 5RHJv668 |    1 | sL4fVbJj | Wf7Paj    | kAJER7    | ghHhTH    | N0smVSd6     |
|  2 | trpkKXbS |    2 | EhhGOeK0 | cvg4CU    | kBpKeS    | wdhM6p    | jZAaw52P     |
|  2 | trpkKXbS |    2 | EhhGOeK0 | cvg4CU    | kBpKeS    | wdhM6p    | jZAaw52P     |
|  3 | kYV6idfm |    3 | 1j8d8gTk | icirSL    | 4ZNdmc    | znYyqN    | UatkkBtn     |
|  3 | kYV6idfm |    3 | 1j8d8gTk | icirSL    | 4ZNdmc    | znYyqN    | UatkkBtn     |
+----+----------+------+----------+-----------+-----------+-----------+--------------+
6 rows in set (0.00 sec)
```

可以看到,**将IN子查询转换为INNER JOIN之后,结果集的行数变多了**.

注: 这里是我按照这个查询,改掉了一些随机生成数据的字段值,才能查出来数据的.

因此,需要分3种情况讨论:

- 情况1:

    对于`s1`表的某条记录来说,`s2`表中**没有任何记录**满足条件`s1.key1 = s2.common_field`,
    则该记录必然不会加入到最后的结果集.

- 情况2:

    对于`s1`表的某条记录来说,`s2`表中**有且只有1条记录**满足条件`s1.key1 = s2.common_field`,
    则该记录会加入到最后的结果集.

- 情况3:

    对于`s1`表的某条记录来说,`s2`表中**至少有2条记录**满足条件`s1.key1 = s2.common_field`,
    则该记录会加入到最后的结果集,并且会出现**多次**(出现的次数为满足条件`s1.key1 = s2.common_field`的`s2`表的记录的数量).

对于`s1`表的某条记录来说,由于查询语句只关心`s2`表中是否存在记录满足条件`s1.key1 = s2.common_field`,
而不关心具体有多少条记录与之匹配;又因为有情况3的存在,因此IN子查询和两表连接之间并不完全等价.
但是将子查询转换为连接又确实可以充分发挥优化器的作用,所以MySQL的设计者在这里提出了一个新的概念:半连接(`semi-join`).
将`s1`表和`s2`表进行半连接即为: **对于`s1`表的某条记录来说,只关心在`s2`表中是否存在与之匹配的记录,而不关心具体有多少条记录与之匹配,
最终的结果集中只保留`s1`表的记录**.假设MySQL内部是按照下面这样来改写前面的IN子查询的:

```sql
SELECT s1.*
FROM s1 SEMI JOIN s2
ON s1.key1 = s2.common_field
WHERE key3 = 'a';
```

所谓半连接,其语义为: 外层的行只要在子查询结果中找到至少1条记录匹配就满足条件.
一旦匹配,子查询结果中剩下的记录就不需要检查了(所以叫"半连接":只需要连接一半,不需要返回所有匹配行).
这种语义比较适合转成`JOIN + 去重`的逻辑.

本质上讲,半连接是一种**行存在性检查**.换言之,半连接优化是专门为**行过滤(WHERE/ON)场景**设计的.

半连接的核心特征:

- 子查询的结果用于判断外层行是否保留(过滤条件)
- 一旦找到匹配行,外层行就保留,后面不再检查(早停,Early Exit)

而早停就意味着半连接希望在匹配时就能逐步生成子查询的结果.所谓"在匹配时就能逐步生成子查询的结果",
其实是描述了**半连接(`semi-join`)在执行上的一种"流式(streaming)"特性**:它并不需要**先完整算出子查询的结果集**,
而是**在扫描子查询表的过程中,一边生成结果一边去匹配外层行**,匹配成功就可以提前结束(Early Exit).

而所谓"逐步生成",意思是指:

- 子查询的结果不是一次性完整产出
- 而是外层行驱动下的**按需生成**,需要匹配时才从子查询的行源里取数据
- 因为匹配过程是流式的,所以内存压力小,还能利用索引高效跳转

注: 半连接(`semi-join`)和物化(`materialization`)在MySQL优化器里基本是2条互斥的执行路径,同一个子查询不会同时既走半连接又走物化.
这里澄清一下二者的区别:

普通物化(`Materialization for subquery`)指的是:

1. 子查询无法改写成半连接(比如子查询中存在`GROUP BY`/`UNION`/聚合函数等)
2. 先全量执行子查询,把执行结果存进一个临时表(物化表)
3. 外层查询直接用这个临时表做查找(通常带唯一索引或哈希表)

**这种情况下子查询就不再是半连接,而是一个独立表源(derived table)**.

半连接(`semi-join`)指的是:

1. **是一种重写IN/EXISTS子查询的策略**,把IN/EXISTS子查询转换成外层查询和子查询表的连接(JOIN),然后选择不同的执行方式
2. 半连接的执行策略中可能也会使用到一些临时表,但是这些表不会成为独立表源,只是作为半连接执行过程中的"候选值集合缓存"

本质上讲,物化是**先全量计算,再匹配**,不能提前结束扫描子查询.

而半连接把子查询"拉"进外层查询,形成类似`JOIN`的执行:

- 外层行和子查询表是**同时扫描,逐步匹配**的
- 只要在子查询中找到至少1行匹配,就能立即判定该外层行满足条件,然后停止继续执行子查询(Early Exit)

这种模式的关键在于: **子查询的结果不必全算出来**,只需要找到和当前外层行匹配的那几条(甚至只要第1条)就够了.

注: `semi-join`只是在MySQL内部采用的一种执行子查询的方式.MySQL并没有提供面向用户的`semi-join`语法.
这里只是想说明上边的IN子查询在MySQL内部会被转换为类似该语句的半连接.

概念是有了,怎么实现这种半连接呢?MySQL的设计者准备了好几种办法.
