# 6. FirstMatch(首次匹配)

`FirstMatch`是一种最原始的半连接执行方式,它和直觉上认为的相关子查询的执行方式是完全相同的:

- 步骤1.

    取1条外层查询的中的记录

- 步骤2.

    到子查询的表中寻找符合匹配条件的记录

- 步骤3.

    - 若找到1条符合条件的记录,则将该外层查询的记录放入最终的结果集,**并停止查找更多匹配的记录**
      - 注意: 这个步骤的过程和EXISTS子查询的执行方式是相同的
      - EXISTS子查询在实现上会做短路优化(`short-circuit evaluation`),即:一旦子查询找到第1行,就立即返回TRUE,不再继续扫描
    - 若找不到,则把该外层查询的记录丢弃掉

- 步骤4.

    取下一条外层查询中的记录,重复上边的过程,直到外层查询的记录全部处理完毕

对于某些使用IN语句的相关子查询,例如:

```sql
SELECT *
FROM s1 
WHERE key1 IN (
    SELECT common_field
    FROM s2
    WHERE s1.key3 = s2.key3
);
```

就可以转换为半连接查询:

```sql
SELECT s1.*
FROM s1 SEMI JOIN s2
ON 
    s1.key1 = s2.common_field
AND
    s1.key3 = s2.key3;
```

注: 连接条件ON子句也是可以有多个连接条件的

然后就可以使用前面介绍过的`Duplicate Weedout`/`Loose Scan`/`FirstMatch`等半连接执行策略来执行查询
(注意针对相关子查询无法使用`Semi-join Materialization`连接策略).当然,若子查询的查询列表处只有主键或者唯一二级索引列,
还可以直接使用`Table pullout`的策略来执行查询.
但是需要注意的是: **由于相关子查询并不是一个独立的查询,所以不能转换为物化表来执行查询**.因此,无法使用`Semi-join Materialization`连接策略.
