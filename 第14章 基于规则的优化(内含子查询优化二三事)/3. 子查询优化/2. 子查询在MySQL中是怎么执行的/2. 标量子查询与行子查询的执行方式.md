# 2. 标量子查询与行子查询的执行方式

在以下2个场景中,经常使用到标量子查询或者行子查询:

- 在SELECT子句中
    
    前边说过,在查询列表中的子查询必须是标量子查询 

- 子查询使用`=`/`>`/`<`/`>=`/`<=`/`!=`(也可以写成`<>`)/`<=>`(安全等于)/等操作符和某个操作数组成一个布尔表达式
    
    这样的子查询必须是标量子查询或者行子查询.可以想象,`n = (子查询)`这样的语句,如果子查询返回多行,就会报错.
    因为`n`只能是1个值,而不是多个值;同理,`(m, n) = (子查询)`这样的语句,如果子查询返回多行,也会报错.

- 不相关标量子查询或不相关行子查询

    在上述2种场景中的不相关标量子查询或不相关行子查询,它们的执行方式很简单.例如:
    
    ```sql
    SELECT *
    FROM s1 
    WHERE key1 = (
        SELECT common_field
        FROM s2
        WHERE key3 = 'a'
        LIMIT 1
    );
    ```
    
    它的执行方式和直觉上认为的一样:

    - 步骤1.

        先单独执行子查询`(SELECT common_field FROM s2 WHERE key3 = 'a' LIMIT 1)`

    - 步骤2.

        再将步骤1中子查询得到的结果,当作外层查询的参数,再执行外层查询`SELECT * FROM s1 WHERE key1 = (步骤1的结果)`

    即: **对于包含不相关标量子查询和不相关行子查询的查询语句,MySQL会分别独立执行外层查询和子查询,当作2个单表查询即可**

- 相关标量子查询或相关行子查询

例如:

```sql
SELECT *
FROM s1
WHERE key1 = (
    SELECT common_field
    FROM s2
    WHERE s1.key3 = s2.key3
    LIMIT 1
);
```

它的执行方式也和直觉上认为的一样:

- 步骤1.

    从外层查询中获取1条记录,本例中也就是先从`s1`表中获取一条记录

- 步骤2.

    从步骤1获取的那条记录中,找出子查询中涉及到的值.
    本例中就是从`s1`表中获取的那条记录中找出`s1.key3`列的值,然后使用这个值执行子查询

- 步骤3.

    根据子查询的查询结果,检测外层查询WHERE子句的条件(即`WHERE key1 = (步骤2的查询结果))`是否成立
    - 若成立,则把外层查询的那条记录(就是步骤1获取的那条记录)加入到结果集
    - 否则就丢弃

- 步骤4.

    重复执行步骤1,获取第2条外层查询中的记录,以此类推,直到外层查询中的所有记录都被查询完毕

观察这个步骤,它的伪代码大致如下:

```
for each s1Row in s1: {
    for each s2Row in t2 {
        if s1Row.key3 == s2Row.key3: {
            break
        }
    }
    
    if s1Row.key1 == s2Row.common_field: {
        add s1Row to result set
    }
}
```

即: **在使用标量子查询和行子查询的场景中,MySQL优化器的执行方式和直觉认为的是一样的**.
