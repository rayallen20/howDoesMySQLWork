# 2. 外连接消除

前文说过,内连接的驱动表和被驱动表的位置可以相互转换,而左连接和右连接的驱动表和被驱动表是固定的.这就导致内连接可能
通过优化表的连接顺序来降低整体的查询成本,而外连接则无法优化表的连接顺序.
之前讲解连接原理时用过的`t1`和`t2`的结构和数据如下:

```sql
CREATE TABLE `t1` (
  `m1` int DEFAULT NULL,
  `n1` char(1) DEFAULT NULL
) ENGINE=InnoDB CHARSET=utf8mb4;
```

```sql
CREATE TABLE `t2` (
  `m2` int DEFAULT NULL,
  `n2` char(1) DEFAULT NULL
) ENGINE=InnoDB CHARSET=utf8mb4;
```

```
mysql> SELECT * FROM t1;
+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+
3 rows in set (0.02 sec)
```

```
mysql> SELECT * FROM t2;
+------+------+
| m2   | n2   |
+------+------+
|    2 | b    |
|    3 | c    |
|    4 | d    |
+------+------+
3 rows in set (0.00 sec)
```

前文说过,外连接和内连接的本质区别:在连接时,对于驱动表中的记录,若无法在被驱动表中找到匹配ON子句中的过滤条件的记录,则:

- 内连接:丢弃驱动表中的记录
- 外连接:保留驱动表中的记录,并将被驱动表中的记录的各个字段使用NULL值填充

效果如下:

```
mysql> SELECT *
    -> FROM t1 INNER JOIN t2
    -> ON t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
2 rows in set (0.00 sec)
```

```
mysql> SELECT *
    -> FROM t1 LEFT JOIN t2
    -> ON t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    1 | a    | NULL | NULL |
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
3 rows in set (0.00 sec)
```

在上边例子中的左连接中,由于驱动表`t1`中`m1=1`且`n1='a'`的那条记录无法在被驱动表`t2`中找到符合ON子句条件`t1.m1 = t2.m2`的记录,
所以就直接把这条记录加入到结果集中,对应的`t2`表的`m2`和`n2`列的值都设置为NULL.

注: 右连接和左连接其实只是在驱动表的选取上不一样,其他方面都一样.所以优化器在优化时,先把右连接转换成左连接,然后再进行优化.

WHERE子句的杀伤力比较大,凡是不符合WHERE子句中条件的记录都不会参与连接.只要在WHERE子句的搜索条件中指定"**被驱动表的列不为NULL**",
则外连接中在被驱动表中找不到符合ON子句条件的驱动表记录也就从最后的结果集中被排除了.换言之,在这种情况下,外连接和内连接是没区别的.
例如:

```
mysql> SELECT *
    -> FROM t1 LEFT JOIN t2
    -> ON t1.m1 = t2.m2
    -> WHERE t2.n2 IS NOT NULL;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
2 rows in set (0.00 sec)
```

由于指定了被驱动表`t2`的`n2`列不允许为NULL,所以这个`t1`和`t2`表的左连接查询的结果集和内连接查询的结果集是完全相同的.
当然,也可以不用显式指定被驱动表的某个列符合搜索条件`IS NOT NULL`,只要隐含的有这个意思即可.例如:

```
mysql> SELECT *
    -> FROM t1 INNER JOIN t2
    -> ON t1.m1 = t2.m2
    -> WHERE t2.m2 = 2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
+------+------+------+------+
1 row in set (0.00 sec)
```

- 空值拒绝(reject-NULL): **在外连接查询中,指定WHERE子句中包含条件:被驱动表中的列不为NULL值**.该条件称为空值拒绝

**在被驱动表的WHERE子句符合空值拒绝的条件后,外连接和内连接可以相互转换**.这种转换带来的好处就是:
查询优化器可以通过评估表的不同连接顺序的成本,选出成本最低的那种连接顺序来执行查询.这种转换的过程称为**外连接消除**(outer-join elimination).
