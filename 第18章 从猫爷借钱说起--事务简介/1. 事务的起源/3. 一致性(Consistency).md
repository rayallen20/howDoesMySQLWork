# 3. 一致性(Consistency)

现实世界存在着各种约束,比如:

- 身份证号不能重复
- 性别只能是男或者女
- 高考的分数只能在0-750之间
- 人民币面值最大只能是100
- 红绿灯只有3种颜色
- 房价不能为负(在2025年看这句话倒也不一定哈)
- 学生要听老师话(这条约束听起来有点儿奇怪,但在某些学校确实是这样)
- 等等

**只有符合这些约束的数据才是有效的**.比如有人说他高考考了1000分,你一听就知道他是胡扯的.
数据库世界只是现实世界的一个映射,现实世界中存在的约束当然也要在数据库世界中有所体现.
**若数据库中的数据全部符合现实世界中的约束(all defined rules),则称这些数据就是一致的,或者说符合一致性的**.

靠2方面来保证数据库中数据的一致性(即符合所有现实世界的约束):

- 数据库本身能保证一部分一致性需求

    即:数据库自身可以保证一部分现实世界的约束永远有效.

    MySQL数据库可以为表建立:
    - 主键
    - 唯一索引
    - 外键
    - 声明某个列为`NOT NULL`来拒绝`NULL`值的插入

    比如,当对某个列建立唯一索引时,若插入某条记录时发现该列的值重复了,则MySQL就会报错并且拒绝插入.
    除了这些保证一致性的功能,MySQL还支持`CHECK`语法来自定义约束.例如:
    
    ```sql
    CREATE TABLE account_with_check (
        id INT NOT NULL AUTO_INCREMENT COMMENT '自增id',
        name VARCHAR(100) COMMENT '客户名称',
        balance INT COMMENT '余额',
        PRIMARY KEY (id),
        CHECK (balance >= 0) 
    ) Engine=InnoDB CHARSET=utf8mb4;
    ```
    
    本例中的`CHECK`语句本意是想规定`balance`列不能存储小于0的数字,对应的现实世界的意思就是银行账户余额不能小于0.
    但是,MySQL仅仅支持CHECK语法,但实际上并没有用(**从MySQL 8.0.16开始,InnoDB正式支持`CHECK`约束**).
    
    还可以通过定义触发器的方式来自定义一些约束条件,以保证数据库中数据的一致性.

- 更多的一致性需求需要靠写业务代码的程序员自己保证

为建立现实世界和数据库世界的对应关系,理论上应该把现实世界中的所有约束都反应到数据库世界中.但是,**在更改数据库数据时进行一致性检查
是一个耗费性能的工作**.

比如,为`account`表建立了一个触发器:每当插入或者更新记录时都会校验`balance`列的值是否大于0.这就会影响到插入或更新的速度.

仅仅是校验一行记录是否符合一致性需求还好,但是有的一致性需求需要检查全表.例如:银行会建立一张代表账单的表,其中记录了每个账户的每笔交易,
且每笔交易完成后,都需要保证: `整个系统的余额 = 所有账户的收入 - 所有账户的支出`.若在数据库层面实现这个一致性需求的话,则每次发生交易时,
都需要:

- step1. 将所有的收入累加
- step2. 将所有的支出累加
- step3. 将所有的账户余额累加
- step4. 检测`所有收入的累加 - 所有支出的累加`是否等于`所有账户余额的累加`

若账单表里有几亿条记录,光是这个校验的过程可能就要耗费好几个小时.这样的性能代价是完全承受不起的.

现实生活中复杂的一致性需求比比皆是,而由于性能问题把一致性需求交给数据库去解决也是不现实的,所以这个锅就甩给了业务端程序员.
例如`account`表,也可以不建立触发器,只要编写业务的程序员在业务代码中判断:当某个操作会将`balance`列的值更新为小于0的值时,不执行该操作即可.

**原子性和隔离性都会对一致性产生影响**.

比如,现实世界中转账操作完成后,有这样一个一致性需求:参与转账的账户的总余额不变.

- 若数据库不遵循原子性要求(即允许出现转了一半就不转的情况),则有可能出现给狗哥扣了钱而没给猫爷转过去的情况,那最后就是不符合一致性需求的
- 若数据库不遵循隔离性要求(即允许2次转账操作时读取了相同的账户数据),则可能出现操作结束后狗哥账户中扣的钱和猫爷账户中涨的钱就不一样的情况,也不符合一致性需求

所以,**数据库某些操作的原子性和隔离性都是保证一致性的一种手段,在操作执行完成后保证符合所有既定的约束则是一种结果**.

但是,满足原子性和隔离性的操作也不一定就满足一致性.比如说狗哥要转账20元给猫爷,虽然操作满足原子性和隔离性,但转账完成后狗哥的账户的余额就成负的了,
这显然是不满足一致性的.

同样的,不满足原子性和隔离性的操作也不一定就不满足一致性.只要最后的结果符合所有现实世界中的约束,那么就是符合一致性的.比如经常说的"最终一致性",
即:在某些操作完成后,虽然数据暂时不满足一致性,但经过一段时间后会变成满足一致性的状态.

一般在定义一致性需求时,只要某些数据库操作满足原子性和隔离性规则,则这些操作执行后的结果就会符合一致性需求.
