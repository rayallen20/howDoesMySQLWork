# 0. 前言

对于大部分程序员来说,他们的任务就是把现实世界的业务场景映射到数据库世界.比如银行为了存储人们的账户信息会建立一个`account`表:

```sql
CREATE TABLE account (
    id INT NOT NULL AUTO_INCREMENT COMMENT '自增id',
    name VARCHAR(100) COMMENT '客户名称',
    balance INT COMMENT '余额',
 PRIMARY KEY (id)
) Engine=InnoDB CHARSET=utf8mb4;
```

狗哥和猫爷是一对好朋友,他们都到银行各自开设了一个账户,他们在现实世界中拥有的资产就会体现在数据库世界的`account`表中.
比如现在狗哥有11元,猫爷只有2元,那么现实中的这个情况映射到数据库的`account`表如下:

```
mysql> SELECT * FROM account;
+----+--------+---------+
| id | name   | balance |
+----+--------+---------+
|  1 | 狗哥   |      11 |
|  2 | 猫爷   |       2 |
+----+--------+---------+
2 rows in set (0.00 sec)
```

**在某个特定的时刻,狗哥猫爷这些家伙在银行所拥有的资产是一个特定的值.这些特定的值也可以被描述为账户在这个特定的时刻现实世界的一个状态**.
随着时间的流逝,狗哥和猫爷可能陆续进行向账户中存钱/取钱/向别人转账等操作,他们账户中的余额就也因此发生变动,每一个操作都相当于现实世界中
账户的一次状态转换.

数据库世界作为现实世界的一个映射,自然也要进行相应的变动.现实世界中一些看似很简单的状态转换,映射到数据库世界却不是那么容易的.

比如,有一次猫爷急着用钱,急忙打电话给狗哥要借10块钱.现实世界中的狗哥走向了ATM机,输入了猫爷的账号以及10元的转账金额,然后按下确认,
狗哥就拔卡走人了.对于数据库世界来说,相当于执行了下面这2条语句:

```
UPDATE account SET balance = balance - 10 WHERE id = 1;
UPDATE account SET balance = balance + 10 WHERE id = 2;
```

但是这里面有个问题:若上述2条语句只执行了一条时,服务器忽然断电了,该怎么办?把狗哥的钱扣了,但是没给猫爷转过去.那猫爷还是逃脱不了着急用钱的窘境.
即使对于单独的1条语句,前面在讲`Buffer Pool`时也说过:在对某个页面进行读写访问时,需要:

- 先把这个页面加载到`Buffer Pool`中
- 之后如果修改了某个页面,也不会立即把修改刷新到磁盘
  - 只是把这个修改后的页面添加到`Buffer Pool`的`flush`链表中
- 在之后的某个时间点才会刷新到磁盘

如果在将修改过的页刷新到磁盘之前系统崩溃了,猫爷岂不是依然陷在用钱窘境中?

怎么才能保证让可怜的猫爷摆脱窘境呢?这里的核心问题是:**如何让某些数据库操作符合现实世界中状态转换的规则**.
数据库的设计者认为,现实世界中状态转换的规则有好几条.
