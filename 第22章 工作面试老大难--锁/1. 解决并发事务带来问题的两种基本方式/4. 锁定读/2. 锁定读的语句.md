# 2. 锁定读的语句

前文讲到,为了采用加锁方式避免脏读/不可重复读/幻读这些现象,在读取一条记录时需要获取该记录的S锁.其实这是不严谨的.

- 锁定读: 有时需要在读取记录时就获取该记录的X锁,从而禁止别的事务读写该记录.这种**在读取记录前就为该记录加锁的读取方式**称为锁定读(`Locking Read`)

MySQL的设计者提供了下面2种特殊的SELECT语句格式来支持锁定读:

- 对读取的记录加S锁

    ```
    SELECT ... LOCK IN SHARE MODE;
    ```
    
    即在普通的SELECT语句后面加上`LOCK IN SHARE MODE`.若当前事务执行了该语句,则该语句会为读取到的记录加S锁,这样:
    
    - 允许其他事务继续获取这些记录的S锁(比如其他事务也使用`SELECT ... LOCK IN SHARE MODE`语句来读取这些记录时)
    - 其他事务不能获取这些记录的X锁(比如使用`SELECT.. FOR UPDATE语句来读取这些记录,或直接改动这些记录时)
      - 若其他事务想要获取这些记录的X锁,则它们会被阻塞,直到当前事务提交之后将这些记录上的S锁释放掉为止

- 对读取的记录加X锁

    ```
    SELECT ... FOR UPDATE;
    ```
    
    即在普通的SELECT语句后面加上`FOR UPDATE`.若当前事务执行了该语句,则该语句会为读取到的记录加X锁,这样:
    
    - 不允许其他事务获取这些记录的S锁(比如其他事务使用`SELECT.. LOCK IN SHARE MODE`语句来读取这些记录时)
    - 不允许其他事务获取这些记录的X锁(比如说使用`SELECT.. FOR UPDATE`语句来读取这些记录,或其他事务直接改动这些记录时)
      - 若其他事务想要获取这些记录的S锁或者X锁,则它们会被阻塞,直到当前事务提交之后将这些记录上的X锁释放掉为止

关于锁定读的更多加锁细节,后续会讲到
