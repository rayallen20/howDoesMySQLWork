# 2. 读-写或写-读情况

前文说过,在读-写/写-读情况下会出现:

- 脏读
- 不可重复读
- 幻读

的现象.

SQL92标准规定,不同隔离级别有如下特点:

- 在`READ UNCOMMITTED`隔离级别下: 脏读/不可重复读/幻读都可能发生
- 在`READ COMMITTED`隔离级别下: 不可重复读、幻读可能发生，脏读不可能发生
- 在`REPEATABLE READ`隔离级别下: 幻读可能发生,脏读/不可重复读不可能发生
- 在`SERIALIZABLE`隔离级别下: 以上现象都不可能发生

各个数据库厂商对SQL标准的支持可能不一样.MySQL与SQL标准不同的一点就是:MySQL在`REPEATABLE READ`隔离级别下很大程度地避免了幻读现象(在某些情况下其实还是可能出现幻读现象的,
稍后会讲到).如何避免脏读/不可重复读/幻读这些现象?有2种可选的解决方案:

- 方案1: 读操作使用多版本并发控制(MVCC),写操作进行加锁

    MVCC在第21章有详细的描述,就是生成一个`ReadView`,然后通过`ReadView`找到符合条件的记录版本(历史版本是由`undo`日志构建的).就像是在生成`ReadView`的那个时刻,
    时间静止了(就像用相机拍了一个快照),查询语句只能读到在生成`ReadView`之前已提交事务所做的更改
    
    - 在生成`ReadView`之前未提交的事务
    - 在生成`ReadView`之后才开启的事务
    
    所做的更改则是看不到的.写操作针对的是最新版本的记录,读操作读的是记录历史版本.
    
    - 读操作读的是记录历史版本
    - 写操作改动的是记录的最新版本
    
    这两者并不冲突.
    
    即: **采用MVCC时,读-写操作并不冲突**
    
    注:
    
    前面讲过,普通的SELECT语句在`READ COMMITTED`和`REPEATABLE READ`隔离级别下会使用到MVCC读取记录
    
    - 在`READ COMMITTED`隔离级别下,一个事务在执行过程中每次执行SELECT操作时,都会生成一个`ReadView`
    - `ReadView`的存在本身就保证了事务不能读取到未提交的事务所做的更改,也就是避免了脏读现象
    - 在`REPEATABLE READ`隔离级别下,一个事务在执行过程中只有第一次执行SELECT操作才会生成一个`ReadView`,之后的SELECT操作都复用该`ReadView`
    
    这样也就避免了不可重复读和幻读的现象.

- 方案2: 读/写操作都采用加锁的方式

    有一些业务场景不允许读取记录的旧版本,而是每次都必须去读取记录的最新版本.比如在银行存款的事务中:
    
    - 先把账户的余额读出来
    - 然后将其加上本次存款的数额
    - 最后再写到数据库中
    
    在将账户余额读取出来后,就不能让别的事务再访问到该余额,直到本次存款事务执行完成后,其他事务才可以访问账户的余额.那么在读取记录时,
    就需要对其进行加锁操作,这就表示读操作和写操作也得像写-写操作那样排队执行
    
    注:
    
    - 脏读现象的产生是因为: 当前事务读取了另一个未提交事务写的一条记录
      - 若另一个事务在写记录时就给这条记录加锁,则当前事务就无法在读取该记录时再获取到锁了,所以也就不会出现脏读现象了
    - 不可重复读现象的产生是因为: 当前事务先读取一条记录,另外一个事务对该记录进行了改动
      - 若在当前事务读取记录时就给该记录加锁,则另一个事务就无法修改该记录,自然也就不会出现不可重复读现象了
    - 幻读现象的产生是因为: 某个事务读取了符合某些搜索条件的记录,之后别的事务又插入了符合相同搜索条件的新记录,导致该事务再次读取相同搜索条件的记录时,可以读到别的事务插入的新记录,这些新插入的记录就称为**幻影记录**
      - 采用加锁的方式避幻读现象就有点麻烦了: 因为当前事务在第一次读取记录时那些幻影记录并不存在,所以在读取时,并不知道该给谁加锁,但InnoDB的设计者也有办法,后边会讲到

很明显:

- 采用MVCC方式,读-写操作彼此并不冲突,性能更高
- 采用加锁方式,读-写操作彼此需要排队执行,从而影响性能

一般情况下,当然愿意采用MVCC来解决读-写操作并发执行的问题.但是在某些特殊的业务场景中,要求必须采用加锁的方式执行,那也是没有办法的事
