# 5. 隐式锁

在内存中生成锁结构并且维护这些锁结构并不是一件零成本的事情,InnoDB的设计出于节约资源的考量,提出了一个隐式锁的概念.比如:
一般情况下执行INSERT语句是不需要在内存中生成锁结构的(当然,若即将插入的间隙已经被其他事务加了gap锁,则本次INSERT操作会阻塞,
且当前事务会在该间隙的右边界加一个插入意向锁),但是这可能导致一些问题.比方说一个事务(简称事务A)首先插入了一条记录(此时并没有与该记录关联的锁结构),
然后另一个事务(简称事务B)执行如下操作:

- 立即使用`SELECT ... LOCK IN SHARE MODE`语句读取这条记录(即要获取这条记录的S锁)
- 立即使用`SELECT ... FOR UPDATE`语句读取这条记录(即要获取这条记录的X锁)

该怎么办(注意此时事务A尚未提交,还是活跃事务)?

若允许这种情况的发生,则可能出现脏读现象

-立即修改这条记录(即要获取这条记录的X锁)

该怎么办?

若允许这种情况的发生,则可能出现脏写现象

这时事务id又要起作用了.把聚簇索引和二级索引中的记录分开看一下:

- 情景1: 聚簇索引

    对于聚簇索引记录来说,有一个`trx_id`隐藏列,该隐藏列记录的是最后改动该记录的事务id.在事务A新插入一条聚簇索引记录后,该记录的`trx_id`隐藏列
    代表的就是事务A的事务id.若事务B此时想对该记录添加S锁或X锁时,首先要检查该记录的`trx_id`隐藏列代表的事务是否是当前的活跃事务:
    
    - 若不是,则事务B可以正常读取该聚簇索引记录
    - 若是:
      - step1. 为事务A创建一个X锁的锁结构,该锁结构的`is_waiting`属性值为`false`
      - step2. 事务B为自身也创建一个锁结构,该锁结构的`is_waiting`属性值为`true`
      - step3. 事务B进入等待状态

- 情景2: 二级索引

    对于二级索引记录来说,本身并没有`trx_id`隐藏列,但是在二级索引页面的[`Page Header`](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC5%E7%AB%A0%20%E7%9B%9B%E6%94%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%A7%E7%9B%92%E5%AD%90--InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/5.%20Page%20Header(%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8).md)部分有一个`PAGE_MAX_TRX_ID`属性,
    该属性代表对该页面做改动的最大的事务id.
    
    - 若`页面的PAGE_MAX_TRX_ID属性值 < 当前最小的活跃事务id`: 则说明对该页面做修改的事务都已经提交了
    - 若`页面的PAGE_MAX_TRX_ID属性值 >= 当前最小的活跃事务id`: 
      - step1. 在页面中定位到对应的二级索引记录
      - step2. 回表找到该二级索引记录对应的聚簇索引记录
      - step3. 重复情景一的做法

通过上文得知,一个事务对新插入的记录可以不显式地加锁(生成一个锁结构),但是由于事务id的存在,相当于加了一个隐式锁.别的事务在对这条记录加S锁或者X锁时,
由于隐式锁的存在,会:

- step1. 为当前事务(这里的当前事务指的是写这条记录的事务)生成一个锁结构
- step2. 自己(这里的自己指的是要给这条记录加S锁或X锁的事务)再生成一个锁结构
- step3. 进入等待状态

可以看出,**隐式锁起到了延迟生成锁结构的作用**.若别的事务在执行过程中不需要获取与该隐式锁相冲突的锁,则可以避免在内存中生成锁结构.
这只是锁在实现上的一个"投机取巧"的方案,对用户来说是透明的.即: **无论使用隐式锁保护记录,还是通过在内存中显式生成锁结构来保护记录,起到的作用是相同的**.
隐式锁仅仅能够延迟生成锁(不是在事务开启时就创建锁,而是当事务读取到有竞态条件的记录时再创建锁).

注: 除了插入意向锁,在一些特殊情况下INSERT语句还会在内存中创建一些锁结构,稍后会讲到
