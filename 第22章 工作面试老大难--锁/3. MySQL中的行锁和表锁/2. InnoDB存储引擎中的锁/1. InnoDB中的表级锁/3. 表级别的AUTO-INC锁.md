# 3. 表级别的`AUTO-INC`锁

在使用MySQL过程中,可以为表的某个列添加`AUTO_INCREMENT`属性,之后在插入记录时,可以不指定该列的值,系统会自动为该列赋上递增的值,
例如:

```sql
CREATE TABLE t (
    id INT NOT NULL AUTO_INCREMENT,
    c VARCHAR(100),
    PRIMARY KEY (id)
 ) Engine=InnoDB CHARSET=utf8mb4;
```

由于该表的`id`字段声明了`AUTO_INCREMENT`,即在书写插入语句时不需要该字段赋值,例如:

```
mysql> INSERT INTO t(c) VALUES('aa'), ('bb');
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0
```

该插入语句并没有为`id`列显式赋值,所以系统会自动为该列赋上递增的值:

```
mysql> SELECT * FROM t;
+----+------+
| id | c    |
+----+------+
|  1 | aa   |
|  2 | bb   |
+----+------+
2 rows in set (0.00 sec)
```

系统自动为`AUTO_INCREMENT`修饰的列递增赋值的实现方式主要有以下2种:

- 采用`AUTO-INC`锁

    即执行插入语句时就在表级别加一个`AUTO-INC`锁,然后为每条待插入记录的`AUTO_INCREMENT`修饰的列分配递增的值,
    在该语句执行结束后,再把`AUTO-INC`锁释放掉.这样一来,事务A在持有该表的`AUTO-INC`锁的过程中,其他事务中对该表的插入语句都要被阻塞,
    可以保证一个插入语句中分配的递增值是连续的
    
    若插入语句在执行前无法确定要插入记录的数量(无法预计即将插入记录的数量),比如:
    
    - `INSERT ... SELECT`
    - `REPLACE ... SELECT`
    - `LOAD DATA`
    
    一般使用`AUTO-INC`锁为`AUTO_INCREMENT`修饰的列生成对应的值
    
    注意: **`AUTO-INC`锁的作用范围只是单个插入语句,插入语句执行完成后,这个锁就被释放了**,和之前介绍的锁在事务结束时释放是不同的

- 采用轻量级锁

在为插入语句生成`AUTO_INCREMENT`修饰的列的值时:

- 先获取该轻量级锁
- 然后生成本次插入语句需要用到的`AUTO_INCREMENT`列的值
- 最后把该轻量级锁释放掉

这样一来,就不需要等到整个插入语句执行完才释放锁.

简单理解就是不需要等到INSERT语句完全把记录写完(这一步我不确定是写到磁盘上还是内存上,但至少要把记录写完),只需要把该INSERT语句
要插入的记录的`AUTO_INCREMENT`列的值生成完就可以释放锁了.

如果插入语句在执行前就可以确定具体要插入多少条记录(比如上边举的关于表`t`的例子中,在语句执行前就可以确定要插入2条记录),
则一般采用轻量级锁的方式对`AUTO_INCREMENT`修饰的列进行赋值.这种方式可以避免锁定表,可以提升插入性能.

系统变量`innodb_autoinc_lock_mode`用于控制到底使用上述2种方式中的哪种来为`AUTO_INCREMENT`修饰的列进行赋值:

- 当`innodb_autoinc_lock_mode`值为0时,一律采用`AUTO-INC`锁
- 当`innodb_autoinc_lock_mode`值为2时,一律采用轻量级锁
- 当`innodb_autoinc_lock_mode`值为1时,2种方式混用
  - 在插入记录数量确定时使用轻量级锁
  - 在插入记录数量不确定时使用`AUTO-INC`锁

**当`innodb_autoinc_lock_mode`值为2时,可能会造成不同事务中的插入语句为`AUTO_INCREMENT`修饰的列生成的值是交叉的,在有主从复制的场景中是不安全的**

```
mysql> SHOW VARIABLES LIKE 'innodb_autoinc_lock_mode';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| innodb_autoinc_lock_mode | 2     |
+--------------------------+-------+
1 row in set (0.04 sec)
```