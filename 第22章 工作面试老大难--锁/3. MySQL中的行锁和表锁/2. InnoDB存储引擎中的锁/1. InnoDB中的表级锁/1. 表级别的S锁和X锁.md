# 1. 表级别的S锁和X锁

在对某个表执行 

- SELECT
- INSERT
- DELETE
- UPDATE

语句时,InnoDB存储引擎是不会为该表添加表级别的S锁或X锁的(因为这些语句的目标对象是具体的某些行,而非整张表)

另外,在对某个表执行一些诸如:

- `ALTER TABLE`
- `DROP TABLE`

这类的DDL语句时,其他事务对该表并发执行诸如:

- SELECT
- INSERT
- DELETE
- UPDATE

的语句会发生阻塞

同理,某个事务中对某个表执行

- SELECT
- INSERT
- DELETE
- UPDATE

语句时,在其他会话中对该表执行DDL语句也会发生阻塞

这个过程其实是通过在server层使用一种称为元数据锁(`Metadata Locks`,简称MDL)的东西来实现的,一般情况下也不会使用InnoDB
存储引擎自己提供的表级别的S锁和X锁

注:

在[第18章的隐式提交章节中](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC18%E7%AB%A0%20%E4%BB%8E%E7%8C%AB%E7%88%B7%E5%80%9F%E9%92%B1%E8%AF%B4%E8%B5%B7--%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/3.%20MySQL%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%AF%AD%E6%B3%95/6.%20%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4.md)讲到过,DDL语句执行时会隐式的提交当前会话中的事务,原因是DDL语句的执行一般都会在若干个特殊事务中完成.
在开启这些特殊事务前,需要将当前会话中的事务提交掉.另外,关于MDL锁并不是本章所要讨论的范围,可参阅文档了解

其实InnoDB存储引擎提供的表级S锁和X锁相当"鸡肋",只会在一些特殊情况下(例如系统崩溃恢复时)用到.不过还是可以手动获取一下的,在系统变量:

- `autocommit = OFF`
- `innodb_table_locks = ON`
  - 该变量用于控制InnoDB是否在事务中使用表锁,且是否与MySQL Server层的表锁机制进行交互

时,要手动获取InnoDB存储引擎提供的表`t`的S锁或者X锁,可按照如下写法:

- `LOCK TABLES t READ`: InnoDB存储引擎会对表`t`加表级别的S锁
- `LOCK TABLES t WRITE`: InnoDB存储引擎会对表`t`加表级别的X锁

尽量避免在使用InnoDB存储引擎的表上使用`LOCK TABLES`这样的手动锁表语句,它们并不会提供什么额外的保护,只是会降低并发能力.
InnoDB的强大之处在于实现了更细粒度的行锁,关于表级别的S锁和X锁了解即可
