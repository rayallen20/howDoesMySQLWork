# 5. 特殊情况

- 特殊情况1: 当隔离级别不大于`READ COMMITTED`时,若匹配模式为[精确匹配](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC22%E7%AB%A0%20%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE--%E9%94%81/4.%20%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/2.%20%E9%94%81%E5%AE%9A%E8%AF%BB%E7%9A%84%E8%AF%AD%E5%8F%A5/1.%20%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F(match%20mode).md),则不会为扫描区间后面的下一条记录加锁

    注意: 精确匹配是指**对索引进行等值扫描后只有1个扫描区间**,而非只有1条记录(因为二级索引可以存在重复键值)
    
    例如:
    
    ```sql
    SELECT * FROM hero WHERE name = 'c曹操' FOR UPDATE;
    ```
    
    这条语句的执行计划如下:
    
    ```
    mysql> EXPLAIN SELECT * FROM hero WHERE name = 'c曹操' FOR UPDATE;
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | hero  | NULL       | ref  | idx_name      | idx_name | 403     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    1 row in set, 1 warning (0.00 sec)
    ```
    
    执行计划显示,查询优化器决定使用二级索引`idx_name`,需要扫描单点扫描区间`name ∈ ['c曹操', 'c曹操']`中的二级索引记录.在读取完`name = 'c曹操'`的二级索引记录后,
    获取到下一条级索引记录,即`name = 'l刘备'`的二级索引记录.
    
    **由于该场景下的匹配模式为精确匹配,因此在存储引擎内部就判断出该记录不符合精确匹配的条件,所以直接向server层报告"查询完毕"的信息.
    而不再是先给该记录加锁,然后再交给server层判断是否要释放锁**.
    
    即: 按照前文的流程图来讲,就是上一次循环的步骤7结束后,在存储引擎内部就判断出下一次循环的二级索引记录不符合形成扫描区间的边界条件了,
    因此不会再跳回步骤2,而是直接向server层报告"查询完毕"的信息(或者也可以理解为没有进行下一次循环).
    
    在隔离级别不大于`READ COMMITTED`时,该语句执行时的加锁情况如下图示:
    
    ![隔离级别不大于`READ_COMMITED`时的加锁效果示意图-特殊情况1](./img/隔离级别不大于READ_COMMITED时的加锁效果示意图-特殊情况1.jpg)

- 特殊情况2: 当隔离级别不小于`REPEATABLE READ`时,若匹配模式为精确匹配,则会为扫描区间后面的下一条记录加gap锁

    例如,仍然使用上面的语句:
    
    ```sql
    SELECT * FROM hero WHERE name = 'c曹操' FOR UPDATE;
    ```
    
    执行计划显示,查询优化器决定使用二级索引`idx_name`,需要扫描单点扫描区间`name ∈ ['c曹操', 'c曹操']`中的二级索引记录.在读取完`name = 'c曹操'`的二级索引记录后,
    获取到下一条级索引记录,即`name = 'l刘备'`的二级索引记录.
    
    由于该场景下的匹配模式为精确匹配,因此在存储引擎内部就判断出该记录不符合精确匹配的条件,所以为该记录加一个gap锁,之后向server层报告"查询完毕"的信息.
    
    即: 按照前文的流程图来讲,就是上一次循环的步骤7结束后,在存储引擎内部就判断出下一次循环的二级索引记录不符合形成扫描区间的边界条件了,
    因此不会再跳回步骤2.步骤2是为该记录加`next-key`锁,而该场景下是为该记录加gap锁(这里的该记录指的是扫描区间后面的下一条记录,因为没有下一次循环,
    所以这里我没有写下一条记录).而是直接为该记录加一个gap锁,之后向server层报告"查询完毕"的信息(或者也可以理解为没有进行下一次循环).
    
    在隔离级别不小于`REPEATABLE READ`时,该语句执行时的加锁情况如下图示:
    
    ![隔离级别不小于`REPEATABLE_READ`时的加锁效果示意图-特殊情况2](./img/隔离级别不小于REPEATABLE_READ时的加锁效果示意图-特殊情况2.jpg)

    简单理解: 这2种特殊情况,都是因为在存储引擎层就能够确定下一条记录是不匹配的(因为对索引列的条件是等值的),所以就直接进行特殊处理了:
    
    - 隔离级别不大于`READ COMMITTED`时,不对不符合条件的记录加锁,报告"查询完毕"
    - 隔离级别不小于`REPEATABLE READ`时,对不符合条件的记录加gap锁,报告"查询完毕"

- 特殊情况3: 当隔离级别不小于`REPEATABLE READ`时,若匹配模式为精确匹配,且扫描区间中没有记录,则也要为扫描区间后面的下一条记录加一个gap锁

    例如:
    
    ```sql
    SELECT * FROM hero WHERE name = 'g关羽' FOR UPDATE;
    ```
    
    这条语句的执行计划如下:
    
    ```
    mysql> EXPLAIN SELECT * FROM hero WHERE name = 'g关羽' FOR UPDATE;
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | hero  | NULL       | ref  | idx_name      | idx_name | 403     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+
    1 row in set, 1 warning (0.00 sec)
    ```

    执行计划显示,查询优化器决定使用二级索引`idx_name`,需要扫描单点扫描区间`name ∈ ['g关羽', 'g关羽']`中的二级索引记录.
    但是不存在`name = 'g关羽'`的二级索引记录,所以需要为扫描区间`name ∈ ['g关羽', 'g关羽']`后面的下一条记录,即`name = 'l刘备'`
    的二级索引记录加一个gap锁.
    
    **目的是为了防止别的事务在`name ∈ ('c曹操', 'l刘备')`之间插入二级索引记录**
    
    ![隔离级别不小于`REPEATABLE READ`时的加锁效果示意图-特殊情况3](./img/隔离级别不小于REPEATABLE_READ时的加锁效果示意图-特殊情况3.jpg)
    
    **其实特殊情况2和特殊情况3,都是在隔离级别不小于`REPEATABLE READ`且匹配模式为精确匹配时,为扫描区间后面的下一条记录加gap锁.
    其目的是为了确保不会出现幻读现象**

- 特殊情况4: 当隔离级别不小于`REPEATABLE READ`时,若匹配模式不是精确匹配,且没有找到匹配的记录,则会为该扫描区间后面的下一条记录加`next-key`锁

    例如:
    
    ```sql
    SELECT * FROM hero WHERE name > 'd' AND name < 'l' FOR UPDATE;
    ```
    
    这条语句的执行计划如下:
    
    ```
    mysql> EXPLAIN SELECT * FROM hero WHERE name > 'd' AND name < 'l' FOR UPDATE;
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | hero  | NULL       | range | idx_name      | idx_name | 403     | NULL |    1 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
    1 row in set, 1 warning (0.00 sec)
    ```
    
    执行计划显示,查询优化器决定使用二级索引`idx_name`,需要扫描单点扫描区间`name ∈ ('d', 'l')`中的二级索引记录.但是不存在`name ∈ ('d', 'l')`
    的的二级索引记录,所以需要为扫描区间`name ∈ ('d', 'l')`后面的下一条记录,即`name = 'l刘备'`的二级索引记录加一个`next-key`锁.
    
    在隔离级别不小于`REPEATABLE READ`时M该语句执行时的加锁情况如下图示:
    
    ![隔离级别不小于`REPEATABLE READ`时的加锁效果示意图-特殊情况4](./img/隔离级别不小于REPEATABLE_READ时的加锁效果示意图-特殊情况4.jpg)

- 特殊情况5: 当隔离级别不小于`REPEATABLE READ`时:
  - 若使用的是聚簇索引
  - 且扫描的扫描区间是左闭区间
  - 且定位到的第1条聚簇索引记录的主键值与扫描区间中最小的值相同
    - 简单理解就是扫描区间的左界在聚簇索引中是存在的
  - 则会为该聚簇索引记录加`LOCK_REC_NOT_GAP`锁

    例如:
    
    ```sql
    SELECT * FROM hero WHERE number >= 8 FOR UPDATE;
    ```
    
    这条语句的执行计划如下:
    
    ```
    mysql> EXPLAIN SELECT * FROM hero WHERE number >= 8 FOR UPDATE;
    +----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | hero  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    3 |   100.00 | Using where |
    +----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
    1 row in set, 1 warning (0.00 sec)
    ```
    
    执行计划显示,查询优化器决定使用聚簇索引,需要扫描扫描区间`number ∈ [8,+∞)`中的聚簇索引记录.由于`number ∈ [8,+∞)`是左闭区间,
    且表中正好存在一条`number = 8`的聚簇索引记录,所以会对这条`number = 8`的聚簇索引记录只添加`LOCK_REC_NOT_GAP`锁
    
    在隔离级别不小于`REPEATABLE READ`时,该语句执行时的加锁情况如下图示:
    
    ![隔离级别不小于`REPEATABLE READ`时的加锁效果示意图-特殊情况5](./img/隔离级别不小于REPEATABLE_READ时的加锁效果示意图-特殊情况5.jpg)
    
    在图中可以看到:
    
    - 为`number = 8`的聚簇索引记录被了`LOCK_REC_NOT_GAP`锁
    - 为扫描到的其他记录加了`next-key`锁
    
    另外需要注意: 该语句还为`Supremum`记录加了`next-key`锁,这样就可以阻止其他语句在`number ∈ (20, +∞)`的区间插入记录了
    
    之所以会有这种特殊情况,是为了避免"误伤".由于表中不可能出现主键值相间的记录,所以别的事务肯定不会再插入`number = 8`的聚簇索引记录.
    因此,仅在`number = 8`的聚簇索引记录上加一个`LOCK_REC_NOT_GAP`锁就足够了,而不必要为其加`next-key`锁.
    若在`number = 8`的聚簇索引记录上加了`nextkey`锁,就阻止了别的事务在`number ∈ (3, 8)`的范围内插入聚簇索引记录,显然这是不必要的.

- 特殊情况6:无论是哪个隔离级别,只要是[唯一性搜索](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC22%E7%AB%A0%20%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE--%E9%94%81/4.%20%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90/2.%20%E9%94%81%E5%AE%9A%E8%AF%BB%E7%9A%84%E8%AF%AD%E5%8F%A5/2.%20%E5%94%AF%E4%B8%80%E6%80%A7%E6%90%9C%E7%B4%A2(unique%20search).md),且读取的记录没有被标记为"已删除"(记录头信息中的`deleted_flag = 1`),就为读取到的记录加`LOCK_REC_NOT_GAP`锁

    简单理解就是: 因为这条加锁读的语句,只会读1条记录(唯一性搜索保证了这一点),所以不需要考虑幻读的问题,因此只需要为读取到的记录加`LOCK_REC_NOT_GAP`锁就够了,不需要加gap锁.
    
    例如:
    
    ```sql
    SELECT * FROM hero WHERE number = 8 FOR UPDATE;
    ```
    
    这条语句的执行计划如下:
    
    ```
    mysql> EXPLAIN SELECT * FROM hero WHERE number = 8 FOR UPDATE;
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | hero  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
    1 row in set, 1 warning (0.00 sec)
    ```
    
    执行计划显示,查询优化器决定使用聚簇索引,需要扫描扫描区间`number ∈ [8,8]`中的聚簇索引记录.由于是唯一性搜索,
    所以只需要为`number = 8`的聚簇索引记录加`LOCK_REC_NOT_GAP`锁.
    
    在隔离级别不小于`REPEATABLE READ`时,该语句执行时的加锁情况如下图示(其实隔离级别不大于`READ COMMITTED`时也是一样的):
    
    ![隔离级别不小于`REPEATABLE READ`时的加锁效果示意图-特殊情况6](./img/隔离级别不小于REPEATABLE_READ时的加锁效果示意图-特殊情况6.jpg)

- 特殊情况7: 在扫描某个扫描区间中的记录时,一般都是按照从左到右的顺序进行扫描,但是有些情况下需要从右到左进行扫描.当隔离级别不小于`REPEATABLE READ`,且按照从右到左的顺序扫描扫描区间中的记录时,会为匹配到的第1条记录的下一条记录加gap锁

    例如:
    
    ```sql
    SELECT *
    FROM hero FORCE INDEX(idx_name)
    WHERE
        name > 'c曹操'
    AND
        name <= 'x荀彧'
    AND
        country!= '吴'
    ORDER BY name DESC
    FOR UPDATE;
    ```
    
    这条语句的执行计划如下:
    
    ```
    mysql> EXPLAIN SELECT * FROM hero FORCE INDEX(idx_name) WHERE name > 'c曹操' AND name <= 'x荀彧' AND country!= '吴' ORDER BY name DESC FOR UPDATE;
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+---------------------------------------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                                                   |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+---------------------------------------------------------+
    |  1 | SIMPLE      | hero  | NULL       | range | idx_name      | idx_name | 403     | NULL |    1 |    80.00 | Using index condition; Using where; Backward index scan |
    +----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+---------------------------------------------------------+
    1 row in set, 1 warning (0.00 sec)
    ```
    
    执行计划显示,查询优化器决定使用二级索引`idx_name`,需要扫描扫描区间`name ∈ ('c曹操', 'x荀彧']`中的二级索引记录.由于语句中包含`ORDER BY name DESC`,
    也就是需要按照从大到小的顺序对查询结果进行排序,那么可以在扫描扫描区间`name ∈ ('c曹操', 'x荀彧']`中的二级索引记录时,直接定位到该扫描区间的最后一条记录,
    即`name = 'x荀彧'`的二级索引记录,然后按照从右到左的顺序进行扫描即可.不过在定位到`name = 'x荀彧'`的二级索引记录后,需要对该记录所在单向链表的下一条二级索引记录,
    即`name = 'z诸葛亮'`的二级索引记录加一个gap锁(目的是防止其他事务插入`name = 'x荀彧'`的新记录)
    
    简单理解: 该特殊情况是为了防止出现幻读现象
    
    在隔离级别不小于`REPEATABLE READ`时,该语句执行时的加锁情况如下图示:
    
    ![隔离级别不小于`REPEATABLE READ`时的加锁效果示意图-特殊情况7](./img/隔离级别不小于REPEATABLE_READ时的加锁效果示意图-特殊情况7.jpg)

这些加锁特殊情况:

- 要么是为了避免出现幻读现象
- 要么是根据MySQL的一些固有特点(比如记录的主键值不重复)将部分`next-key`锁替换为`LOCK_REC_NOT_GAP`锁,从而尽量减少对其他事务的影响
