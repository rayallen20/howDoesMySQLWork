# 1. 普通的SELECT语句

在不同的隔离级别下,普通的SELECT语句具有不同的表现,具体如下:

- 在`READ UNCOMMITTED`隔离级别下,不加锁: 直接读取记录的最新版本;可能出现以下现象:
  - 脏读
  - 不可重复读
  - 幻读
- 在`READ COMMITTED`隔离级别下,不加锁: 在每次执行普通的SELECT语句时都会生成一个ReadView,这样避免了脏读现象,但没有避免以下现象:
  - 不可重复读
  - 幻读
- 在`REPEATABLE READ`隔离级别下,不加锁: 只在第一次执行普通的SELECT语句时生成一个ReadView,这样就避免了以下现象:
  - 脏读
  - 不可重复读
  - 幻读

    不过这里有一个小插曲(以下过程均在`REPEATABLE READ`隔离级别下进行):
    
    - step1. 事务T1读取一条尚不存在的记录
    
    ```
    mysql> BEGIN;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> SELECT * FROM hero WHERE number = 30;
    Empty set (0.00 sec)
    ```
    
    注意: 此时事务T1尚未提交
    
    - step2. 事务T2写入这条尚不存在的记录并提交
    
    ```
    mysql> BEGIN;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> INSERT INTO hero VALUES(30, 'g关羽', '魏');
    Query OK, 1 row affected (0.00 sec)
    
    mysql> COMMIT;
    Query OK, 0 rows affected (0.01 sec)
    ```
    
    - step3. 事务T1更新这条记录
    
    ```
    mysql> BEGIN;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> SELECT * FROM hero WHERE number = 30;
    Empty set (0.00 sec)
    
    mysql> -- 以上是事务T1之前的操作(即step1中的操作)
    
    mysql> UPDATE hero SET country='蜀' WHERE number= 30;
    Query OK, 1 row affected (0.00 sec)
    Rows matched: 1  Changed: 1  Warnings: 0
    ```
    
    - step4. 事务T1查询该条记录
    
    ```
    mysql> BEGIN;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> SELECT * FROM hero WHERE number = 30;
    Empty set (0.00 sec)
    
    mysql> -- 以上是事务T1之前的操作(即step1中的操作)
    
    mysql> UPDATE hero SET country='蜀' WHERE number= 30;
    Query OK, 1 row affected (0.00 sec)
    Rows matched: 1  Changed: 1  Warnings: 0
    
    mysql> SELECT * FROM hero WHERE number = 30;
    +--------+---------+---------+
    | number | name    | country |
    +--------+---------+---------+
    |     30 | g关羽   | 蜀      |
    +--------+---------+---------+
    1 row in set (0.00 sec)
    ```
    
    在`REPEATABLE READ`隔离级别下:
    
    - 事务T1第一次执行普通的SELECT语句时生成了一个ReadView
    - 之后事务T2向`hero`表中新插入一条记录并提交
    
    ReadView并不能阻止事务TI执行UPDATE/DELETE语句来改动这调新插入的记录(因为T2已经提交,因此改动该记录并不会造成阻塞)
    但是这样一来,这条新记录的`trx_id`隐藏列的值就变成了事务T1的事务id.之后事务T1再使用普通的SELECT语句去查询这条记录时,就可以看到这条记录了,
    也就可以把这条记录返回给客户端.因为这个特殊现象的存在,所以也可以认为**InnoDB中的MVCC并不能完全禁止幻读**

    注: 
    
    ReadView是InnoDB在一致性读(`Consistent Read`)场景下生成的视图,用于确定: 某个事务在执行时,哪些已提交或未提交的事务的版本对它是可见的.
    它的核心目的是控制**快照读**(`snapshot read`)的可见性,即:
    
    ```
    -- 普通查询,不加锁
    SELECT ...
    ```
    
    在这种情况下,InnoDB会根据ReadView来决定返回哪个版本的记录
    
    而UPDATE/DELETE语句并不是普通的快照读,而是**当前读**(`current read`),当前读的特征:
    
    - 读取的是最新版本的数据
    - 并会加上相应的行锁(如X锁或S锁)
    
    例如:
    
    ```sql
    UPDATE t SET c = 1 WHERE id = 10;
    DELETE FROM t WHERE id = 10;
    SELECT * FROM t WHERE id = 10 FOR UPDATE;
    ```
    
    这些语句都属于当前读.
    
    在执行这些操作时,InnoDB不会使用之前生成的ReadView,而是会读取当前版本(最新已提交或自己未提交的版本),以保证修改的正确性
    
    但UPDATE/DELETE也可能会间接依赖ReadView,例如:
    
    ```sql
    UPDATE t SET score = 90 WHERE user_id IN (
        SELECT id FROM users WHERE status = 'active'
    );
    ```
    
    该语句中的子查询属于快照读,会使用当前事务的ReadView.即:
    
    - 对目标表的更新使用当前读(不依赖ReadView)
      - 但在确定要更新哪些行时,若涉及普通子查询或非锁定读,则这些子查询部分会用到ReadView
    
    总结:
    
    |                          操作类型                           | 是否使用 ReadView |    说明     |
    |:-------------------------------------------------------:|:-------------:|:---------:|
    |                    普通的`SELECT`(不加锁)                     |      使用       | 一致性读(快照读) |
    | `SELECT ... FOR UPDATE`/`SELECT ... LOCK IN SHARE MODE` |      不使用      |  当前读,加锁   |
    |                    UPDATE/DELETE主体部分                    |      不使用      |  当前读,加锁   |
    |                UPDATE/DELETE中的子查询(若不加锁)                 |      使用       |   作为快照读   |

- 在`SERIALIZABLE`隔离级别下,需要分下面2种情况进行讨论:
  - 在系统变量`autocommit = 0`时(即禁用自动提交时)

    普通的SELECT语句会被转换为`SELECT ... LOCK IN SHARE MODE`这样的语句.也就是在读取记录前需要先获得记录的S锁.具体的加锁情况和
    在`REPEATABLE READ`隔离级别下一样,后面会分析
  
  - 在系统变量`autocommit = 1`时(即启用自动提交时)

    普通的SELECT语句并不会加锁,只是利用MVCC生成一个ReadView来读取记录.这种场景下之所以不用加锁,是因为**启用自动提交意味着1个事务中只包含1条语句**,
    而只执行1条语句也就不会出现不可重复读/幻读这样的现象了
