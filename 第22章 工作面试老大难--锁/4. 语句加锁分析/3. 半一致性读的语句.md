# 3. 半一致性读的语句

半一致性读(`Semi-Consistent Read`)是一种夹在一致性读和锁定读之间的读取方式.当:

- 隔离级别不大于`READ COMMITTED`
- 且执行UPDATE语句时

将使用半一致性读.

半一致性读: 当UPDATE语句读取到已经被其他事务加了X锁的记录时,InnoDB会将该记录的最新提交版本读出来,然后判断该版本是否与UPDATE语句中的搜索条件相匹配:
- 若不匹配,则不对该记录加锁,从而跳到下一条记录
- 若匹配,则再次读取该记录并对其进行加锁

这样处理只是为了让UPDATE语句尽可能少被别的语句阻塞

简单理解就是: 先根据这条被加了X锁的记录的最新提交版本来判断是否符合UPDATE语句的条件,而不是一直阻塞到该记录的X锁被释放,
这样可以继续处理后续的记录,等到这条被加了X锁的记录的X锁被释放后,再来处理这条记录

注: 这里说的"该记录的最新提交版本",是指忽略持锁事务尚未提交的修改,通过`undo`日志回滚出该行最近一次已经提交的版本,用这个版本判断是否与UPDATE语句的搜索条件相匹配

注: 这里说的"若匹配,则再次读取该记录并对其进行加锁",是指等到UPDATE语句拿到锁后(也就是为该记录加X锁的事务提交后),再读取该记录的最新版本,
然后再次判断该版本是否与UPDATE语句中的搜索条件相匹配(因为刚才持锁事务有可能又更新了这条数据,导致这条数据的版本发生了变化,因此这一步需要重新检测),
若匹配则加锁,然后进行更新操作

假设事务T1的隔离级别为`READ COMMITTED`,事务T1执行了下面这条语句:

```sql
BEGIN;
SELECT * FROM hero WHERE number = 8 FOR UPDATE;
```

(注意此时事务T1尚未提交)

该语句在执行时对`number = 8`的聚簇索引记录加了X型`LOCK_REC_NOT_GAP`锁,如下图示:

![对记录添加X型`LOCK_REC_NOT_GAP`锁](./img/对记录添加X型LOCK_REC_NOT_GAP锁.jpg)

(其实这种情况就是之前讲过的特殊情况6)

此时隔离级别也为`READ COMMITTED`的事务T2执行了如下语句:

```sql
BEGIN;
UPDATE hero SET name = 'cao曹操' WHERE number >= 8 AND number < 20 AND country != '魏';
```

该语句在执行时需要依次获取:

- `number = 8`
- `number = 15`
- `number = 20`

的聚簇索引记录的X型`LOCK_REC_NOT_GAP`锁(其中`number = 20`的记录上的锁会稍后释放)

TODO: 此处该说法是书上的,和我在GPT和DS上查到的说法不同

由于事务T1已经获取了`number = 8`的聚簇索引记录的X型`LOCK_REC_NOT_GAP`锁,按理说此时事务T2应该由于获取不到`number = 8`
的聚簇索引记录的X型`LOCK_REC_NOT_GAP`锁而阻塞.但是由于进行的是半一致性读,所以存储引擎会先获取`number = 8`的聚簇索引记录最新提交的版本
并返回给server层.该版本的`country = '魏'`,很显然不符合条件`country != '魏'`,所以server层决定放弃获取`number = 8`的聚簇索引记录上的
X型`LOCK_REC_NOT_GAP`锁,转而让存储引擎读取下一条记录
