# 2. 外键检查

InnoDB是一个支持外键的存储引擎.现在为三国英雄的战马建一个表`horse`:

```sql
CREATE TABLE horse (
    number INT PRIMARY KEY,
    horse_name VARCHAR(100),
    FOREIGN KEY (number) REFERENCES hero(number)
) Engine=InnoDB CHARSET=utf8mb4;
```

```
mysql> CREATE TABLE horse (
    ->     number INT PRIMARY KEY,
    ->     horse_name VARCHAR(100),
    ->     FOREIGN KEY (number) REFERENCES hero(number)
    -> ) Engine=InnoDB CHARSET=utf8mb4;
Query OK, 0 rows affected (0.05 sec)
```

这样`hero`表就算是一个父表,新建的`horse`表就算一个子表.其中`horse`表的`number`列参照的是`hero`表的`number`列.当向子表`horse`中插入一条记录时,
存在:

- `number`值在`hero`表中找得到
- `number`值在`hero`表中找不到

这2种情况

- 待插入记录的`number`值在`hero`表中能找到

    比如: 在`horse`表中新插入的记录的`number = 8`,而在`hero`表中`number = 8`的记录代表曹操,他的马是绝影:
    
    ```
    mysql> BEGIN;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> INSERT INTO horse VALUES(8, '绝影');
    Query OK, 1 row affected (0.00 sec)
    ```
    
    在插入成功之前,无论当前事务的隔离级别是什么,只需要直接给父表`hero`中`number = 8`的记录加一个S型`LOCK_REC_NOT_GAP`锁即可.
    
    即: **在子表的记录插入成功之前,需要为父表中对应的记录加一个S型`LOCK_REC_NOT_GAP`锁**

- 待插入记录的`number`值在`hero`表中找不到

比如: 在`horse`表中新插入的记录的`number = 5`,而在`hero`表中不存在`number = 5`的记录:

```
mysql> BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql> INSERT INTO horse VALUES(5, '绝影');
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`join_demo`.`horse`, CONSTRAINT `horse_ibfk_1` FOREIGN KEY (`number`) REFERENCES `hero` (`number`))
```

此时虽然插入失败,但是在这个过程中需要根据隔离级别,对父表`hero`中`number  = 8`的聚簇索引记录(**即父表中插入位置上的下一条存在的记录**)进行加锁(或者不加锁):

- 当隔离级别不大于`READ COMMITTED`时,不对该记录加锁
- 当隔离级别不小于`REPEATABLE READ`时,对该记录加gap锁

注:

我猜测这也是为了实现事务的隔离性.当隔离级别不大于`READ COMMITTED`时,当前事务可以读到其他事务已提交的修改,所以即使在当前事务中:

- 上一次INSERT失败了
- 又INSERT一次,成功了

也是合理的,因为当前事务可以读到其他事务已提交的修改,而在这2次INSERT之间,可能有其他事务提交了对父表的修改,使得第二次INSERT成功.

但是当隔离级别不小于`REPEATABLE READ`时,当前事务只能读到自己已提交的修改,所以如果在当前事务中:

- 上一次INSERT失败了
- 又INSERT一次,也必须失败

否则就会违反事务的隔离性.所以为了防止其他事务对父表进行修改,需要对父表中插入位置上的下一条存在的记录加gap锁,防止其他事务插入新的记录到这个gap中,从而导致当前事务的第二次INSERT成功.
