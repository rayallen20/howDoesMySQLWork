# 0. 前言

前文说过,INSERT语句在一般情况下不需要在内存中生成锁结构,并单纯依靠[隐式锁](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC22%E7%AB%A0%20%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE--%E9%94%81/3.%20MySQL%E4%B8%AD%E7%9A%84%E8%A1%8C%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/2.%20InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E9%94%81/2.%20InnoDB%E4%B8%AD%E7%9A%84%E8%A1%8C%E7%BA%A7%E9%94%81/5.%20%E9%9A%90%E5%BC%8F%E9%94%81.md)保护插入的记录.

不过当前事务在插入一条记录前,需要先定位到该记录在B+树中的位置.若该位置的下一条记录已经被加了gap锁(`next-key`锁也包含gap锁),则当前事务会为
该记录加上一种类型为[插入意向锁(`Insert Intention Lock`)](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC22%E7%AB%A0%20%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE--%E9%94%81/3.%20MySQL%E4%B8%AD%E7%9A%84%E8%A1%8C%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/2.%20InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E9%94%81/2.%20InnoDB%E4%B8%AD%E7%9A%84%E8%A1%8C%E7%BA%A7%E9%94%81/4.%20Insert%20Intention%20Lock.md)的锁,并且当前事务进入等待状态.

下面看一下在执行INSERT语句时,会在内存中生成锁结构的2种特殊情况
