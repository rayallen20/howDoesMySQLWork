# 1. 遇到重复键(duplicate key)

在插入一条新记录时,首先要做就是确定这条新记录应该插入到B+树的哪个位置.如果在确定位置时发现:

- 现有记录的主键与与待插入记录的主键相同
- 现有记录的唯一二级索引列与待插入记录的唯一二级索引列相同
  - 不过可以有多条记录的唯一二级索引列的值同时为NULL,这里不考虑这种情况

(以上2个条件为或关系),此时会报错

比如:

插入一条新记录,而且该记录的主键值已经包含在`hero`表中:

```
mysql> BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql> INSERT INTO hero VALUES(20, 'g关羽', '蜀');
ERROR 1062 (23000): Duplicate entry '20' for key 'hero.PRIMARY'
```

在生成报错信息前,其实还需要做一件非常重要的事情:对聚簇索引中`number = 20`的聚簇索引记录加S锁.加的锁的具体类型取决于隔离级别:

- 当隔离级别不大于`READ COMMITTED`时,加的是S型`LOCK_REC_NOT_GAP`锁
- 当隔离级别不小于`REPEATABLE READ`时,加的是S型`next-key`锁

注: 这里我猜测,原因如下:

正是因为这条`number = 20`的聚簇索引记录的存在,导致在该事务中,这条INSERT语句执行失败.因此若在当前事务提交之前,
允许修改这条`number = 20`的聚簇索引记录,就可能会导致当前事务中这条INSERT语句在重新执行时成功,从而违反了事务的隔离性.
因此,必须对这条`number = 20`的聚簇索引记录加S锁,从而阻止其他事务修改该记录.

若是唯一二级索引列的值重复,比如再把普通二级索引`idx_name`改为唯一二级索引`uk_name`:

```
mysql> ALTER TABLE hero DROP INDEX idx_name, ADD UNIQUE KEY uk_name (name);
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

然后执行:

```
mysql> BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql> INSERT INTO hero VALUES(30, 'c曹操', '魏');
ERROR 1062 (23000): Duplicate entry 'c曹操' for key 'hero.uk_name'
```

很显然,`hero`表之前就包含`name = 'c曹操'`的记录.若再插入一条`name = 'c曹操'`的新记录,虽然插入聚簇索引记录没问题,但是在插入`uk_name`
唯一二级索引记录时便会报错.在报错之前,同样会为已经存在的那条`name = 'c曹操'`的二级索引记录加一个S锁.

注意: **对唯一二级索引记录加锁时,无论是哪个隔离级别,只要在插入新记录时遇到唯一二级索引列重复,都会对已经在B+树中的那条唯一二级索引记录加`next-key`锁**
(这一点和聚簇索引的加锁是不同的).

注: 按理说在

- `READ UNCOMMITTED`
- `READ COMMITTED`

隔离级别下,不应该出现`next-key`锁.这主要是考虑到如果只加`LOCK_REC_NOT_GAP`锁,可能出现有多条记录的唯一二级索引列值都相同的情况.
详情可以看[这里](https://bugs.mysql.com/bug.php?id=68021)和[这里](https://bugs.mysql.com/bug.php?id=73170).

另外,在使用`INSERT ... ON DUPLICATE KEY ...`这样的语法来插入记录时,若遇到主键或唯一二级索引列的值重复,会对B+树中已存在的相同键值的记录加X锁,而不是S锁
