# 1. `redo`日志刷盘时机

前面说过,`MTR`运行过程中产生的一组`redo`日志,在`MTR`结束时,会被复制到`log buffer`中.可是这些日志不能一直在内存中呆着,
在一些情况下它们会被刷新到磁盘中.比如:

- `log buffer`空间不足时

    `log buffer`的大小是有限的(通过系统变量`innodb_log_buffer_size`指定),若不停地向这个有限大小的`log buffer`中写入日志,
    很快它就会被填满.InnoDB的设计者认为:若当前写入`log buffer`的`redo`日志量已经占满了`log buffer`总容量的50%左右,则
    需要把这些日志刷新到磁盘上.

    可以认为这是一种"被动"刷新`redo`日志的方式,因为它是由于`log buffer`空间不足而触发的.

- 事务提交时

    前面说过,之所以提出`redo`日志的概念,主要是因为它占用的空间少,且写入`redo`日志时是顺序写入的,引入`redo`日志后,
    虽然在事务提交时可以不把在`Buffer Pool`中被修改过的的页面(脏页)刷新到磁盘,但为确保持久性,
    **必须把修改这些页面对应的`redo`日志刷新到磁盘**(WAL机制),否则系统崩溃恢复时,无法恢复该事务对页面所做的修改.

    可以认为这是一种"主动"刷新`redo`日志的方式,因为它是由于事务提交而触发的.

- 将某个脏页刷新到磁盘前

    将某个脏页刷新到磁盘前,会保证先将该脏页对应的`redo`日志刷新到磁盘中(再强调一次,`redo`日志是顺序刷新的,
    所以在将某个脏页对应的`redo`日志从`redo log buffer`刷新到磁盘时,也会保证将在该`redo`日志之前产生的`redo`日志也刷新到磁盘中).

- 后台线程

    后台有一个线程,大约以每秒一次的频率将`log buffer`中的`redo`日志刷新到磁盘.
    注意这个线程是专门刷新`log buffer`中的`redo`日志的,而不是刷新`Buffer Pool`中的脏页的线程.
    这俩不是1个线程.

- 正常关闭服务器时

    在正常关闭服务器时,会将`log buffer`中的所有`redo`日志刷新到磁盘中.

- 做checkpoint时

    现在还没讲过checkpoint的概念,可以先不用理会.
