# 2. redo日志是什么

前文说过,InnoDB存储引擎是以页为单位来管理存储空间的,增删改查操作从本质上讲,都是在访问页面(包括读页面/写页面/创建新页面等操作).
在前文中讲`Buffer Pool`时说过:在真正访问页面之前,需要先把在磁盘中的页加载到内存中的`Buffer Pool`中,之后才可以访问.
在讲事务的时候强调过持久性:对于一个已经提交的事务,在事务提交后即使系统发生了崩溃,该事务对数据库中所做的更改也不能丢失.

若只在内存的`Buffer Pool`中修改了页面,假设在事务提交后突然发生了某个故障,导致内存中的数据都失效了,那么这个已经提交了的事务
对数据库中所做的更改也就跟着丢失了,这是不能接受的.假设,ATM机已经提示狗哥转账成功,但之后由于服务器出现故障,重启之后猫爷发现自己没收到钱,
猫爷就麻烦大了.此时问题来了:**如何保证持久性**?一个很简单的做法:在事务提交完成之前,把该事务修改的所有页面都刷新到磁盘.
不过这个简单粗暴的做法存在下面2个问题:

- 刷新一个完整的数据页太浪费了

    有时候仅仅修改了某个页面中的1个字节,但是由于InnoDB是以页为单位来进行磁盘I/O的,也就是说在该事务提交时,
    不得不将1个完整的页面从内存中刷新到磁盘.1个页面默认大小是16KB,
    只修改1个字节就要刷新16KB的数据到磁盘上,这显然是太浪费了.

- 随机I/O刷新起来比较慢

    1个事务可能包含很多语句,即使是1条语句也可能修改很多页面.该事务修改的这些页面可能并不相邻.
    这就意味着在将某个事务修改的`Buffer Pool`中的页面刷新到磁盘时,需要进行很多的随机I/O.
    随机I/O比顺序I/O要慢,尤其对于传统的机械硬盘来说.

这里再回过头来看要解决的问题: **只是想让已经提交了的事务(执行了`COMMIT`语句的事务)对数据库中数据所做的修改永久生效,
即使后来系统崩溃,在重启后也能把这种修改恢复过来**.

所以,其实**没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘,只需要把修的内容记录一下可以了**.比如,
某个事务将系统表空间中的第100号页面中偏移量为1000处的那个字节的值从1改成2.则只需要记录:

```
将第0号表空间的100号页面的偏移量为1000处的值更新为2
```

即可.这样在事务提交时,就会把上述内容刷新到磁盘中.即使之后系统崩溃了,重启之后只要按照上述步骤重新修改数据页,
那么该事务对数据库中所做的修改就可以被恢复出来,这样也就满足持久性的要求了.

在系统因崩溃而重启时,需要按上述步骤重新修改数据页,所以上述内容也被称为**重做日志**(`redo log`).更常态的叫法:`redo`日志.
相较于在事务提交时将所有修改过的内存中的页面刷新到磁盘中,只将该事务执行过程中产生的`redo`日志刷新到磁盘的好处主要有2个:

- `redo`日志占用的空间非常小

    在存储:

    - 表空间ID
    - 页号
    - 偏移量
    - 需要更新的值

    时,需要的存储空间很小.关于`redo`日志的格式后边会详细讲解,此处只需要知道一条`redo`日志占用的空间不是很大即可.

- `redo`日志是顺序写入磁盘的

    在执行事务的过程中,每执行1条语句,就可能产生若干条`redo`日志,这些日志是按照产生的顺序写入磁盘的,也就是使用顺序I/O.
    注: 这里说的顺序写入,是指`redo`日志的内容是顺序写入的,不是`redo`日志对应的操作是顺序写入的.

简单概括:

1. `redo`日志的主要作用:**保证事务的持久性**

   即使在事务提交后,真正的数据页还没落盘,若系统宕机,也能靠`redo`日志来恢复已提交事务的结果.

2. `redo`日志的写入方式: 顺序I/O

    用顺序I/O写日志的方式替代随机I/O写页面,提高性能.

3. 正常情况下,不会用`redo`日志来更新数据页,而是[刷新`Buffer Pool`中的脏页到磁盘](https://github.com/rayallen20/howDoesMySQLWork/blob/f67756ef76cd4d4dcedeb4d7f782eb74d3a39bba/%E7%AC%AC17%E7%AB%A0%20%E8%B0%83%E8%8A%82%E7%A3%81%E7%9B%98%E5%92%8CCPU%E7%9A%84%E7%9F%9B%E7%9B%BE--InnoDB%E7%9A%84Buffer%20Pool/2.%20InnoDB%E7%9A%84Buffer%20Pool/8.%20%E5%88%B7%E6%96%B0%E8%84%8F%E9%A1%B5%E5%88%B0%E7%A3%81%E7%9B%98.md).仅在系统崩溃后,需要恢复数据时才会用`redo`日志来更新数据页.

    也就是说,根据`redo`日志恢复数据页后,恢复完的数据页是在`Buffer Pool`中(处于脏页的状态),而不是直接刷新到磁盘的.
    `redo`日志只负责"重放修改",真正把数据写回磁盘的动作始终是`Buffer Pool`的刷脏流程来完成的.
    正常情况下,不会靠`redo`日志去更新数据页,而是直接[刷新`Buffer Pool`中的脏页到磁盘](https://github.com/rayallen20/howDoesMySQLWork/blob/f67756ef76cd4d4dcedeb4d7f782eb74d3a39bba/%E7%AC%AC17%E7%AB%A0%20%E8%B0%83%E8%8A%82%E7%A3%81%E7%9B%98%E5%92%8CCPU%E7%9A%84%E7%9F%9B%E7%9B%BE--InnoDB%E7%9A%84Buffer%20Pool/2.%20InnoDB%E7%9A%84Buffer%20Pool/8.%20%E5%88%B7%E6%96%B0%E8%84%8F%E9%A1%B5%E5%88%B0%E7%A3%81%E7%9B%98.md).
    `redo`日志只在崩溃恢复时才会被读取,用来重放还没写入磁盘的数据修改.
