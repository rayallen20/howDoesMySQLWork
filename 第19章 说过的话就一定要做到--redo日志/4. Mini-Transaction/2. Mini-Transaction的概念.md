# 2. `Mini-Transaction`的概念

- `Mini-Transaction`(MTR): 对底层页面进行一次原子访问的过程,称为一个`Mini-Transaction`

比如:

- 修改1次`Max Row ID`的值是1个`Mini-Transaction`
- 向某个索引对应的B+树中插入1条记录的过程也是1个`Mini-Transaction`

**一个MTR可以包含一组`redo`日志**,在进行崩溃恢复时,需要把这一组`redo`日志作为一个不可分割的整体来处理.

一个事务可以包含若干条语句,每一条语句又包含若干个MTR,每一个MTR又可以包含若干条`redo`日志.如下图示:

![事务、语句、MTR、redo日志之间的关系](./img/事务、语句、MTR、redo日志之间的关系.jpg)

注:

- 语句与MTR的1对多: 1条语句可能要修改多个页面(比如悲观插入),所以1条语句可能包含多个MTR
- MTR与`redo`日志的1对多: 1个页面中可能有多处要修改的地方(比如要修改同一个页面的元数据和用户记录链表),所以1个MTR可能包含多条`redo`日志

简单理解: 1个MTR就是1组针对同一个页面的`redo`日志的执行过程,这一组`redo`日志在崩溃恢复时,要么全部执行,要么全部不执行(即概念中所说的"原子访问").

假设: 现有一条`UPDATE`语句,它产生了3个MTR,分别为:

- MTR1
- MTR2
- MTR3

每个MTR中又有3条redo日志,结构如下:

- MTR1

    - `redo`1-1
    - `redo`1-2
    - `redo`1-3
    - `MLOG_MULTI_REC_END`

- MTR2

    - `redo`2-1
    - `redo`2-2
    - `redo`2-3
    - `MLOG_MULTI_REC_END`

- MTR3

    - `redo`3-1
    - `redo`3-2
    - `redo`3-3
    - `MLOG_MULTI_REC_END`

在崩溃恢复时,是有可能出现:MTR1/MTR3恢复成功,MTR2恢复失败的(比如MTR2的`redo`日志不完整).此时:

- MTR1和MTR3的修改会体现在恢复后的数据页上
- MTR2的修改则完全丢弃,好像从来没发生过

即:MTR是恢复的最小原子单元,保证了**页级别的原子性**.但是跨MTR是不保证原子性的.

而`redo`日志是以MTR为粒度的,`redo`日志的职责为:

- 系统崩溃后,每个页都能恢复到一致的状态
- 若1个MTR日志不完整,则该MTR中的`redo`日志整组丢弃

但是,`redo`日志不保证事务的原子性,它只保证**页内部不会撕裂**

事务的原子性需要依靠`undo`日志来保证.

这里要再解释一下**页级别的原子性**这句话.还是以页分裂为例解释:页分裂这种操作,涉及到对原页/新页/父页的修改.
在恢复时,页分裂通常会拆成多个MTR:

- `MTR1`: 准备新页并局部完成分裂
  - 分配并格式化新页(文件段/页头初始化等)
  - 从旧页搬移一部分记录到新页
  - 修正叶子层的左右兄弟指针
  - 维护两页的页目录与`PAGE_N_HEAP`/`PAGE_HEAP_TOP`/`PAGE_N_DIR_SLOTS`等
  - 提交`MTR`(此刻父页还没有任何修改,结构对外可被视为"尚未分裂")
- `MTR2`: 在父页插入分隔键/指针
  - 给父页插入新分隔键,挂上指向新页的`child`指针
  - 维护父页的目录/页头计数等(同样不为这些字段单独写`redo`日志,这个维护属于动作的派生结果)
  - 提交`MTR2`(至此分裂对外生效)
    - 若父页也满了,再触发新的"父页分裂序列"(`MTR3`/`MTR4`...),逐层向上

在这个过程中,`MTR1`就是在1个`MTR`内操作了多个页面的.也就是说:

- 在同一个`MTR`中,有多条带不同页号的`MLOG`记录,最后以`MLOG_MULTI_REC_END`作为该`MTR`的结束标记
- 恢复时要么把这一段全部重放,要么(若尾部不完整)一条都不重放

这里说的**页级别的原子性**,不是指单个页的原子性,而是指1个`MTR`操作的多个页面之间保证原子性.
