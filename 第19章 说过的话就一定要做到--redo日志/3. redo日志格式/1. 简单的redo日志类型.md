# 1. 简单的`redo`日志类型

这里先通过一个例子引出简单的`redo`日志类型的概念.

前文介绍InnoDB的[记录行格式](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC4%E7%AB%A0%20%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7--InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/3.%20InnoDB%E8%A1%8C%E6%A0%BC%E5%BC%8F/2.%20COMPACT%E8%A1%8C%E6%A0%BC%E5%BC%8F/2.%20%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE.md)
时讲过,若没有为某个表显式地定义主键,且该表中也没有定义不允许存储`NULL`值的`UNIQUE`键,
则InnoDB会自动为表添加一个名为`row_id`的隐藏列作为主键.为`row_id`隐藏列赋值的方式如下:

- 服务器会在内存中维护一个全局变量,每当向某个包含隐藏的`row_id`隐藏列的表中插入一条记录时,就会把该全局变量的值作为新记录的`row_id`列的值,并把该全局变量的值自增1
- 每当该全局变量的值为256的倍数时,则会将该变量的值刷新到系统表空间的页号为7的页面中的[`Data Directory Header`结构](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC9%E7%AB%A0%20%E5%AD%98%E6%94%BE%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%A4%A7%E6%B1%A0%E5%AD%90--InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/3.%20%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4/1.%20%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/1.%20InnoDB%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8/5.%20%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4%E4%B8%AD%E9%A1%B5%E5%8F%B7%E4%B8%BA7%E7%9A%84%E9%A1%B5%E9%9D%A2.md)中的`Max Row ID`的属性中
  - 之所以不是每次自增该全局变量时就将该值刷新到磁盘,就是为了避免频繁刷盘
- 当系统启动时,会将[`Data Directory Header`结构](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC9%E7%AB%A0%20%E5%AD%98%E6%94%BE%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%A4%A7%E6%B1%A0%E5%AD%90--InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/3.%20%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4/1.%20%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/1.%20InnoDB%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8/5.%20%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4%E4%B8%AD%E9%A1%B5%E5%8F%B7%E4%B8%BA7%E7%9A%84%E9%A1%B5%E9%9D%A2.md)中的`Max Row ID`属性的值加载到内存中,并将该值加上256之后赋值给前边提到的全局变量
  - 因为在系统上次关机时,该全局变量的值可能大于磁盘页面中的`Max Row ID`属性值,但是还没大到256的倍数(即`全局变量的值 < Max Row ID + 256`,也就是还没有触发刷盘的机制)

`Max Row ID`属性占用的存储空间是8字节.当:

- 某个事务向某个包含`row_id`隐藏列的表插入一条记录
- 且为该记录分配的`row_id`值为256的倍数时

就会向系统表空间页号为7的页面的相应偏移量处写入8字节的值.但是,这个写入实际上是在`Buffer Pool`中完成的,
还需要把这次对该页面的修改以`redo`日志的形式记录下来.这样在事务提交之后,即使系统崩溃了,也可以将该页面恢复成崩溃前的状态,
从而保证为新插入的记录分配的`row_id`值是正确的.在这种对页面的修改是极其简单的情况下,`redo`日志中只需要
记录"**在某个页面的某个偏移量处修改了几个字节的值,具体修改后的内容是什么**"(也就是`5W1H`中的`Where`和`What`)即可.
InnoDB的设计这把这种**极其简单的`redo`日志称为物理日志**,并且根据在页面中写入数据的多少,划分了几种不同的`redo`日志类型:

- `MLOG_1BYTE`(`type`字段对应的十进制数字为1):表示在页面的某个偏移量处写入1个字节的`redo`日志类型
- `MLOG_2BYTE`(`type`字段对应的十进制数字为2):表示在页面的某个偏移量处写入2个字节的`redo`日志类型
- `MLOG_4BYTE`(`type`字段对应的十进制数字为4):表示在页面的某个偏移量处写入4个字节的`redo`日志类型
- `MLOG_8BYTE`(`type`字段对应的十进制数字为8):表示在页面的某个偏移量处写入8个字节的`redo`日志类型
- `MLOG_WRITE_STRING`(`type`字段对应的十进制数字为30):表示在页面的某个偏移量处写入一个字节序列的`redo`日志类型

本例中提到的`Max Row ID`属性实际占用8字节的存储空间,所以在修改页面中的该属性时,记录的`redo`日志的类型为`MLOG_8BYTE`,
`redo`日志类型为`MLOG_8BYTE`的结构如下图示:

![`MLOG_8BYTE`类型的redo日志结构](img/MLOG_8BYTE类型的redo日志结构.jpg)

注: `offset`字段占用2Bytes

其余的`MLOG_1BYTE`/`MLOG_2BYTE`/`MLOG_4BYTE`类型的`redo`日志结构和`MLOG_8BYTE`的日志结构类似,只是具体数据中包含的字节数量不同.
`MLOG_WRITE_STRING`类型的`redo`日志表示写入一个字节序列,但是因为不能确定写入的具体数据占用多少字节,
所以需要在日志结构中添加一个`len`字段,如下图示:

![`MLOG_WRITE_STRING`类型的redo日志结构](./img/MLOG_WRITE_STRING类型的redo日志结构.jpg)

注: `len`字段占用2Bytes

注: 只要将`MLOG_WRITE_STRING`类型的`redo`日志的`len`字段填充上1/2/4/8这些数字,就可以分别替代

- `MLOG_1BYTE`
- `MLOG_2BYTE`
- `MLOG_4BYTE`
- `MLOG_8BYTE`

这些类型的`redo`日志,为什么还要多此一举设计这么多类型? 这是为了节省空间,以上4种类型的`redo`日志
与`MLOG_WRITE_STRING`类型的`redo`日志相比,少了2字节的`len`字段,所以从`redo`日志的设计原则上讲就是:
能不写`len`字段就不写`len字段`,能省一个字节是一个字节(这里的"省"我认为其目的是为了减小`redo`日志的体积).
