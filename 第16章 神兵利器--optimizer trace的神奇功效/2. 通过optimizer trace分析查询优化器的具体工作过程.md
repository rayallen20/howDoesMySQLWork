# 2. 通过`optimizer trace`分析查询优化器的具体工作过程

这里使用`#`后跟随注释的形式来解释优化过程中一些比较重要的点

同时我把JSON格式的内容单独拿出来了,为了便于阅读和分析

- `QUERY`部分如下:

```
*************************** 1. row ***************************
# 分析的查询语句是什么
                            QUERY: SELECT *
FROM single_table
WHERE 
    key1 > 'z'
AND
    key2 < 1000000
AND
    key3 IN ('a', 'b', 'c')
AND
    common_field = 'abc'
```

- `TRACE`部分如下(`TRACE`部分表示优化的具体过程):

```json
{
  "steps": [
    {
      "join_preparation": {       # prepare阶段
        "select#": 1,
        "steps": [
          {
            "IN_uses_bisection": true
          },
          {
            "expanded_query": "/* select#1 */ select `single_table`.`id` AS `id`,`single_table`.`key1` AS `key1`,`single_table`.`key2` AS `key2`,`single_table`.`key3` AS `key3`,`single_table`.`key_part1` AS `key_part1`,`single_table`.`key_part2` AS `key_part2`,`single_table`.`key_part3` AS `key_part3`,`single_table`.`common_field` AS `common_field` from `single_table` where ((`single_table`.`key1` > 'z') and (`single_table`.`key2` < 1000000) and (`single_table`.`key3` in ('a','b','c')) and (`single_table`.`common_field` = 'abc'))"
          }
        ]
      }
    },
    {
      "join_optimization": {    # optimize阶段
        "select#": 1,
        "steps": [
          {
            "condition_processing": {   # 处理搜索条件
              "condition": "WHERE",
              # 原始搜索条件
              "original_condition": "((`single_table`.`key1` > 'z') and (`single_table`.`key2` < 1000000) and (`single_table`.`key3` in ('a','b','c')) and (`single_table`.`common_field` = 'abc'))",
              "steps": [
                {
                  # 等值传递转换
                  "transformation": "equality_propagation",
                  "resulting_condition": "((`single_table`.`key1` > 'z') and (`single_table`.`key2` < 1000000) and (`single_table`.`key3` in ('a','b','c')) and multiple equal('abc', `single_table`.`common_field`))"
                },
                {
                  # 常量传递转换
                  "transformation": "constant_propagation",
                  "resulting_condition": "((`single_table`.`key1` > 'z') and (`single_table`.`key2` < 1000000) and (`single_table`.`key3` in ('a','b','c')) and multiple equal('abc', `single_table`.`common_field`))"
                },
                {
                  # 去除没用的条件
                  "transformation": "trivial_condition_removal",
                  "resulting_condition": "((`single_table`.`key1` > 'z') and (`single_table`.`key2` < 1000000) and (`single_table`.`key3` in ('a','b','c')) and multiple equal('abc', `single_table`.`common_field`))"
                }
              ]
            }
          },
          {
            # 替换虚拟生成列
            "substitute_generated_columns": {
            }
          },
          {
            # 表的依赖信息
            "table_dependencies": [
              {
                "table": "`single_table`",
                "row_may_be_null": false,
                "map_bit": 0,
                "depends_on_map_bits": [
                ]
              }
            ]
          },
          {
            "ref_optimizer_key_uses": [
            ]
          },
          {
            # 预估不同单表访问方法的成本
            "rows_estimation": [
              {
                "table": "`single_table`",
                "range_analysis": {
                  # 全表扫描的行数及成本
                  "table_scan": {
                    "rows": 10200,
                    "cost": 1119.1
                  },
                  # 分析可能使用的索引
                  "potential_range_indexes": [
                    {
                      # 分析主键索引
                      "index": "PRIMARY",
                      # 不可用
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      # 分析索引 uk_key2
                      "index": "uk_key2",
                      # 可能被使用
                      "usable": true,
                      "key_parts": [
                        "key2"
                      ]
                    },
                    {
                      # 分析索引 idx_key3
                      "index": "idx_key3",
                      # 可能被使用
                      "usable": true,
                      "key_parts": [
                        "key3",
                        "id"
                      ]
                    },
                    {
                      # 分析索引 idx_key_part
                      "index": "idx_key_part",
                      # 不可用
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      # 分析索引 idx_key1
                      "index": "idx_key1",
                      # 可能被使用
                      "usable": true,
                      "key_parts": [
                        "key1",
                        "id"
                      ]
                    }
                  ],
                  "setup_range_conditions": [
                  ],
                  "group_index_range": {
                    "chosen": false,
                    "cause": "not_group_by_or_distinct"
                  },
                  "skip_scan_range": {
                    "potential_skip_scan_indexes": [
                      {
                        "index": "uk_key2",
                        "usable": false,
                        "cause": "query_references_nonkey_column"
                      },
                      {
                        "index": "idx_key3",
                        "usable": false,
                        "cause": "query_references_nonkey_column"
                      },
                      {
                        "index": "idx_key1",
                        "usable": false,
                        "cause": "query_references_nonkey_column"
                      }
                    ]
                  },
                  # 分析各种可能使用的索引的成本
                  "analyzing_range_alternatives": {
                    "range_scan_alternatives": [
                      {
                        # 使用索引uk_key2的成本分析
                        "index": "uk_key2",
                        # 使用索引uk_key2的扫描区间
                        "ranges": [
                          "NULL < key2 < 1000000"
                        ],
                        # 是否使用index dive的方式分析成本
                        "index_dives_for_eq_ranges": true,
                        # 使用该索引获取的记录是否按主键排序
                        "rowid_ordered": false,
                        # 是否使用多范围读取(MRR)
                        "using_mrr": false,
                        # 是否是覆盖索引
                        "index_only": false,
                        "in_memory": 0,
                        # 使用该索引获取的记录条数
                        "rows": 10000,
                        # 使用该索引的成本
                        "cost": 11001,
                        # 是否选择该索引
                        "chosen": false,
                        "cause": "cost"
                      },
                      {
                        # 使用索引idx_key3的成本分析
                        "index": "idx_key3",
                        # 使用索引idx_key3的扫描区间
                        "ranges": [
                          "key3 = 'a'",
                          "key3 = 'b'",
                          "key3 = 'c'"
                        ],
                        # 是否使用index dive的方式分析成本
                        "index_dives_for_eq_ranges": true,
                        # 使用该索引获取的记录是否按主键排序
                        "rowid_ordered": false,
                        # 是否使用多范围读取(MRR)
                        "using_mrr": false,
                        # 是否是覆盖索引
                        "index_only": false,
                        "in_memory": 0,
                        # 使用该索引获取的记录条数
                        "rows": 3,
                        # 使用该索引的成本
                        "cost": 6.31,
                        # 是否选择该索引
                        "chosen": true
                      },
                      {
                        # 使用索引idx_key1的成本分析
                        "index": "idx_key1",
                        # 使用索引idx_key1的扫描区间
                        "ranges": [
                          "'z' < key1"
                        ],
                        # 是否使用index dive的方式分析成本
                        "index_dives_for_eq_ranges": true,
                        # 使用该索引获取的记录是否按主键排序
                        "rowid_ordered": false,
                        # 是否使用多范围读取(MRR)
                        "using_mrr": false,
                        # 是否是覆盖索引
                        "index_only": false,
                        "in_memory": 0,
                        # 使用该索引获取的记录条数
                        "rows": 327,
                        # 使用该索引的成本
                        "cost": 360.71,
                        # 是否选择该索引
                        "chosen": false,
                        "cause": "cost"
                      }
                    ],
                    # 分析使用索引合并的成本
                    "analyzing_roworder_intersect": {
                      "usable": false,
                      "cause": "too_few_roworder_scans"
                    }
                  },
                  # 对于该单表查询最优的访问方法
                  "chosen_range_access_summary": {
                    "range_access_plan": {
                      "type": "range_scan",
                      "index": "idx_key3",
                      "rows": 3,
                      "ranges": [
                        "key3 = 'a'",
                        "key3 = 'b'",
                        "key3 = 'c'"
                      ]
                    },
                    "rows_for_plan": 3,
                    "cost_for_plan": 6.31,
                    "chosen": true
                  }
                }
              }
            ]
          },
          {
            # 分析各种可能的执行计划
            # (对于多表查询,可能有多种不同的方案;单表查询的方案在选取索引时就分析过了,此处直接选取索引idx_key3即可)
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ],
                "table": "`single_table`",
                "best_access_path": {
                  "considered_access_paths": [
                    {
                      "rows_to_scan": 3,
                      "access_type": "range",
                      "range_details": {
                        "used_index": "idx_key3"
                      },
                      "resulting_rows": 3,
                      "cost": 6.61,
                      "chosen": true
                    }
                  ]
                },
                "condition_filtering_pct": 100,
                "rows_for_plan": 3,
                "cost_for_plan": 6.61,
                "chosen": true
              }
            ]
          },
          {
            # 尝试给查询添加一些其他的查询条件
            "attaching_conditions_to_tables": {
              "original_condition": "((`single_table`.`common_field` = 'abc') and (`single_table`.`key1` > 'z') and (`single_table`.`key2` < 1000000) and (`single_table`.`key3` in ('a','b','c')))",
              "attached_conditions_computation": [
              ],
              "attached_conditions_summary": [
                {
                  "table": "`single_table`",
                  "attached": "((`single_table`.`common_field` = 'abc') and (`single_table`.`key1` > 'z') and (`single_table`.`key2` < 1000000) and (`single_table`.`key3` in ('a','b','c')))"
                }
              ]
            }
          },
          {
            "finalizing_table_conditions": [
              {
                "table": "`single_table`",
                "original_table_condition": "((`single_table`.`common_field` = 'abc') and (`single_table`.`key1` > 'z') and (`single_table`.`key2` < 1000000) and (`single_table`.`key3` in ('a','b','c')))",
                "final_table_condition   ": "((`single_table`.`common_field` = 'abc') and (`single_table`.`key1` > 'z') and (`single_table`.`key2` < 1000000) and (`single_table`.`key3` in ('a','b','c')))"
              }
            ]
          },
          {
            # 再稍微改进一下执行计划
            "refine_plan": [
              {
                "table": "`single_table`",
                "pushed_index_condition": "(`single_table`.`key3` in ('a','b','c'))",
                "table_condition_attached": "((`single_table`.`common_field` = 'abc') and (`single_table`.`key1` > 'z') and (`single_table`.`key2` < 1000000))"
              }
            ]
          }
        ]
      }
    },
    {
      # execute阶段
      "join_execution": {
        "select#": 1,
        "steps": [
        ]
      }
    }
  ]
}
```

- `MISSING_BYTES_BEYOND_MAX_MEM_SIZE`部分与`INSUFFICIENT_PRIVILEGES`部分如下:

```
# 因优化过程文本太多而丢弃的文本字节大小,值为0时表示没有丢弃
MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0
# 权限字段
          INSUFFICIENT_PRIVILEGES: 0
1 row in set (0.00 sec)
```

优化过程大致分为3个阶段:

- `prepare`阶段
- `optimize`阶段
- `execute`阶段

之前讲的基于成本的优化主要集中在`optimize`阶段:

- 对于单表查询来说,主要关注的是`optimize`阶段的`rows_estimation`(预估不同单表访问方法的成本)过程.该过程深入分析了对单表查询的各种执行方案的成本
- 对于多表连接查询来说,更多需要关注`considered_execution_plans`(分析各种可能的执行计划)过程.该过程中会写明各种不同的表连接顺序所对应的成本.

优化器最终会选择成本最低的那种方案来作为最终的执行计划,也就是使用`EXPLAIN`语句所展现出的那种方案.

当不理解使用`EXPLAIN`语句展示出的对某个查询的执行计划时,可使用`optimizer trace`功能来详细了解每一种执行方案对应的成本.

注: 本例中,`rows_estimation`过程分析的都是`range`访问方法对应的成本,并没有涉及到`ref`访问方法.对于`ref`访问方法来说,
在计算回表操作的I/O成本时,存在天花板(之前提到过).`ref`访问方法对应的成本是被单独计算的,计算过程体现在
`considered_execution_plans.best_access_path.considered_access_paths`中.本例中没有使用`ref`访问方法,
所以在`optimize trace`的输出中没有体现.
