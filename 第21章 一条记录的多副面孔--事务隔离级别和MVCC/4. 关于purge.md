# 4. 关于`purge`

- `insert undo`日志在事务提交之后就可以释放掉了,而`update undo`日志由于还需要支持MVCC,因此不能立即删除

    在讲`undo`日志时说过,1个事务写的1组`undo`日志中都有一个[`Undo Log Header`](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC20%E7%AB%A0%20%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E--undo%E6%97%A5%E5%BF%97/7.%20Undo%E6%97%A5%E5%BF%97%E7%9A%84%E5%85%B7%E4%BD%93%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B/3.%20Undo%20Log%20Header.md)部分,这个`Undo Log Header`中有一个名为`TRX_UNDO_HISTORY_NODE`的属性,
    表示一个名为History链表的节点.当一个事务提交之后,就会把该事务执行过程中产生的这一组`update undo`日志插入到`History`链表的头部
    
    在讲`undo`日志时还说过,每个回滚段都对应一个名为[`Rollback Segment Header`](https://github.com/rayallen20/howDoesMySQLWork/blob/main/%E7%AC%AC20%E7%AB%A0%20%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E--undo%E6%97%A5%E5%BF%97/9.%20%E5%9B%9E%E6%BB%9A%E6%AE%B5/1.%20%E5%9B%9E%E6%BB%9A%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5.md)的页面,该页面中有以下2个属性:
    
    - `TRX_RSEG_HISTORY`: 表示History链表的基节点
    - `TRX_RSEG_HISTORY_SIZE`: 表示History链表占用的页面数量
    
    也就是说**每个回滚段都有一个History链表**,一个事务在某个回滚段中写入的一组`update undo`日志在该事务提交之后,就会加入到该回滚段的
    `History`链表中.系统中可能存在很多回滚段,这也就意味着可能存在很多个History链表.
    
    不过这些加入到History链表的`update undo`日志所占用的存储空间也没有被释放,但它们也不能一直存在,否则就需要很大的存储空间来存放这些`undo`日志.

- 为了支持MVCC,`delete mark`操作仅仅是在记录上打一个删除标记,并没有真正将记录删除

    在一组`undo`日志中的`Undo Log Header`部分有一个名为`TRX_UNDO_DEL_MARKS`的属性,用来标记本组`undo`日志中是否包含因
    `delete mark`操作而产生的`undo`日志.
    
    这些打了删除标记的记录也不能一直存在,否则也需要很大的存储空间来存放这些`undo`日志.

为了节约存储空间,应该在合适的时候把`update undo`日志以及仅仅被标记为删除的记录彻底删除掉,这个删除操作就称为`purge`.
不过问题的关键在于: 这个合适的时候到底是什么时候?

`update undo`日志和被标记为删除的记录只是为了支持`MVCC`而存在的,**只要系统中最早产生的那个`ReadView`不再访问这些`undo`日志和被标记为删除的记录,
那么这些`undo`日志和被标记为删除的记录就可以被彻底删除了**.`ReadView`在什么时候才肯定不会访问某个事务执行过程中产生的`undo`日志呢?
只要能保证生成`ReadView`时某个事务已经提交,那么该`ReadView`肯定就不需要访问该事务运行过程中产生的`undo`日志了(因为该事务所改动的记录的最新版本均对该`ReadView`可见).

InnoDB的设计者为此做了2件事:

- 在一个事务提交时,会为该事务生成一个名为`事务no`的值,该值用来表示事务提交的顺序,先提交的事务的`事务no`值小,后提交的事务的`事务no`值大

    一组`undo`日志中对应的`Undo Log Header`部分中,有一个名为`TRX_UNDO_TRX_NO`的属性.当事务提交时,就把该事务对应的`事务no值`填到该属性中.
    因为`事务no`代表着各个事务提交的顺序,而History链表又是按照事务提交的顺序来排列各组`undo`日志的,所以History链表中的各组`undo`日志
    也是按照对应的`事务no`来排序的(`事务no`大的在前,`事务no`小的在后).
    
    注意: 
    
    - `事务no`描述的是事务的提交顺序
    - `事务id`描述的是事务的创建顺序

- 一个`ReadView`结构除了包含前面讲过的几个属性之外,还包含一个`事务no`的属性.在生成一个`ReadView`时,会把`当前系统中最大的事务no值 + 1`的值赋给该属性

InnoDB的设计者把当前系统中所有的`ReadView`按照创建时间连成了一个链表,当执行`purge`操作时(这个`purge`操作是在专门的后台线程中执行的),
就把系统中最早生成的`ReadView`给取出来.如果当前系统中不存在`ReadView`,就现场创建一个(新创建的这个`ReadView`的`事务no`值肯定比当前已经提交的事务的`事务no`值大).
然后从各个回滚段的History链表中取出`事务no`值较小的各组`undo`日志:

- 若`一组undo日志的事务no值 < 当前系统最早生成的ReadView的事务no值`: 就意味着该组`undo`日志已经没有用了,就会从History链表中移除,并且释放掉它们占用的存储空间
  - 因为该组`undo`日志的更新结果已经对系统中当前所有活跃事务可见了,更新前的快照已经没有任何事务会访问它们了,因此可以删除该组`undo`日志了
- 若该组`undo`日志包含因`delete mark`操作而产生的`undo`日志(`TRX_UNDO_DEL_MARKS`属性值为1),则也需要将对应的标记为删除的记录给彻底删除
  - 因为删除数据的事务提交的时刻早于当前系统中最早开启的事务开启的时刻,所以该删除操作的结果对当前系统中所有活跃事务都是可见的,因此可以将这些被标记为删除的记录彻底删除

注意: 当前系统中最早生成的`ReadView`决定了`purge`操作中可以清理哪些`update undo`日志和打了删除标记的记录.若某个事务使用`REPEATABLE READ`隔离级别,
则该事务会一直复用最初产生的`ReadView`.假如该事务运行了很久,一直没有提交,那么最早生成的`ReadView`会一直不释放,系统中的`update undo`日志和
打了删除标记的记录就会越来越多,表空间对应的文件也会越来越大,一条记录的版本链将会越来越长,从而影响系统性能
