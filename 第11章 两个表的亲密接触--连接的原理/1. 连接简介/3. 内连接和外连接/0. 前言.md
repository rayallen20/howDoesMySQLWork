# 0. 前言

先创建两个有现实意义的表如下:

```
mysql> CREATE TABLE student (
    ->     number INT NOT NULL AUTO_INCREMENT COMMENT '学号',
    ->     name VARCHAR(5) COMMENT '姓名',
    ->     major VARCHAR(30) COMMENT '专业',
    ->     PRIMARY KEY (number)
    -> ) Engine=InnoDB CHARSET=utf8mb4 COMMENT '学生信息表';
Query OK, 0 rows affected (0.02 sec)
```

```
mysql> CREATE TABLE score (
    ->     number INT COMMENT '学号',
    ->     subject VARCHAR(30) COMMENT '科目',
    ->     score TINYINT COMMENT '成绩',
    ->     PRIMARY KEY (number, score)
    -> ) Engine=InnoDB CHARSET=utf8mb4 COMMENT '学生成绩表';
Query OK, 0 rows affected (0.01 sec)
```

向2张表中分别插入了一些数据后如下:

```
mysql> SELECT * FROM student;
+----------+--------+--------------------------+
| number   | name   | major                    |
+----------+--------+--------------------------+
| 20180101 | 张三   | 软件学院                 |
| 20180102 | 李四   | 计算机科学与工程         |
| 20180103 | 王五   | 计算机科学与工程         |
+----------+--------+--------------------------+
3 rows in set (0.00 sec)
```

```
mysql> SELECT * FROM score;
+----------+-------------------------+-------+
| number   | subject                 | score |
+----------+-------------------------+-------+
| 20180101 | MySQL是怎样运行的       |    78 |
| 20180101 | 深入浅出MySQL           |    88 |
| 20180102 | 深入浅出MySQL           |    98 |
| 20180102 | MySQL是怎样运行的       |   100 |
+----------+-------------------------+-------+
4 rows in set (0.00 sec)
```

现在,要想把每个学生的考试成绩都查询出来,就需要进行2表连接了(因为`score`中没有姓名信息,所以不能单纯只查询`score`表).
连接过程就是从`student`表中取出记录,然后在`score`表中查找`number`相同的成绩记录,所以过滤条件就是`student.number = score.number`.
查询语句如下:

```sql
SELECT *
FROM student, score
WHERE student.number = score.number;
```

```
mysql> SELECT *
    -> FROM student, score
    -> WHERE student.number = score.number;
+----------+--------+--------------------------+----------+-------------------------+-------+
| number   | name   | major                    | number   | subject                 | score |
+----------+--------+--------------------------+----------+-------------------------+-------+
| 20180101 | 张三   | 软件学院                 | 20180101 | MySQL是怎样运行的       |    78 |
| 20180101 | 张三   | 软件学院                 | 20180101 | 深入浅出MySQL           |    88 |
| 20180102 | 李四   | 计算机科学与工程         | 20180102 | 深入浅出MySQL           |    98 |
| 20180102 | 李四   | 计算机科学与工程         | 20180102 | MySQL是怎样运行的       |   100 |
+----------+--------+--------------------------+----------+-------------------------+-------+
4 rows in set (0.00 sec)
```

去掉重复的字段:

```sql
SELECT s1.number, s1.name, s2.subject, s2.score
FROM student AS s1, score AS s2
WHERE s1.number = s2.number;
```

```
mysql> SELECT s1.number, s1.name, s2.subject, s2.score
    -> FROM student AS s1, score AS s2
    -> WHERE s1.number = s2.number;
+----------+--------+-------------------------+-------+
| number   | name   | subject                 | score |
+----------+--------+-------------------------+-------+
| 20180101 | 张三   | MySQL是怎样运行的       |    78 |
| 20180101 | 张三   | 深入浅出MySQL           |    88 |
| 20180102 | 李四   | 深入浅出MySQL           |    98 |
| 20180102 | 李四   | MySQL是怎样运行的       |   100 |
+----------+--------+-------------------------+-------+
4 rows in set (0.00 sec)
```

从上述查询结果中可以看到,各个同学对应的各科成绩就都被查出来了.可是有个问题:王五同学(也就是学号为`20180103`的同学)
因为某些原因没有参加考试,所以在`score`表中没有对应的成绩记录.如果老师想查看所有学生的考试成绩,即使是缺考的学生,
他们的成绩也应该展示出来,但是到目前为止介绍的连接查询是无法完成这样的需求的.

这个需求的本质问题是: **针对驱动表中的某条记录,即使在被驱动表中没有找到与之匹配的记录,也仍然需要把该驱动表记录加入到结果集中**.
为解决该问题,就有了内连接和外连接的概念:

- 对于内连接的两个表: 若驱动表中的记录在被驱动表中找不到匹配的记录,则该记录不会加入到最后的结果集(之前提到的连接都是内连接)
- 对于外连接的两个表: 即使驱动表中的记录在被驱动表中没有匹配的记录,也仍然需要加入到结果集

在MySQL中,根据选取驱动表的不同,外连接可以细分为2种:

- 左外连接: 选取左侧的表为驱动表
- 右外连接: 选取右侧的表为驱动表

仍然存在问题: **即使使用外连接,有的需求也不需要把驱动表的全部记录都加入到结果集中**.

这时候问题就出现了: 有时候匹配失败要加入结果集,有时候又不要加入结果集.因此,需要把过滤条件分为2种.也就是说,过滤条件在不同的地方有不同的语义:

- WHERE子句中的过滤条件

不论是内连接还是外连接,凡是不符合WHERE子句中的过滤条件的记录都不会被加入最后的结果集.
即: 不符合WHERE子句中的过滤条件的记录,不论是驱动表还是被驱动表,都不会加入到结果集中.

- ON子句中的过滤条件

对于外连接的驱动表的记录来说,若无法在被驱动表中找到匹配ON子句中的过滤条件的记录,那么该记录仍然会被加入到结果集中,
对应的被驱动表记录的各个字段使用NULL值填充

即: 不符合ON子句中的过滤条件的记录,只有驱动表的记录会被加入到结果集中,被驱动表的记录不会加入到结果集中.

注意: ON子句是专门为"**外连接**驱动表中的记录在被驱动表找不到匹配记录时是否应该把该记录加入结果集中"这个场景而提出的.
所以如果把ON子句放到内连接中,MySQL会把它和WHERE子句一样对待(因为ON子句的使用场景并不是内连接).
即: **内连接中的WHERE子句和ON子句是等价的**.

注: 左外连接和右外连接分别简称为左连接和右连接,所以后续提到的"左连接"和"右连接"都是指左外连接和右外连接.
