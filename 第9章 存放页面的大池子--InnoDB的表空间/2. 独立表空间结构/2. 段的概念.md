# 2. 段的概念

为什么需要提出一个区(extent)的概念呢? 以前分析问题的套路是: 表中的记录存储到页里面,然后页作为节点组成B+树,这个B+树就是索引.
然后讲一些聚簇索引和二级索引的区别.这个思路听起来并没有什么问题.

是的,如果表中数据量很少,比如说表中只有几十/几百条数据,的确用不到extent的概念,因为简单的几个页就能把对应的数据存储起来.
但是如果表中的数据量慢慢变大了,只在页这个层级上看待存储和查找这两个问题,层级就太低了.

表里的记录多了又怎样? B+树的每一层中的页都会形成一个双向链表,
`File Header`中的`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`字段就是为了形成双向链表而设置的啊.

是的,从理论上说,不引入extent的概念只使用页的概念对存储引擎的运行并没有什么影响,但是来考虑下面这个场景:

每向表中插入一条记录,本质上就是向该表的聚簇索引以及所有二级索引代表的B+树的节点中插入数据.
而B+树每一层中的页都会形成一个双向链表,如果是以页为单位来分配存储空间,双向链表相邻的两个页之间的物理位置可能离得非常远.
使用B+树来减少记录的扫描行数的过程是通过一些搜索条件到B+树中定位到第1条符合条件的记录(对于全表扫描来说就就是定位到第1个叶子节点的第1条记录),
然后沿着由记录组成的单向链表和由数据页组成的双向链表一直扫描就可以了.如果双向链表中相邻的两个页的物理位置不连续,对于传统的机械硬盘来说,
需要重新定位磁头位置,也就是会产生随机I/O,这样会影响磁盘的性能,所以应该尽量让页面链表中相邻的页的物理位置也相邻,
这样在扫描叶子节点中大量的记录时才可以使用顺序I/O.

注: 这里说的是"尽量",其实页面链表中相邻的页的物理位置不相邻并不会让程序无法运行,只是会影响性能.

所以,为了让B+树同一层内的页面链表中相邻的页的物理位置尽量相邻,就需要引入extent的概念.

1个extent就是在物理位置上连续的64个页(extent中页面的页号都是连续的).**在表中的数据量很大时,
为某个索引分配空间的时候就不再按照页为单位分配了,而是按照extent为单位分配(即1次分配64个页)**.
甚至在表中的数据非常非常多时,可以一次性分配多个连续的extent.
虽然可能造成一点空间的浪费(数据不足以填满整个extent),但是从性能角度看,可以消除很多随机I/O,收益大于损失.

事情到这里还没有结束.在使用B+树进行查询时只是在扫描叶子节点中的记录,而如果不区分叶子节点和非叶子节点,
统统把节点代表的页面放到申请到的extent中,进行范围扫描的效果就大打折扣了(因为非叶子节点不需要进行范围扫描,只有叶子节点需要).

所以InnoDB的设计者对B+树的叶子节点和非叶子节点进行了区别对待.也就是说叶子节点有自己独有的extent,非叶子节点也有自己独有的extent.
存放叶子节点的extent的集合就算是1个段(segment),存放非叶子节点的extent的集合也算是一个segment.
也就是说1个索引会生成2个segment,1个叶子节点segment,一个非叶子节点segment.

默认情况下,一个使用InnoDB存储引擎的表只有1个聚簇索引,1个索引会生成2个segment,而segment是以extent为单位申请存储空间的,
1个extent默认占用1MB存储空间.所以,默认情况下一个只存了几条记录的小表也需要2MB的存储空间么?
以后每次添加一个索引都要多申请2M的存储空间么?这对于存储记录比较少的表简直是天大的浪费.
InnoDB的设计这考虑到了这种情况.这个问题的本质是:**到现在为止我们说的extent都是非常"纯粹"的,也就是1个extent被整个分配给某1个segment,
或者说extent中的所有页面都是为了存储同1个segment的数据而存在的.即使segment的数据填不满extent中所有的页面,那余下的页面也不能挪作他用**.

现在为了考虑"以完整的extent为单位分配给某个segment时,对于数据量较小的表太浪费存储空间"这种情况,
InnoDB的设计者提出了一个碎片(fragment)extent的概念: **在1个fragment extent中,并不是所有的页都是为了存储同1个segment的数据而存在的,
而是fragment extent中的页可以用于不同的目的,比如有些页用于segmentA,有些页用于segmentB,有些页甚至不属于任何segment.
fragment extent直属于表空间,并不属于任何一个segment**.

有了这个概念之后,为某个segment分配存储空间的策略如下:

- 在刚开始向表中插入数据时,segment是从某个fragment extent以单个页面为单位来分配存储空间的
- 当某个segment已经占用了32个fragment extent中的页面(注意这里的单位是页面而不是extent)之后,就会以完整的extent为单位来分配存储空间
  - 原先占用的fragment extent中的页面,并不会复制到新申请的完整的extent中

所以,segment现在不能仅定义为是某些extent的集合,更精确的来说,应该是某些零散的页面以及一些完整的extent的集合.
除了索引的叶子节点segment和非叶子节点segment之外,InnoDB中还有为存储一些特殊的数据而定义的segment,比如回滚segment.
现在并不关心别的类型的segment,现在只需要知道:**segment是一些零散的页面以及一些完整的extent的集合**即可.

注: segment是逻辑上的概念,可以认为segment是一种对extent的管理方式或者者说是对extent的分配方式.

例: 以一个100㎡的房子举例.

- 可以简单粗暴地划分为5个20㎡的房间,每个房间都当做卧室使用
- 也可以划分为:
  - 1个40㎡的主卧
  - 1个20㎡的次卧
  - 1个30㎡的厨房
  - 1个10㎡的卫生间

在这个例子中,segment就相当于房间的划分方式,是一种逻辑上对空间的管理方式;而extent就相当于房子中真实存在的100㎡,是物理意义上真实存在的空间.
