# 3. 使用划分区域的LRU链表进行优化

有了这种被划分成young区域和old区域的LRU链表之后,InnoDB的设计就可以针对之前提到的2种可能降低`Buffer Pool`命中率的情况进行优化了.

- 针对预读的页面可能不进行后续访问的优化

InnoDB的设计者规定:**当磁盘上的某个页面在初次加载到`Buffer Pool`中的某个缓冲页时,该缓冲页对应的控制块会被放到old区域的头部**.
这样一来,针对预读到`Buffer Pool`却不进行后续访问的页面,就会被逐渐从old区域逐出,而不会影响young区域中使用比较频繁的缓冲页.

- 针对全表扫描时,短时间内访问大量使用频率非常低的页面的优化

在进行全表扫描时,虽然首次被加载到`Buffer Pool`中的页放到了old区域的头部,但是后续会被马上访问到,
每次进行访问时又会把该页放到young区域的头部,这样仍然会把那些使用频率比较高的页面给"排挤"下去.
那么,能否在第一次访问该页面时,不将其从old区域移动到young区域的头部,而是在后续访问时再将其移动到young区域的头部?
答案是不行的.因为InnoDB的设计者规定:**每次从页面中读取一条记录,都算是访问了一次该页面**.
而一个页面中可能会包含很多条记录,也就是说读取完某个页面的记录就相当于访问该页面很多次.

全表扫描有一个特点:执行频率非常低(因为谁也不会总写全表扫描的语句).而且在执行全表扫描的过程中,
即使某个页面中有很多条记录,虽然每次读取一条记录都算是访问一次页面,但这个过程所花费的时间也是非常少的.
所以只需要规定: 在对某个位于old区域的缓冲页进行第一次访问时,就在该缓冲页对应的控制块中记录下这个访问时间,
若:

- 后续的访问时间与第一次访问的时间的差值小于某个阈值,则该页面就不会被从old区域移动到young区域的头部
  - "后续的访问时间与第一次访问的时间的差值小于某个阈值"这句话实际上就是对"短时间内频繁访问某个页然后就不访问了"这个情况在时间维度上的描述
- 否则将它移动到young区域的头部

系统变量`innodb_old_blocks_time`用于控制上述的阈值:

```
mysql> SHOW VARIABLES LIKE 'innodb_old_blocks_time';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| innodb_old_blocks_time | 1000  |
+------------------------+-------+
1 row in set (0.05 sec)
```

该变量的作用域为`GLOBAL`,默认值为1000,单位为毫秒.

也就是说,对于从磁盘上被加载到LRU链表的old区域的某个页来说,若第一次和最后一次访问该页面的时间间隔小于1s
(第1次访问与最后1次访问的时间间隔都小于1s了,那么在此期间的任何连续的2次访问之间的时间间隔必然小于1s),则该页不会被加入到young区域.
很明显,在一次全表扫描的过程中,多次访问一个页面(也就是读取同一个页面中的多条记录)的时间不会超过1s.

修改`innodb_old_blocks_time`的值可以通过修改配置文件:

```
root@mysql-master:~# vim /etc/mysql/mysql.conf.d/mysqld.cnf
root@mysql-master:~# cat /etc/mysql/mysql.conf.d/mysqld.cnf
```

```
[server]
# 第1次访问时间之后的指定时长内 若再次访问 则不移动该页面对应的控制块到young区域头部
innodb_old_blocks_time = 2000
```

重启服务后查看变量:

```
mysql> SHOW VARIABLES LIKE 'innodb_old_blocks_time';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| innodb_old_blocks_time | 2000  |
+------------------------+-------+
1 row in set (0.01 sec)
```

综上所述,正是因为将LRU链表划分为young区域和old区域这2个部分,又添加了系统变量`innodb_old_blocks_time`,
使得预读机制和全表扫描造成的`Buffer Pool`命中率降低的问题得到了遏制:因为用不到的预读页面和全表扫描的页面都只会被放到old区域,
而不影响young区域中的缓冲页.
