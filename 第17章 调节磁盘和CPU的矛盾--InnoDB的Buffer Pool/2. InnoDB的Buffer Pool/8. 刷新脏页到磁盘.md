# 8. 刷新脏页到磁盘

后台有专门的线程负责每隔一段时间把脏页刷新到磁盘,这样可以不影响用户线程处理正常的请求.主要有2种刷新路径:

- 从LRU链表的冷数据中刷新一部分页面到磁盘

    后台线程会定时从LRU链表尾部开始扫描一些页面,系统变量`innodb_lru_scan_depth`用于指定扫描的页面数量.若在LRU链表中发现脏页,
    则把它们刷新到磁盘.这种刷新页面的方式被称为`BUF_FLUSH_LRU`.
    
    ```
    mysql> SHOW VARIABLES LIKE 'innodb_lru_scan_depth';
    +-----------------------+-------+
    | Variable_name         | Value |
    +-----------------------+-------+
    | innodb_lru_scan_depth | 1024  |
    +-----------------------+-------+
    1 row in set (0.01 sec)
    ```
    
    该变量的作用域为`GLOBAL`级别,默认值为1024.
    
    注意: `BUF_FLUSH_LRU`的目标是释放`Buffer Pool`空间.它会从LRU链表冷端挑选脏页,若该页是脏页,则就先写回磁盘(异步I/O).
    **I/O完成且确认无新修改后,会从LRU链表中移除该页,并把对应的控制块放回free链表,这样内存就被释放出来**,可以给新的页使用.

- 从flush链表中刷新一部分页面到磁盘

    后台线程也会定时从flush链表中刷新一部分页面到磁盘,刷新的速率取决于当时系统是否繁忙.这种刷新页面的方式被称之为`BUF_FLUSH_LIST`.
    
    注意: **用`BUF_FLUSH_LIST`刷新的是"按最老修改`LSN`顺序的脏页",目的是推进检查点(checkpoint),不是为了腾出`Buffer Pool`空间**
    (这句话的重点是"不是为了腾出`Buffer Pool`空间").写盘成功后, 这些页会被标记为干净页并从flush链表移除,
    但仍留在LRU链表里(保持原来的冷热位置).只有当后续需要内存/发生LRU逐出时,这些干净页才可能被淘汰,其控制块才会回到free链表.

    为更高效地执行脏页刷盘操作,InnoDB设计了许多系统变量来控制刷新的过程,例如:

    - `innodb_flush_neighbors`: 该变量用于控制InnoDB在刷新脏页时,是否顺便把相邻的页也一并刷新到磁盘
    - `innodb_io_capacity_max`: 该变量用于设置InnoDB在高负载情况下允许的最大I/O操作数
    - `innodb_io_adaptive_flushing`: 该变量用于控制InnoDB是否根据当前的工作负载动态调整脏页刷新的速率
    - `innodb_max_dirty_pages_pct`: 该变量用于设置`Buffer Pool`中允许的最大脏页百分比,当脏页比例超过该值时,InnoDB会加快脏页刷新的速度

有时,后台线程刷新脏页的进度比较慢,导致用户线程在准备加载一个磁盘页到`Buffer Pool`中时没有可用的缓冲页.此时会尝试查看LRU链表尾部,
看是否存在可以直接释放掉的未修改缓冲页.若没有,则不得不将LRU链表尾部的1个脏页**同步刷新到磁盘**(和磁盘交互是很慢的,这会降低处理用户请求的速度).
这种刷新单个页面到磁盘中的刷新方式称为`BUF_FLUSH_SINGLE_PAGE`.

当然,在系统特别繁忙时,也可能出现用户线程从flush链表中刷新脏页的情况.很显然,在处理用户请求过程中去刷新脏页
是一种严重降低处理速度的行为(因为磁盘的速度太慢了),这属于一种迫不得已的情况,后续在讲redo日志的checkpoint时再进一步解释.
