# 12. 查看`Buffer Pool`的状态信息

`SHOW ENGINE INNODB STATUS`语句用于查看关于InnoDB存储引擎运行过程中的一些状态信息,其中就包括`Buffer Pool`的一些信息:

```
mysql> SHOW ENGINE INNODB STATUS\G;
*************************** 1. row ***************************
...
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 0
Dictionary memory allocated 477761
Buffer pool size   8192
Free buffers       6991
Database pages     1197
Old database pages 461
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 0, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 1055, created 142, written 184
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
No buffer pool page gets since the last printout
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 1197, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
--------------
...
```

- `Total large memory allocated`: 表示InnoDB使用大页的数量,0表示没有使用大页
- `Dictionary memory allocated`: 为数据字典信息分配的内存空间大小.注意这个内存空间和`Buffer Pool`没有关系,不包括在`Buffer Pool`的大小中
- `Buffer pool size`: 表示该`Buffer Pool`可以容纳的缓冲页个数.注意单位是页
- `Free buffers`: 表示当前`Buffer Pool`空闲缓冲页的个数,即free链表中的节点个数
- `Database pages`: 表示LRU链表中的页的数量,即young区域和old区域节点数量
- `Old database pages`: 表示LRU链表中old区域的节点数量,即old区域中的页的数量
- `Modified db pages`: 表示脏页数量,也就是flush链表中节点的数量
- `Pending reads`: 正在等待从磁盘上加载到`Buffer Pool`中的页面数量
  - 当准备从磁盘中加载某个页面时,会先为该页面在`Buffer Pool`中分配一个缓冲页以及它对应的控制块
  - 然后把这个控制块添加到LRU的old区域的头部
  - 但是此时真正的磁盘页并没有被加载进来
  - 因此`Pending reads`的值会加1,表示"这个位置已经预留好了,但数据还没到"
  - 加载完成后,`Pending reads`的值就会减1
- `Pending writes LRU`: 即将从LRU链表中刷新到磁盘中的页面数量
- `Pending writes flush list`: 即将从flush链表中刷新到磁盘中的页面数量
- `Pending writes single page`: 即将以单个页面的形式刷新到磁盘中的页面数量
- `Pages made young`: 表示LRU链表中曾经从old区域移动到young区域头部的节点数量.注意:
  - 一个节点每次只有从old区域移动到young区域头部时,才会将`Pages made young`的值加1
  - 若该节点本来就在`young`区域,假设该节点位于young区域1/4后面,则下一次访问该页面时也会将它移动到young区域头部,但这个过程并不会导致`Pages made young`的值加1
- `Pages made not young`: 
  - 在将`innodb_old_blocks_time`设置的值大于0时
  - 首次访问或者后续访问某个位于old区域的节点
  - 由于不符合时间间隔的限制而不能将其移动到young区域头部中,则`Page made not young`的值会加1
  - 注意:
    - 位于young区域的节点,若因为它在young区域的前1/4处,而导致它没有被移动到young区域头部,这样的访问并不会将`Page made not young`的值加1
- `youngs/s`: 表示每秒从old区域被移动到young区域头部的节点数量
- `non-youngs/s`: 表示每秒由于不满足时间限制而不能从old区域移动到young区域头部的节点数量
- `Pages read/created/written`: 表示读取/创建/写入了多少页.后边跟着读取/创建/写入的速率(即示例中的`0.00 reads/s, 0.00 creates/s, 0.00 writes/s`部分)
- `Pages read ahead`: 通过预读机制,从磁盘预先读取到`Buffer Pool`的页面数
- `evicted without access`: 那些通过预读机制读入`Buffer Pool`的页面中,在被真正访问之前,就被淘汰(`evict`)出去的页面数量
- `Random read ahead`: 通过随机预读(Random Read Ahead)机制读取的页数
- `LRU len`: 表示LRU链表中节点的数量
- `unzip_LRU`: 表示`unzip_LRU`链表中节点的数量(由于没有具体讲过这个链表,现在可以忽略它的值)
- `I/O sum`: 最近50s读取磁盘页的总数
- `I/O cur`: 现在正在读取的磁盘页数量
- `unzip sum`: 最近50s解压的页面数量
- `unzip cur`: 现在正在解压的页面数量

有一些统计项,在8.X中被移除了:

- `Total memory allocated`: 表示`Buffer Pool`向操作系统申请的连续内存空间大小,包括全部控制块/缓冲页/碎片的大小
  - 在MySQL8.X中,该统计项使用`Buffer pool size * 系统变量innodb_page_size的值`来计算即可,因此不再显示
- `Buffer pool hit rate`: 表示在过去某段时间中,平均访问1000次页面,有多少次该页面已经被缓存到`Buffer Pool`了
  - 在MySQL8.X中,该统计项被移除了,因为该统计项可以通过`performance_schema`中的`INNODB_BUFFER_POOL_STATS`表和`INNODB_METRICS`表来计算
- `young-making rate`: 表示在过去某段时间,平均访问1000次页面,有多少次访问使页面移动到young区域的头部了.注意:
  - 这里统计的将页面移动到young区域的头部次数中
  - 不仅包含从old区域移动到young区域头部的次数
  - 还包括从young区域移动到young区域头部的次数(访问某个young区域的节点,若该节点位于young区域的1/4处后面,则会把它移动到young区域的头部)
- `not (young-making rate)`: 表示在过去某段时间,平均访问1000次页面,有多少次访问没有使页面移动到young区域的头部.注意:
  - 这里统计的没有将页面移动到young区域的头部次数中
  - 不仅仅包含因设置了系统变量`innodb_old_blocks_time`而导致访问了old区域中的节点但没把它们移动到young区域的次数
  - 还包含因该节点位于young区域的前1/4处,而没有被移动到young区域头部的次数
