# 6. `index`

- `index`: 扫描全部二级索引记录的访问方法,称为`index`访问方法。

例如:

```sql
SELECT key_part1, key_part2, key_part3
FROM single_table
WHERE key_part2 = 'abc';
```

由于`key_part2`并不是联合索引`idx_key_part`中最左边的列,所以无法形成合适的扫描区间来减少需要扫描的记录数量,
从而无法使用`ref`或者`range`访问方法来执行该语句.但是该查询符合以下2个条件:

- 查询列表只有3个列: `key_part1`/`key_part2`/`key_part3`,而索引`idx_key_part`包含这三个列
- 该语句中作为搜索条件的列也包含在索引`idx_key_part`中(搜索条件中只有`key_part2`列)

也就是说,可以直接遍历联合索引`idx_key_part`的所有二级索引记录来,针对获取到的每一条二级索引记录,都判断是否符合条件`key_part2 = 'abc'`.
如果成立,就从该二级索引记录中读取`key_part1`/`key_part2`/`key_part3`这3个列的值,然后将它们发送给客户端即可(**不需要回表操作**).
这种情况下,该查询语句对应的扫描空间为:`key_part2 ∈ (-∞, +∞)`.

因为二级索引记录比聚簇索记录小的多,(聚簇索引记录要存储所有用户定义的列以及隐藏列,而二级索引记录只需要存放索引列和主键),
且且这个过程也不用进行回表操作,所以直接扫描全部二级索引比直接扫描全部聚簇索引的成本要小很多.
MySQL的设计者把这种采用扫描全部二级索引记录的访问方法称为`index`.

另外,当通过全表扫描对使用InnoDB存储引擎的表执行查询时,若添加了`ORDER BY 主键`的语句,那么该语句在执行时,
会被**人为地认定为使用`index`访问方法**.

例如:

```sql
SELECT *
FROM single_table
ORDER BY 
`id` ASC;
```

该语句的执行计划如下:

```
mysql> DESC SELECT *
    -> FROM single_table
    -> ORDER BY 
    -> `id` ASC;
+----+-------------+--------------+------------+-------+---------------+---------+---------+------+-------+----------+-------+
| id | select_type | table        | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra |
+----+-------------+--------------+------------+-------+---------------+---------+---------+------+-------+----------+-------+
|  1 | SIMPLE      | single_table | NULL       | index | NULL          | PRIMARY | 4       | NULL | 10200 |   100.00 | NULL  |
+----+-------------+--------------+------------+-------+---------------+---------+---------+------+-------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```
