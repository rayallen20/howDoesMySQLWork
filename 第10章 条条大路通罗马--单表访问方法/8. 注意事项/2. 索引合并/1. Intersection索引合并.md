# 1. Intersection索引合并

现有一查询语句如下:

```sql
SELECT *
FROM single_table
WHERE key1 = 'a'
AND key3 = 'b';
```

当然可以选择使用全表扫描的方式执行该查询,不过由于搜索条件涉及`key1`和`key3`列,因此也可以使用下面2种方案执行该查询:

- 方案1:使用索引`idx_key1`执行该査询

此时对应的扫描区间为`key1 ∈ ['a', 'a']`.对于获取到的每条二级索引记录,根据它的`id`值执行回表操作后获取到完整的用户记录,
再判断是否满足条件`key3 = 'b'`.

注意: 扫描区间`key1 ∈ ['a', 'a']`是一个单点扫描区间,也就是说在该区间内的所有二级索引记录,其`key1`列的值都为`'a'`.
**这也就意味着这些二级索引记录其实是按照主键值进行排序的**.

- 方案2:使用索引`idx_key3`执行该査询

此时对应的扫描区间就是`key3 ∈ ['b', 'b']`.对于获取到的每条二级索引记录,根据它的`id`值执行回表操作后获取到完整的用户记录,
再判断是否满足条件`key1 = 'a'`.

注意: 扫描区间`key3 ∈ ['b', 'b']`是一个单点扫描区间,也就是说在该区间内的所有二级索引记录,其`key3`列的值都为'b'.
**这也就意味着这些二级索引记录其实是按照主键值进行排序的**.

其实除了全表扫描以及上面提到的方案1和方案2之外,还可以有方案3,具体如下:

- 方案3:同时使用索引`idx_key1`和索引`idx_key3`执行査询

也就是在`idx_key1`中扫描`key1 ∈ ['a', 'a']`区间中的二级索引记录,同时在`idx_key3`中扫描`key3 ∈ ['b', 'b']`区间中的二级索引记录,
然后从二者的操作结果中找出`id`列值相同的记录(即找出它们共有的`id`值).然后再根据这些共有的id值执行回表操作(那些仅在单个扫描区间中存在的id值
就不需要执行回表操作了),这样能省下很多回表操作带来的开销.

这里的方案3就是Intersection索引合并.Intersection的中文含义就是"交集",
Intersection索引合并指的就是:**对从不同索引中扫描到的记录的id值取交集,只为这些值执行回表操作**.
**如果使用Intersection索引合井的方式执行查询,且每个使用到的索引都是二级索引的话,
则要求从每个索引中获取到的二级索引记录都是按照主键值排序的**.

在上面的査询中:

- 在索引`idx_key1`的扫描区间`key1 ∈ ['a', 'a']`中的二级索引记录都是按照主键值排序的
- 在索引`idx_key3`的扫描区间`key3 ∈ ['b', 'b']`中的二级索引记录都是按照主键值排序的

为什么会要求从不同二级索引中获取到的二级索引记录都按照主键值排好序呢?这主要出于2方面的考虑:

- 从两个有序集合中取交集比从两个无序集合中取交集要容易得多
- 如果获取到的`id`值是有序排列的,则在根据这些`id`值执行回表操作时,就不再是进行单纯的随机I/O(这些`id`值是有序的),从而会提高效率

假设:

- 在索引`idx_key1`的扫描区间`key1 ∈ ['a', 'a']`中二级索引记录的`id`值是排好序的,且顺序为1/3/5,
- 在索引`idx_key3`的扫描区间`key3 ∈ ['b', 'b']`中二级索引记录的`id`值也是排好序的,且顺序为2/3/4

则该查询在使用Intersection索引合并来执行时,过程如下:

- 步骤1

先从索引`idx_key1`的扫描区间`key1 ∈ ['a', 'a']`中,取出第1条二级索引记录,该记录的主值为1.
然后从索引`idx_key3`的扫描区间`key3 ∈ ['b', 'b']`中取出第1条二级索引记录,该记录的主键值为2.
因为`1 < 2`,所以直接把从索引`idx_key1`中取出的那条主键值为1的二级索引记录丢弃.

- 步骤2

接着继续从索引`idx_key1`的扫描区间`key1 ∈ ['a', 'a']`中取出下1条二级索引记录,该记录的主键值为3.
步骤1中,从索引`idx_key3`的扫描区间`key3 ∈ ['b', 'b']`中取出的二级索引记录的主键值为2.
因为`3 > 2`,所以直接把步骤1中从索引`idx_key3`的扫描区间`key3 ∈ ['b', 'b']`中取出的那条主键值为2的二级索引记录丢弃.

- 步骤3

接着继续从索引`idx_key3`的扫描区间`key3 ∈ ['b', 'b']`中取出下1条二级索引记录,该记录的主键值为3.
步骤2中,索引`idx_key1`的扫描区间`key1 ∈ ['a', 'a']`中取出的二级索引记录的主键值为3.
因为`3 == 3`,也就意味着获取主键交集成功,然后根据该主键值执行回表操作,获取到完整的用户记录后将其发送给客户端.

- 步骤4

接着从索引`idx_key1`的扫描区间`key1 ∈ ['a', 'a']`中取出下1条二级索引记录,该记录的主键值为5.
然后从索引`idx_key3`的扫描区间`key3 ∈ ['b', 'b']`中取出下1条二级索引记录,该记录的主键值为4.
因为`5 > 4`,所以直接把从索引`idx_key3`的扫描区间`key3 ∈ ['b', 'b']`中取出的那条主键值为4的二级索引记录丢弃.

- 步骤5

接着从索引`idx_key3`的扫描区间`key3 ∈ ['b', 'b']`中取出下1条符合条件的二级索引记录.发现没有了,结束查询.

这里写得复杂,但其实这个执行过程很快.

该查询语句的执行计划如下:

```
mysql> DESC SELECT *
    -> FROM single_table
    -> WHERE key1 = 'a'
    -> AND key3 = 'b';
+----+-------------+--------------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
| id | select_type | table        | partitions | type | possible_keys     | key      | key_len | ref   | rows | filtered | Extra       |
+----+-------------+--------------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | single_table | NULL       | ref  | idx_key3,idx_key1 | idx_key3 | 403     | const |    1 |     5.00 | Using where |
+----+-------------+--------------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.02 sec)
```

注: 这里并没有从执行计划中看到Intersection索引合并的相关信息,我也不知道原因.但是后续有能够看到Intersection索引合并的执行计划的例子.

如果在使用某个二级索引执行查询时,从对应的扫描区间中读取出的二级索引记录不是照主键值排序的,则不可以使用Intersection索引合并来执行查询.
例如:

```sql
SELECT *
FROM single_table
WHERE key1 > 'a'
AND key3 = 'b';
```

因为从索引`idx_key1`的扫描区间`key1 ∈ (a, +∞)`中获取到的记录并不是按照主键值排序的,所以该查询不能使用Intersection索引合并来执行.

该查询语句的执行计划如下:

```
mysql> DESC SELECT *
    -> FROM single_table
    -> WHERE key1 > 'a'
    -> AND key3 = 'b';
+----+-------------+--------------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
| id | select_type | table        | partitions | type | possible_keys     | key      | key_len | ref   | rows | filtered | Extra       |
+----+-------------+--------------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | single_table | NULL       | ref  | idx_key3,idx_key1 | idx_key3 | 403     | const |    1 |    50.00 | Using where |
+----+-------------+--------------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

再来看一个例子:

```sql
SELECT *
FROM single_table
WHERE key1 = 'a'
AND key_part1 = 'a';
```

对于联合索引`idx_key_part`来说,它的二级索引记录是先按照`key_part1`列的值进行排序的,在`key_part1`值相同的情况下,
再按照`key_part2`值进行排序.那么在二级索引`idx_key_part`中,`key_part1`值为`'a'`的二级索引记录并不是按照主键值进行排序的,
所以该查询也不能使用Intersection索引合并的方式执行.

该查询语句的执行计划如下:

```
mysql> DESC SELECT *
    -> FROM single_table
    -> WHERE key1 = 'a'
    -> AND key_part1 = 'a';
+----+-------------+--------------+------------+------+-----------------------+--------------+---------+-------+------+----------+-------------+
| id | select_type | table        | partitions | type | possible_keys         | key          | key_len | ref   | rows | filtered | Extra       |
+----+-------------+--------------+------------+------+-----------------------+--------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | single_table | NULL       | ref  | idx_key_part,idx_key1 | idx_key_part | 403     | const |    1 |     5.00 | Using where |
+----+-------------+--------------+------------+------+-----------------------+--------------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

另外,聚簇索引是比较特殊的存在,因为聚簇索引记录本身就是按照主键值进行排序的.比如下面这个查询:

```sql
SELECT *
FROM single_table
WHERE key1 = 'a'
AND id > 9000;
```

- 从索引`idx_key1`的扫描区间`key1 ∈ ['a', 'a']`中获取的二级索引记录是按照主键值排序的
- 从聚簇索引的扫描区间`id ∈ (9000, +∞)`中获取的聚簇索引记录也是按照主键值排序的

所以上述查询可以使用Intersection索引合并的方式执行.
但是在实现这种包含聚簇索引的Intersection索引合并方法时,并不会真正地扫描聚簇索引记录.那么它是怎么实现的呢?

二级索引记录是包含索引列和主键列的,在索引列值相同的情况下,二级索引记录是按照主键值的大小排序的.
所以该查询在使用Intersection索引合并时,搜索条件`id > 9000`其实并不会为聚簇索引形成扫描区间`id ∈ (9000, +∞)`,
而是与搜索条件`key1 = 'a'`一起在索引`idx_key1`中形成扫描区间`(key1, id) ∈ (('a', 9000), ('a', +∞))`.
也就是说可以直接使用索引`idx_key1`执行査询,定位到符合条件`key1 = 'a' AND id > 9000`的第1条二级索引记录,
然后沿着记录所在的单向链表向后扫描,直到某条记录不符合条件`key1 = 'a'`或条件`id > 9000`为止.
当然,针对获取到的每一条二级索引记录,都需要执行回表操作.在这个过程中不需要扫描聚簇索引的扫描区间`id ∈ (9000, +∞)`中的聚簇索引记录.

该查询语句的执行计划如下:

```
mysql> DESC SELECT *
    -> FROM single_table
    -> WHERE key1 = 'a'
    -> AND id > 9000;
+----+-------------+--------------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+
| id | select_type | table        | partitions | type        | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                                          |
+----+-------------+--------------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+
|  1 | SIMPLE      | single_table | NULL       | index_merge | PRIMARY,idx_key1 | idx_key1,PRIMARY | 407,4   | NULL |    1 |   100.00 | Using intersect(idx_key1,PRIMARY); Using where |
+----+-------------+--------------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+
1 row in set, 1 warning (0.01 sec)
```
在执行计划中,可以看到`type`列的值为`index_merge`,表示使用了索引合并的方式执行查询.
且在`Extra`列中可以看到,是索引`idx_key1`和聚簇索引`PRIMARY`之间发生了Intersection索引合并.
