# 2. Union索引合并

现有一查询语句如下:

```sql
SELECT *
FROM single_table
WHERE key1 = 'a'
OR key3 = 'b';
```

能仅使用`idx_key1`或`idx_key3`执行上述査询吗?答案肯定是不行的.
以`idx_key1`为例,假如使用`idx_key1`执行该査询,则对应的扫描区间就是`key1 ∈ (-∞, +∞)`,
而且需要针对获取到的每一条二级索引记录,都执行回表操作.在这种情况下是不使用`idx_key1`执行该査询的.
针对`idx_key3`也是同理.

那么,就只能使用全表扫描的方式执行该查询吗?也不是.可以同时使用`idx_key1`和`idx_key3`来执行査询.即:

- 在`idx_key1`中扫描区间`key1 ∈ ['a', 'a']`中的二级索引记录
- 同时在`idx_key3`中扫描区间`key3 ∈ ['b', 'b']`中的二级索引记录
- 然后根据二级索引记录的`id`值在两者的结果中进行去重
- 最后,再根据去重后的`id`值执行回表操作,这样重复的i值只需回表一次

这种方案就是Union索引合并.Union的中文含义就是"并集",
Union素引合并指的就是:**对从不同索引中扫描到的记录的id值取并集,然后为这些`id`值执行回表操作**.

如果使用Union索引合并的方式执行査询,且每个使用到的索引都是二级索引的话,则要求从每个索引中获取到的二级索引记录都是按照主键值排序的.
比如该査询中:

- 在`idx_key1`中扫描区间`key1 ∈ ['a', 'a']`中的二级索引记录都是按照主键值排序的
- 在`idx_key3`中扫描区间`key3 ∈ ['b', 'b']`中的二级索引记录也都是按照主键值排序的

这也是出于以下2个方面的考虑:

- 从两个有序集合执行去重操作比从两个无序集合中执行去重操作容易一些
- 如果获取到的`id`值是有序排列的,则在根据这些`id`值执行回表操作时,就不再是进行单纯的随机I/O(这些`id`值是有序的),从而会提高效率

该语句的执行计划如下:

```
mysql> DESC SELECT *
    -> FROM single_table
    -> WHERE key1 = 'a'
    -> OR key3 = 'b';
+----+-------------+--------------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
| id | select_type | table        | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |
+----+-------------+--------------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
|  1 | SIMPLE      | single_table | NULL       | index_merge | idx_key3,idx_key1 | idx_key1,idx_key3 | 403,403 | NULL |    2 |   100.00 | Using union(idx_key1,idx_key3); Using where |
+----+-------------+--------------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+
1 row in set, 1 warning (0.00 sec)
```

如果在使用某个二级索引执行查询时,从对应的扫描区间中读取出的二级索引记录不是按照主键值排序的,则不可以使用Union索引合并的方式执行査询.
例如:

```sql
SELECT *
FROM single_table
WHERE key1 > 'a'
OR key3 = 'b';
```

因为从索引`idx_key1`的扫描区间`key1 ∈ ('a', +∞)`中获取到的二级索引记录并不是按照主键值排序的,所以该査询不能使用Union索引合并的方式执行.

该语句的执行计划如下:

```
mysql> DESC SELECT *
    -> FROM single_table
    -> WHERE key1 > 'a'
    -> OR key3 = 'b';
+----+-------------+--------------+------------+------+-------------------+------+---------+------+-------+----------+-------------+
| id | select_type | table        | partitions | type | possible_keys     | key  | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+--------------+------------+------+-------------------+------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | single_table | NULL       | ALL  | idx_key3,idx_key1 | NULL | NULL    | NULL | 10200 |    33.34 | Using where |
+----+-------------+--------------+------------+------+-------------------+------+---------+------+-------+----------+-------------+
1 row in set, 1 warning (0.06 sec)
```

另一个例子:

```sql
SELECT *
FROM single_table
WHERE key1 = 'a'
OR key_part1 = 'a';
```

对于联合索引`idx_key_part`来说,它的二级索引记录是先按照`key_part1`列的值进行排序的,在`key_part1`值相同的情况下,
再按照`key_part2`值进行排序.那么在二级索引`idx_key_part`中,`key_part1`值为`'a'`的二级索引记录并不是按照主键值进行排序的,
所以该查询也不能使用Union索引合并的方式执行.

该查询语句的执行计划如下:

```
mysql> DESC SELECT *
    -> FROM single_table
    -> WHERE key1 = 'a'
    -> OR key_part1 = 'a';
+----+-------------+--------------+------------+-------------+-----------------------+-----------------------+---------+------+------+----------+------------------------------------------------------+
| id | select_type | table        | partitions | type        | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                                |
+----+-------------+--------------+------------+-------------+-----------------------+-----------------------+---------+------+------+----------+------------------------------------------------------+
|  1 | SIMPLE      | single_table | NULL       | index_merge | idx_key_part,idx_key1 | idx_key1,idx_key_part | 403,403 | NULL |    2 |   100.00 | Using sort_union(idx_key1,idx_key_part); Using where |
+----+-------------+--------------+------------+-------------+-----------------------+-----------------------+---------+------+------+----------+------------------------------------------------------+
1 row in set, 1 warning (0.00 sec)
```

注意这里使用的是Sort-Union索引合并,不是Union索引合并.

另外,聚簇索引是比较特殊的存在,因为聚簇索引记录本身就是按照主键值进行排序的.比如下面这个查询:

```sql
SELECT *
FROM single_table
WHERE key1 = 'a'
OR id > 9000;
```

- 从索引`idx_key1`的扫描区间`key1 ∈ ['a', 'a']`中获取的二级索引记录是按照主键值排序的
- 从聚簇索引的扫描区间`id ∈ (9000, +∞)`中获取的聚簇索引记录也是按照主键值排序的

所以上述查询可以使用Union索引合并的方式执行.

该查询语句的执行计划如下:

```
mysql> DESC SELECT *
    -> FROM single_table
    -> WHERE key1 = 'a'
    -> OR id > 9000;
+----+-------------+--------------+------------+-------------+------------------+------------------+---------+------+------+----------+--------------------------------------------+
| id | select_type | table        | partitions | type        | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                                      |
+----+-------------+--------------+------------+-------------+------------------+------------------+---------+------+------+----------+--------------------------------------------+
|  1 | SIMPLE      | single_table | NULL       | index_merge | PRIMARY,idx_key1 | idx_key1,PRIMARY | 403,4   | NULL | 1001 |   100.00 | Using union(idx_key1,PRIMARY); Using where |
+----+-------------+--------------+------------+-------------+------------------+------------------+---------+------+------+----------+--------------------------------------------+
1 row in set, 1 warning (0.00 sec)
```

对于下面这个查询:

```sql
SELECT *
FROM single_table
WHERE ( 
    key_part1 = 'a'
    AND
    key_part2 = 'b'
    AND
    key_part3 = 'c'
) OR (
    key1 = 'a'
    AND
    key3 = 'b'
);
```

可以先通过索引`idx_key1`和`idx_key3`执行Intersection索引合并,这样可以找到符合条件`(key1 ='a' AND key3 ='b')`的记录,
然后再和联合索引`idx_key_part`执行Union索引合并即可.

该语句的执行计划如下:

```
mysql> DESC SELECT *
    -> FROM single_table
    -> WHERE ( 
    ->     key_part1 = 'a'
    ->     AND
    ->     key_part2 = 'b'
    ->     AND
    ->     key_part3 = 'c'
    -> ) OR (
    ->     key1 = 'a'
    ->     AND
    ->     key3 = 'b'
    -> );
+----+-------------+--------------+------------+-------------+--------------------------------+--------------------------------+--------------+------+------+----------+---------------------------------------------------------------------+
| id | select_type | table        | partitions | type        | possible_keys                  | key                            | key_len      | ref  | rows | filtered | Extra                                                               |
+----+-------------+--------------+------------+-------------+--------------------------------+--------------------------------+--------------+------+------+----------+---------------------------------------------------------------------+
|  1 | SIMPLE      | single_table | NULL       | index_merge | idx_key3,idx_key_part,idx_key1 | idx_key_part,idx_key3,idx_key1 | 1209,403,403 | NULL |    2 |   100.00 | Using union(idx_key_part,intersect(idx_key3,idx_key1)); Using where |
+----+-------------+--------------+------------+-------------+--------------------------------+--------------------------------+--------------+------+------+----------+---------------------------------------------------------------------+
1 row in set, 1 warning (0.00 sec)
```
