# 3. Sort-Union索引合并

Union索引合并的使用条件太苛刻,它必须保证从各个索引中扫描到的记录的主键值是有序的.例如下面这个查询就无法使用Union索引合并:

```sql
SELECT *
FROM single_table
WHERE key1 < 'a'
OR key3 > 'z';
```

但是条件`key1 < 'a'`和条件`key3 > 'z'`又特别让人动心,所以可以这样:

- 先根据条件`key1 < 'a'`从索引`idx_key1`的二级索引记录中获取记录,并按照记录的主键值进行排序
- 再根据条件`key3 < 'z'`从索引`idx_key3`的二级索引记录中获取记录,并按照记录的主键值进行排序
- 上述2个二级索引主键值都是排好序的,剩下的操作和Union索引合并的方式就完全相同了

上述这种"先将从各个索引中扫描到的记录进行排序,再按照执行Union索引合并方式执行查询"的方式就是Sort-Union索引合并.
很显然,这种Sort-Union索引合并比单纯的Union索引合并多了一步对二级索引记录的主键值排序的过程.

该查询语句的执行计划如下:

```
mysql> DESC SELECT *
    -> FROM single_table
    -> WHERE key1 < 'a'
    -> OR key3 > 'z';
+----+-------------+--------------+------------+------+-------------------+------+---------+------+-------+----------+-------------+
| id | select_type | table        | partitions | type | possible_keys     | key  | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+--------------+------------+------+-------------------+------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | single_table | NULL       | ALL  | idx_key3,idx_key1 | NULL | NULL    | NULL | 10200 |    55.55 | Using where |
+----+-------------+--------------+------------+------+-------------------+------+---------+------+-------+----------+-------------+
1 row in set, 1 warning (0.03 sec)
```

注: 这里我的执行计划并没有使用到Sort-Union索引合并,而是使用了全表扫描.
我猜测这是因为MySQL的优化器在执行计划生成时,会根据各个索引的选择性来决定是否使用索引合并.如果某个索引的选择性较低,则可能不会使用索引合并,而是直接进行全表扫描.

注:

为什么只有Sort-Union索引合并,没有Sort-Intersection索引合并么? 是的,的确没有Sort-Intersection索引合并.
在MySQL的近亲--MariaDB数据库中实现了Sort-Intersection索引合并.

一种猜测认为,Sort-Union索引合并针对的是"单独根据搜索条件从某个二级索引中获取的记录数比较少"的使用场景,
这样即使对这些二级索引记录按照主键值进行排序,成本也不会太高.

而Intersection索引合并针对的是"单独根据搜索条件从某个二级索引中获取的记录数太多,导致回表成本太大"的使用场景,
使用Intersection索引合并后可以明显降低回表成本(取交集的目的就是为了减少需要回表的二级索引记录的数量).
但是,如果加入Sort-Intersection索引合并,就需要为大量的二级索引记录按照主键值进行排序,这个成本可能比使用单个二级索引执行查询的成本都要高,
于是MySQL的设计者就没有引入Sort-Intersection索引合并这个访问方法.
