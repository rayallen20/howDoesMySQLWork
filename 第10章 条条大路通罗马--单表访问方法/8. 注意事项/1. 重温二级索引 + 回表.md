# 1. 重温二级索引 + 回表

在使用索引来减少需要扫描的记录数量时,一般情况下只会为单个索引生成扫描区间,例如:

```sql
SELECT *
FROM single_table
WHERE key1 = 'abc'
AND key2 > 1000;
```

查询优化器会识别到这个查询中的2个搜索条件:

- `key1 = 'abc'`
- `key2 > 1000`

如果使用`idx_key1`执行查询,则对应的扫描区间为`key1 ∈ [abc, abc]`;如果使用`idx_key2`执行查询,则对应的扫描区间为`key2 ∈ (1000, +∞)`.
优化器会通过访问表中的少量数据或者直接根据事先生成的统计数据,来计算扫描区间`key1 ∈ [abc, abc]`中包含的记录数量,
再计算扫描区间`key2 ∈ (1000, +∞)`中包含的记录数量,之后再通过一定算法来计算使用这2个扫描区间执行查询时的成本分别是多少,最后选择成本较小
的那个扫描区间对应的索引执行查询(关于选择使用哪个索引进行查询的具体步骤后边会讲到)

一般来说,等值查找比范围查找需要扫描的记录数更少(也就是`ref`访问方法一般比`range`访问方法好,但这并不总成立,也有可能在采用`ref`方法访问时,
使用的索引列为特定值值的行数特别多,导致还不如全表扫描).这里假设优化器决定使用`idx_key1`索引进行查询,那么整个查询的执行过程如下:

- 步骤1

先通过`idx_key1`对应的B+树定位到扫描区间`key1 ∈ [abc, abc]`中的第1条二级索引记录.

- 步骤2

根据从上一步中得到的二级索引记录的主键值执行回表操作,得到完整的用户记录,再检测该记录是否满足条件`key2 > 1000`.若满足则将其发送给客户端;
否则将其忽略.

- 步骤3

再根据该记录所在的单向链表找到下一条二级索引记录,重复步骤2中的操作,直到某条二级索引记录不再满足条件`key1 = 'abc'`为止.

注:

从上文可以看出,每次从二级索引中读取到1条记录后,就会根据该记录的主键值执行回表操作.针对某个扫描区间中的这些二级索引记录而言,其主键值是无序的,
也就是说这些二级索引记录对应的聚簇索引记录所在的页面的页号是无序的.每次执行回表操作时都相当于要随机读取一个聚簇索引页面,而这些随机I/O带来的
性能开销比较大.于是MySQL的设计者提出了一个名为`Disk-Sweep Multi-Range Read`(MRR,多范围读取)的优化措施,即:**先读取一部分二级索引记录,
将它们的主键值排好序之后再统一执行回表操作**.相对于每读取1条二级索引记录就立即执行回表操作,这样会节省一些I/O开销.当然使用这个MRR优化措施
的条件比较苛刻,所以就直接认为每读取1条二级索引记录就立即执行回表操作即可.
